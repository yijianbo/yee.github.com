<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>做好职场中的抽象类</title>
      <link href="/2019/07/14/%E5%81%9A%E5%A5%BD%E8%81%8C%E5%9C%BA%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>/2019/07/14/%E5%81%9A%E5%A5%BD%E8%81%8C%E5%9C%BA%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>在面向对象特性的语言特性中，「抽象类」是一种特别有意思的存在，对于日常只关注于事务脚本型的应用层开发者而言，一般很少涉及到抽象类的使用。据我观察，大部分人对「抽象类」的理解要么比较模糊，要么比较浅显，我特意采访了几个团队的小伙伴，抛出了几个问题：</p><blockquote><p>yee：「抽象类」存在的意义是什么？</p><p>小伙伴：抽象类就是为了【复用】吧。可以将一部分【确定性】的方法预先实现好，子类继承它就可以直接使用了呀。</p><p>yee：【复用】不一定要定义抽象类呀，就写个普通类也完全可以供子类继承呀。而且对【复用】的需求而言，「组合」比「集成」更灵活，一般不建议直接通过「继承」来实现【复用】。</p><p>小伙伴：（傻了）……</p><p>yee：你们有没有觉得「抽象类」有一种“比上不足比下有余”的尴尬。</p><p>比上不足部分：就【抽象度】而言，「Interface」 的抽象度更高呀，也更能准确的表达API的意义。「抽象类」也有「抽象方法」，但是它是一个孤立的存在（单看它本身的方法定义是无法明确知道它到底要干嘛），要知道抽象方法背后的意义，还得看它子类的逻辑。</p><p>比下有余部分：相对于「普通类」，「抽象类」多了一个「abstract」关键字，意味着它能定义一些不需要实现的方法，多了一些抽象的描述能力（这个抽象能力完全可以用 inteface 实现）。但是，这也意味着抽象类本身不能被实例化，那么，一个不能被实例化的类，对于普通类而言，有啥不可替代的优势？</p><p>小伙伴：是哦，有存在意义么…..</p><p>WTF 😹😹😹</p></blockquote><p>其实，我问的这几个问题，也是多年来我自己的认知比较模糊的部分。直到最近体系化的重温软件架构设计模式，幸运的阅读了日本技术作家结城浩的<a href="https://book.douban.com/subject/26933281/" target="_blank" rel="noopener">图解设计模式</a>，里面讲模板方法的时候，将这部分的内容讲透了。</p><blockquote><p>PS.</p><ol><li>这本书也是我这几年读 的GOF 相关书籍里面，推荐度最高的一本。日本人的文风比较朴实，每一种模式结构讲的特别质朴，少了很多人为增加的复杂度，作者重点放在如何把模式的本质和关键角色将明白，而不是如何把模式套进去（这是很多欧美作品的通病）。翻译老师的功底也很棒，很多地方做了本土化，完全没有欧美技术作品的生硬感。</li><li>GOF的分类设计很重要。大部分书将设计模式分为构造型、行为型、结构型。这种分类方式有一定的简化信息的作用，但是还是很抽象，场景化不够。而本书采用了非常场景化的分类方法，非常好理解。如【模板方法模式】就被分类到了【交给子类】。【交给子类】有很多场景：<ul><li>交给子类去实现方法</li><li>交给子类去构建实例</li></ul></li><li>要学习设计模式，首次得对接口、抽象类、普通类的存在意义具备一定的理解。而【模板方法】模式是最好的入门场景。本书也将这个模式放在相当靠前的位置，这对后续的模式理解有非常好的基石作用。几乎其他所有的讲GOF 的书，都是机械的按照三大分类进行顺序编排，一上来就是简单工厂模式等，让人非常沮丧。</li></ol></blockquote><p>模板方法的本质一句话就可以概括：</p><blockquote><p>父类实现关键步骤，子类实现具体步骤。</p><p>翻译一下：</p><p>在父类中将业务处理的总体框架（关键步骤）中进行定义，总体框架会调度编排一系列具体方法，完成总体业务逻辑。而这些具体方法父类没有能力实现（因为它不知道业务场景，或者业务场景非常多，必须每个场景有一个应付的子类），都交给子类根据实际场景进行实现。</p></blockquote><p>在这个设计模式里面，抽象类的意义就完全体现出来了：</p><ol><li>抽象类能定义普通方法，这个普通方法可以实现并定义关键步骤，总领程序包的业务框架处理。</li><li>抽象类能定义抽象方法，抽象粒度得当，给不同的子类留下了场景化的空间，子类在理解总体处理框架的基础上，结合自己场景进行抽象方法的实现。</li></ol><p>从这个点上而言，如下三者的抽象度依次减弱，从接口到普通类，确实需要一个过渡角色（抽象类）进行衔接，以便完成统一的统领性关键业务。</p><blockquote><p> 接口 –&gt; 抽象类–&gt; 普通类</p><p>抽象度依次减弱。</p></blockquote><p>更进一步思考，我们在编写程序的时候，更多的是从「子类思维」的角度去考虑：</p><ul><li>继承父类，有什么现成的方法可以直接用</li><li>继承父类，可以新增什么方法以便新增能力</li><li>继承父类，可以重写什么方法改写类的能力</li></ul><p>而抽象类的存在是从「父类思维」的角度考虑：</p><ul><li>定义了哪些方法，<code>要求</code>子类去实现</li><li>定义了那些关键步骤，<code>期待</code>子类理解并遵循关键步骤的统领</li></ul><p>讲到这里，软件架构领域的抽象类角色就差不多了。而我想将「抽象类思考」导入到职场领域。</p><p>很多人对抽象类的理解过于简单，认为它是一个鸡肋般的存在，程序有它没它都一样。这就像在公司里一些眼界相相对狭窄的工程师对部门领导的感觉一样，总认为部门领导又不在一线编码，也没有实现什么关键功能，更谈不上技术体系的重大贡献了。当然这种情况是相对极端，现代的 IT 团队，技术领导一般还是紧贴一线，就算不直接参与编码工作，也会在架构设计，解决方案上深度参与。一般来说，一线工程师还是相对认可领导的。</p><p>更具参考价值的另一个维度，是抽象类们本身的构建能力。要把一个抽象类定义好并不简单，该抽象那些方法，方法之间的边界和关系是什么，该实现那些关键方法，如何调度具体方法，都是抽象类要统一考虑的。而职场中的业务负责人，就是对标这个抽象类的角色。业务体系的关键步骤是什么，如何调度具体步骤，哪些具体步骤应该提出规范，提出规范以后如何贯彻到子类（员工）去实现，都是需要重点考虑的，这也是相当考验业务主导的经验和能力。要做好抽象类，得深入场景，对多个复杂场景有一定的共性抽取能力，才能完成方法的抽象。业务中也是这样，对业务背景的理解，才能定义好目标，用好不同的人以应对不同的场景，</p><p>总之，抽象类被忽略挺多，被误解挺多，要想掰正抽象类的位置，还得抽象类本身表达出优雅的共性抽取能力和总领能力。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论有效的学习方法</title>
      <link href="/2019/06/27/%E8%AE%BA%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2019/06/27/%E8%AE%BA%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>学习方法在很多人看来是一个很玄的事情，五花八门的，涉及到的内容特别多，包括且不限于：</p><ul><li>时间规划管理课</li><li>学习笔记整理术</li><li>记忆力锻炼法</li><li>如何治疗拖延症</li><li>……</li></ul><p>这些东西，在我看来，不仅杂乱，而且根本没有抓住学习方法的精髓，很多东西就是看起来架势足，花样多，实际上并没有什么卵用，有点类似于吃饭前各种拍照，仅仅为了发个朋友圈。</p><p>职业生涯这么多年，从我自己的自主学习经验来看，真正有效的学习方法，往往是简单的，而且是统一的。说简单，我是说没有太多花架子，就是那么几招，相对来说就能保证较好的学习效果；说统一，是指那些真正厉害的人，采取的方法最终都大同小异，底层逻辑都是相通的，大家坐下来把各自经验分享一番以后，都会忍不住频频点头，大有英雄所见略同的感受。</p><p>首先，我对「学习」的本质有个粗浅的认知：</p><blockquote><p>学习是由「输入」+「输出」共同组成。我们学习一个知识，无非是对一些学习材料进行阅读、消化，形成自己的理解，最终在工作和生活中应用，或复述表达给其他人。</p><p>刚刚说的这个过程，可以总结为：</p><ul><li><p>输入： 阅读，消化，理解</p></li><li><p>输出： 应用，复述，表达</p></li></ul></blockquote><p>要查验学习效果，主要看「输出」的效果。而要保证学习的质量，首先要保证「输入」的信息质量。基于这个思考，我提炼了几个我认为非常关键的学习方法：</p><blockquote><ul><li>主题式学习</li><li>带着问题找答案</li><li>归纳总结</li><li>事上练</li></ul></blockquote><p>这几个点都特别朴素，却是真正落地的，避无可避的落地点。基于学习阶段分为「输入」「输出」的思考，我们可以分类一下：</p><table><thead><tr><th>阶段</th><th>方法</th></tr></thead><tbody><tr><td>输入</td><td>主题式学习</td></tr><tr><td></td><td>带着问题找答案</td></tr><tr><td>输出</td><td>归纳总结</td></tr><tr><td></td><td>事上练</td></tr></tbody></table><h2 id="主题式学习"><a href="#主题式学习" class="headerlink" title="主题式学习"></a>主题式学习</h2><p>在豆瓣高分奇书《如何阅读一本书》中，作者把阅读（其实就是学习）这件事情分为 4 个段位，分别是：</p><ul><li>基础阅读</li><li>检视阅读</li><li>分析阅读</li><li>主题阅读</li></ul><p>对于专业知识的学习，我个人的经验，真正有效的只有「主题阅读」。为什么呢，因为主题阅读这个其实就是扩大信息范围，过滤信息质量，对庞大的信息库进行整理，根据主题下梳理出来的主干（通常是个思维导图），系统性进行学习。主题式学习的效果显而易见：</p><ol><li>主题明确，系统框架清晰，整个学习的目标非常清晰，学习范围也划定好了，最重要的是：因为有了学习主干，我们就知道什么是重点，什么是需要花大力气的，这个直接决定了学习效果。</li><li>主干清晰，也更有利于指导自己做长期规划，减少因学习的偶尔中断，进度延缓而带来的焦虑和挫败感。</li><li>主题学习往往对同一个知识点要阅读很多材料，多份信息相互印证，既加深了学习过程中的印象，无形中我们也会自动整理，将多份材料抽取为自己的话语体系。</li></ol><h2 id="带着问题找答案"><a href="#带着问题找答案" class="headerlink" title="带着问题找答案"></a>带着问题找答案</h2><p>这一点，我认为是学习效果保障中最最重要的一条，不接受任何反驳。以我学习新技术「Hbase」为例，我知道这是一个数据库，在学习之前，根据自己的需求，结合以前的数据库经验，我整理了如下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 为什么要用它，它解决了 mysql/MONGODB（另外的数据库）哪些无法解决的问题？</span><br><span class="line">- 它是列式数据库，那和之前的SQL，文档数据库的设计范式有什么区别？</span><br><span class="line">- 如何进行基本的 CRUD 操作？</span><br><span class="line">- 有没有方案转换为我们熟悉的操作模式（如 SQL）？</span><br><span class="line">- 它的 RowKey 模式只能取一行数据，如果我要根据其他的信息进行检索，有何方案,性能如何？</span><br><span class="line">- ......</span><br></pre></td></tr></table></figure><p>这些问题直接指导了我下一步的学习方向和学习重点，当然，这些问题也不是一开始就全冒出来的，而是在学习的过程中，接触到了它的一些新概念，我对这些概念冒出的疑问。<br>正是有了这些问题，我在信息搜集的过程中就把解决这个问题作为最高优先级，无形中对信息质量的获取和过滤，直奔答案，效率最高。一个个问题解决下来，基本上知识也就消化了。</p><p>其实这个点还可以进一步发散一下：</p><ul><li>组会讨论前，准备一些议题，会议才能聚焦，大家也会围绕着如何提出解决方案而展开讨论，能防止多人讨论变为头脑风暴，大家都在放飞自我。</li><li>上课学习前，预习准备下，形成一些自己的问题，在老师讲课的时候，会特别关注这些问题的答案，上课也更专注，学习效果会好很多。</li></ul><p>真正的学霸都是会提问的人。</p><h2 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h2><p>归纳总结非常重要，这是将他人的知识内化为自己的知识最关键的一步。很多时候，我们看书的时候，作者的话都能理解，合上以后完全不记得他讲了什么。这就是把读书作为享受，与刷抖音没有本质区别。真正的高手一定会做两件事情：</p><ul><li>重点摘抄</li><li>系统性归纳<br>将这些重点记下来，并通过自己的理解将他们串起来，形成一套可以用自己话语体系复述出来的论点，这就是归纳总结的过程。能将陌生的知识按照自己的理解（而不是原来的顺序）复述出来，是检验是否理解了的唯一标准。</li></ul><h2 id="事上练"><a href="#事上练" class="headerlink" title="事上练"></a>事上练</h2><p>很多时候我们都在强调学习方法，强调思维模式，强调各种花哨的姿势，但是，真正的高手，从来不会去主动关注这些，因为，大家强调的那些东西，对于他们而言，就和吃饭喝水呼吸一样，是自然而然的生理调度，他们根本就意识不到还需要强调这个。没有一个人跳出来说：</p><blockquote><p>我教大家用什么姿势呼吸。</p></blockquote><p>如何将知识的运用做到像呼吸一样自然，从我自己的职业感受（工程师，需要大量编码）而言，就是在工作中大量的使用和锻炼，简化为王阳明的三字真言：</p><blockquote><p>事上练</p></blockquote><p>还是以我学习 HBASE 的体验为例，虽然我对 Hbase 的基础知识掌握的很好了，无非就是一些基础的 CRUD，架构组合，场景应用。但是如果在工作中没有应用它，没有在任何一个项目中启用这套体系，很多东西我心里都是很虚的，在实际工作中会遇到哪些坑，哪些场景下有哪些最佳实践，这些，都是「事上练」才能带来的额外知识，是最宝贵的部分。<br>当我有了几个关于 Hbase 的项目经验，日常的那些基本操作，使用模式已经内化到的手指（而非大脑）上了，我的手指一碰到键盘，自然而然就敲出了相应的命令和代码，这就是把知识做到了像呼吸一样自然的生理调度。</p><p>前段时间高考刚刚结束，不是优秀的小哥哥学霸在分享他们的学习方法，可能名词、叫法都不太一样，但是这些方法的本质，都落到了我说的这几个点上，再次验证了我的认知：真正美的东西，一定是简单朴素的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>愿为专业付费</title>
      <link href="/2019/06/24/%E6%84%BF%E4%B8%BA%E4%B8%93%E4%B8%9A%E4%BB%98%E8%B4%B9/"/>
      <url>/2019/06/24/%E6%84%BF%E4%B8%BA%E4%B8%93%E4%B8%9A%E4%BB%98%E8%B4%B9/</url>
      
        <content type="html"><![CDATA[<p>最近这段时间在思考重新构建自己的一线技术敏感度，一直希望大数据方向有一些积累，经过一段时间的研究和学习，大概摸清楚了大数据的体系架构，在庞大的专业术语库中厘清了主干与分支，决定深入在一两个大数据组件进行学习和研究，主要聚焦在 HBASE 和 Spark 等两个代表性组件进行学习。<br>按照正常的学习方式和路径，需要在本地安装相关的组件，我决定先从 HBASE 下手，我的痛苦过程也就开始了，先说一下背景</p><blockquote><p>1、因为 HBASE 依赖 Hadoop，所以必须现在本机装好 Hadoop 的伪分布式环境<br>2、HBASE 的集群依赖 Zookeeper，所以也必须提前安装好<br>3、HBASE 本身也需要实现伪分布式安装，并与 Hadoop、Zookeeper 的版本、配置做好匹配和联动<br>4、HBASE 本身的 NoSql 写法还是太繁琐，所以一般会与 Phoenix 进行配合使用，还需要下载Phoenix 组件进行配置</p></blockquote><p>这个过程对于熟手来说也相对简单，对于没有经验的人来说，却有不少的坑，而且排查起来难度不小。</p><p>首先，Hadoop 与 HBASE 的版本匹配就让我欲哭无泪。<br>其次，我的电脑只有 8G 内存，这么庞大的大数据软件服务安装启动以后，电脑几乎慢的没法运行，这还是没有跑任务的情况下。<br>再次，即便环境安装好了， Springboot开发框架与 Hadoop 体系 jar 包的依赖冲突也让我纠结到怀疑人生。</p><p>总之，作为一个有着多年开发经验，自诩也算是爱折腾技术的优秀工程师，面对这么一整套比较高门槛和琐碎的体系，也真是有点受不住。</p><p>而且这么多时间耗在了环境的搭建和调试上，我都忘记了自己的初心，本来我是想应用这些技术体系进行业务开发，而现在除了一个跑不动的本地环境，什么都还没开始动。这种沮丧可想而知。</p><p>折腾了 2 天后，一方面实在受不了这耗神的细节，另一方面本机运行的龟速也让我实在没有信心继续下去。偶然想到阿里云肯定提供了类似产品，直接购买一个产品服务使用不是更便捷么。想到马上就行动，阿里云产品矩阵中 HBASE 赫然在列，而且提供了单机版供测试学习使用。我大概花了不到 1 个小时，就完成了相关操作，拥有了一台自己的 HBASE 数据库，整个体验非常棒，那些闹心的操作离我很遥远，大概只做了如下几个重要步骤：</p><blockquote><p>1、创建 VPC<br>2、在 VPC 可用区中选购HBASE<br>3、开通 HBASE 的外网连接地址，设置访问白名单<br>4、下载阿里云提供的 client，配置连接地址，即可连接</p></blockquote><p>这个过程和之前使用 msyql 等服务组件没有任何区别。完全不用考虑自己搭建大数据体系的那些莫名其妙的坑。<br>而且阿里云提供了详尽的产品文档，说明了 HBASE 适合的使用场景，常见的技术组件如何搭配，例如</p><blockquote><ul><li>Hbase+spark</li><li>Hbaase + Phoenix</li><li>Hbase + Solr</li><li>Hbase + Ecs<br>这些资料极大缩短了我的探索过程，是相当宝贵的经验。</li></ul></blockquote><p>说了这么多阿里云产品的优点，选购方案与自建方案相比，唯一的缺点是，在我的认知里，阿里云方案太贵了。即便写这篇文章的现在，我还是觉得太贵，一套阿里云的HBASE集群，一个月大概 2-3K 的费用。但是从认知突破的角度来讲，它带给我的专业度，似乎又值得这个费用。按照这两天所做的无用功，和由此带来的挫败感，按工时来算，其实已经远远超过阿里云这个产品一个月的费用了。</p><p>如果在认知层面能突破禁锢，真正做到愿意为专业付费，那节省下来的时间，因专业而拿到的好结果，因好结果而获得的好心情，其实远远大于产品服务本身的费用。</p><p>这个观点相信很多人都认同，但是当面临真正要马上拿出真金白银的时候，大部分都会像我一样犹豫，我觉得如果认定了这个事情要去做，而且有更专业服务可以直接使用，那就毫不犹豫的使用专业服务吧。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Now-Is-The-Result</title>
      <link href="/2019/06/20/%E5%BD%93%E4%B8%8B%E5%8D%B3%E7%BB%93%E6%9E%9C/"/>
      <url>/2019/06/20/%E5%BD%93%E4%B8%8B%E5%8D%B3%E7%BB%93%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p>最近有个对我自己而言非常非常重要的感悟，千言万语浓缩成一句话：</p><blockquote><p>Now is the Result.</p><p>当下即结果。</p></blockquote><p>想通的一瞬间，整个人都轻松了，如释重负，自己跟自己和好。</p><p>过去的大半年，一直在徘徊、迷茫、反复、逃避、无力等各种状态中切换着，混合着度过，我觉得自己一直没有定位好自己的角色，也忽视了自己的能力边界，因为工作内容的变化，多了很多自由安排的时间和思考方向，反而是这部分多出来的空间自己没有设计好，浑浑噩噩大半年已过，猛然惊醒。</p><p>这两年职业生涯走的很顺，在职位上有了几次比较大的提升，无论是公司高层，还是团队的小伙伴都给与了我很高的评价，身处这种外部环境，我自己也相信了我就是他们眼中那个优秀的人。记得承接新产品的创新设计工作之初，真是踌躇满志，觉得事情会一直按当前的状态惯性发展。而事实上，在实际工作过程中，之前的研发背景在产品设计上并不能起到太多主导作用，反而是因为缺乏行业经验和产品设计经验，让自己在这大半年充满了挫败感。在这个过程中纠结过很多次，随着自己年龄越来越大，更要重点考虑以后职场发展的方向。理论上来讲，现在的岗位和时间节点很适合转行跨界，但是实际上当前的工作内容和状态并不能很好的承接这个事情。回到业务设计工作受挫本身，我发现这个结局几乎是内定的，因为我和团队本身就在这块上有太多能力缺失呀。而之前在架构工作、研发管理工作上拿到了比较好的结果，那也是基于前面几年持续的学习和思考，有了足够的专注和投入，所以那个好结果也几乎都是注定的，只是时间早晚的问题而已。再看每一个阶段性的时间节点，我们每一个【当下】，其实就是前面一段时间所有要素的【结果】，这个【结果】几乎是注定的，要素都满足了，当下就能拿到好结果；缺了一部分要素，好结果要延迟一点；缺了关键要素，当下拿到的是坏结果。</p><p>想明白了这个点，突然释然了，<code>当下就是结果而已</code>。</p><p>当系统突发状况宕机，那是结果，那是系统风险没有被认识到的结果；<br>当团队中有小伙伴要离开，那是结果，那是个人发展与团队发展不匹配的必然结果；<br>当内心的物质欲望不能满足，那更是结果，那是自己在业务水平、财务水平上缺失导致的结果；<br>有意思的是，【当下我的状态】，又决定了【未来的某个当下】的结果。这里又可以引申出：</p><blockquote><p>Now is the reason.<br>当下是答案。</p></blockquote><p>之前新东方有个老师讲过一句鸡汤：</p><blockquote><p>你现在的样子是由3 年前的你决定的，而现在的你又决定 3 年后的样子。</p></blockquote><p>之前只觉得鸡汤好香，适合励志，现在结合自己的感悟，我觉得这个认知更重要的是让自己平和，接受现实，不要在现在的状态和情绪上恋战，积极规划后面的安排。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于技术管理的一点点思考</title>
      <link href="/2018/01/14/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E6%80%9D%E8%80%83/"/>
      <url>/2018/01/14/%E5%85%B3%E4%BA%8E%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>去年调任北京研发中心，负责整个部门的研发管理工作。从这个时间点开始，真正和<code>管理</code>这件事情有了一些关系。当时因为心态、工作安排的原因，也没有系统性的思考过<code>管理</code>的细节，大部分是凭自己过往的经验和感觉，按着野路子做事情。没有经过系统性思考的执行其实大部分都会碰壁，前段时间偶然机会读到一份PPT，专门讲技术管理的，内容特别接地气，细节也挺多，反复阅读并进行了消化，也借着这个话题，我把自己的思考也整理了一下。（<code>管理</code>本身是一门非常宏大的学科，深度和广度都不是现阶段的我能够说明白的，我这里的话题也仅仅局限于<code>中小型团队的技术管理</code>）</p><p>作为「技术管理者」，确实有着特别的一些挑战，非常认同分享者重点列举的这3个：</p><blockquote><p>挑战1：队员做的工作没有自己好，花时间去沟通还不如自己去做。</p><p>挑战2：感觉自己的技术在退化，长期不写代码觉得自己没有价值。</p><p>挑战3：认为管理没有什么技术含量，只要能把队员管理好就行了。</p></blockquote><p>分享者的整个PPT的内容也是围绕这3个挑战展开的，指出了在面对这3个挑战的时候，大部分的人会犯的错误，以及应该用什么的方法模式避免这类错误。</p><p>我从另外一个角度看待<code>技术管理</code>这件事情，视角上应该更能完善这3个<code>挑战</code>所描绘的边界。首先给出我对<code>技术管理</code>这个事情的基本思考：</p><blockquote><p><code>管理</code>的本质是「管事+理人」。「管事」落在事情的执行上，保证项目成果的交付；「理人」落在人际协调和资源调度上，为「管事」提供支撑。</p></blockquote><p>「管事」有一整套的方法论，主要包括计划制定、任务分配、节奏控制等，这部分依赖管理者对项目专业知识的储备以及对项目组人员的熟悉度，相对来说简单一些。</p><p>而「理人」部分，相对来说就比较复杂了，上文说到的几个挑战，其实都属于「理人」的范畴，<code>技术管理</code>领域的人际关系，主要可以用如下的图来概括：</p><p><img src="http://blog-yee.qiniudn.com/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86.png" alt></p><p>这里面，我认为最核心的就是要把<code>自己</code>、<code>老板</code>这部分给理顺，然后才是<code>搭档</code>,<code>队员</code>。</p><h3 id="自己"><a href="#自己" class="headerlink" title="自己"></a>自己</h3><p> 对于技术人员而言，刚开始接触到管理工作时，<code>自己</code>这一关，最大的挑战确实就是：</p><blockquote><p>感觉自己的技术在退化，长期不写代码觉得自己没有价值。</p></blockquote><p>这里发散来讲的话，有这么一些点：</p><ol><li>认清岗位价值，以前是自己做，现在是带领团队做，更有挑战了。</li><li>自己很少写代码，才有更多的时间提高团队的代码质量。</li><li>将自己熟悉的工作教会队员去做，自己去做感兴趣且不熟悉的工作。</li></ol><p>在认知上提升了对管理岗位价值的的理解，确定自己喜欢（至少不排斥）管理工作，那就应该义无反顾的选择技术管理工作，将自己从相对熟悉、比较繁琐的代码工作中解放出来，去做自己不那么熟悉但是感兴趣，更能提升研发质量的技术管理工作。</p><p>除此之外，其实还有个挑战也是大部分人都会有，而且也是比较关键的点：</p><blockquote><p>为什么会是我？</p></blockquote><p>这个挑战来自于不自信，感觉自己对编码工作可能比较熟悉，至于管理工作嘛，完全是另外一个领域，能做好吗？在心理学上有个著名的`冒名顶替综合征，很多人倾向于对自己进行否定。</p><blockquote><p>我不行，大家都被我蒙骗了，大家都觉得我厉害觉得我优秀，其实只有我自己知道根本不是这样的，我取得的成就靠的都是偶然的运气，我不配得到别人的认可和称赞，我就是个名不副实的骗子，是个能力有限没啥本事的冒牌货，不值得获得成功。</p></blockquote><p>有这种综合症的人无法将自己的成功归功于自己的能力，无论再强大再成功，也会觉得自己的成功不是理所应当的，自己是运气好、被高估了。</p><p>对此，分享者有个很不错的结论：</p><blockquote><ol><li>老板的安排没有错，是自己思路没有转变过来。</li><li>只要老板认可了你，你就有这个能力。</li><li>应该抓住这次难得的机会，好好锻炼自己的管理能力。</li></ol></blockquote><p><code>自己</code>这个维度，把「岗位价值」、「自信」这两个问题解决了，这一关基本上就算过了。</p><h3 id="老板"><a href="#老板" class="headerlink" title="老板"></a>老板</h3><p>分享者没有太多谈到<code>老板</code>的维度,我认为在这个点上需要完善一下。对于技术管理者而言，老板的意图和目标其实非常重要，这部分直接决定了管理者如何分配资源和设定优先级，尤其一些大的方向上，更要和老板多沟通，确保理解上没有偏差。</p><p>就我自己的经验而言，初阶管理者在这个维度首先碰到的第一个挑战会是：</p><blockquote><p>热衷于执行性事务，每一个大小事务都继续等着老板发号施令。</p></blockquote><p>技术人员的需求来源和任务相对比较明确，老板，产品经理等都会持续输出需求，技术岗位的日常工作就是按计划实现这些需求，完成任务就可以了。而作为管理者，恰恰部分进入了需求输出者的角色，这时候需要思考项目、产品的下阶段方向和目标，想法成熟以后，需要表达出来跟老板确认可行性，进一步推动在团队内执行。这个转变其实比较大，从技术岗位的被动执行变为主动思考，向上沟通，向下推进。这个问题，应该从如下方向进行调整：</p><ol><li>培养自己从细节中抽身的习惯，将实现类工作安排给队员，自己的工作要专注于对全局的思考。</li><li>不要等着老板发号施令，自己主动为团队设定目标，目标正确性提交给老板评审。</li><li>将目标拆成多个阶段，向老板阶段性汇报进度和成果，及时调整方向和目标。</li></ol><p>在管理岗位上，有一个最明显的感受，就是事情的<code>变数</code>往往比技术岗位更大。一方面来自于一些敏感信息更早传递到管理层，另一方面则是因为管理岗位处理的事情本身不确定性因素会大一些，不像技术岗位的事务，确定了方案就是往前推进就行了，在项目过程中基本上不会插入其他的事情，也不会突然宣布项目方向要做变化。所以我在这里比较强调<code>阶段性汇报</code>，及时向上沟通，有助于资源争取和方向上的及时调整。</p><p><code>老板</code>这个维度，<code>全局思考</code>、<code>目标设定</code>、<code>向上沟通</code>是几个重要的关键字。</p><h3 id="搭档"><a href="#搭档" class="headerlink" title="搭档"></a>搭档</h3><p>管理岗位其实挺孤独的，如果你有一个搭档，那么恭喜你，你是幸运的。搭档的存在，一方面可以共同承担压力和职责；另一方面，两个人的思考碰撞其实比一个人孤独的瞎想效果要好太多，抛开运气差的原因碰到了无法认同的同事，到了管理岗位，其实搭档基本上都会是气味相投才能长期持续共事下去的。对于搭档，我比较认同分享老师的几个观点：</p><ol><li>和搭档建立信任关系。「私下对他说:我觉得咱们兄弟俩合作，一定天下无敌!」</li><li>认可搭档的重要价值。「私下对他说:这个项目如果没有兄弟你，恐怕就无法完成了。」</li><li>极力称赞自己的搭档。「在众人面前说:我跟他一起合作，学到了很多东西」</li></ol><p><code>搭档</code>这个维度，最重要的关键词就是<code>认可</code>、<code>称赞</code>。从内心上真正认可对方的价值，和他私下也建立信任关系，并在人前称赞他，那么，这个搭档一定会在你的职业生涯中助力，也能推动自己的成长。</p><h3 id="队员"><a href="#队员" class="headerlink" title="队员"></a>队员</h3><p><code>队员</code>是管理人员最重要的资源，他们构成了你的团队，决定了你的整体执行能力，也是一线管理者最需要关注的部分。这里大家经常会碰到的挑战,我很认同分享老师的说法：</p><blockquote><p>队员做的工作没有自己好，花时间去沟通还不如自己去做?</p></blockquote><p>在这个挑战下，一般人的做法往往是：</p><blockquote><p> 错误 1:帮队员调整代码</p><p> 错误 2:替队员完成任务</p><p> 错误 3:催队员提高效率</p></blockquote><p>这些做法，把队员推向了自己的对立面。每个人都有自己的自由意志和尊严区域，当老大表现出对自己工作成果的不信任，插手到自己的工作内容的时候，造成的后果就是：</p><p><code>你帮助了他，可他并不认为你是在帮助他。</code></p><p>这里面，既有认知思维的问题，也有为人处世的问题，对应的处理方法简单归纳如下：</p><ol><li><p>以<code>指导模式</code>（而非自己动手）提升队员的工作能力。</p><p>第 1 步:赞扬他最近的工作业绩。告诉他:你当前的任务完成得很漂亮，我非常满意!</p><p>第 2 步:激励他得到更好的成长。问他:你是否希望自己能做得更好?我有些经验可以与你分享。</p><p>第 3 步:指导他把工作做得更好。告诉他:你不妨借鉴一下我的经验，你一定会从中受益。</p></li><li><p>从心底尊重队员，从帮助队员提升的起点出发（而非简单完成任务的角度），调整自己的心态。</p><ul><li><p>降低要求，关注进步，只看增量。</p></li><li><p>要学会“授人以渔”，教会他思考问题的方法。</p></li><li><p>项目延期了，不是人有问题，而是项目管理方法有问题。</p></li></ul></li><li><p>用<code>授权模式</code>表达目标，确定有效沟通机制。</p><p> 第 1 步:清晰表达工作目的与内容。（这项工作的目的是什么?要做的事情是什么?(不要告诉他怎么做)）</p><p> 第 2 步:得到授权方的确认和反馈。（问他:你是怎么理解这项工作的，有什么疑问吗?）</p><p> 第 3 步:与对方建立定期沟通机制。（问他:我们多长时间沟通一次?每次沟通什么内容?）</p></li></ol><p>做到了这几点（<code>指导</code>,<code>尊重</code>,<code>授权</code>），基本上<code>队员</code>这部分也能解决80以上的问题啦，对于20-30左右的团队，这个理论完全可以支撑的。</p><p>管理很宏大，而且是以实践为主的学科，我今天应该算是第一次系统性的整理这方面的思考，以后在日常工作中多多思考和实践，完善这套体系吧。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定目标是一种仪式感</title>
      <link href="/2018/01/11/%E5%AE%9A%E7%9B%AE%E6%A0%87%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%AA%E5%BC%8F%E6%84%9F/"/>
      <url>/2018/01/11/%E5%AE%9A%E7%9B%AE%E6%A0%87%E6%98%AF%E4%B8%80%E7%A7%8D%E4%BB%AA%E5%BC%8F%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>很多事情需要一个仪式感，写下新年愿望就是其中一个。这个笑话永远也不会过时：</p><blockquote><p>2018马上来了，2017的你完成了2016许下的2015年未完成的诺言么?</p></blockquote><p>每到新年的时候，只需要将上述年份变更下，笑话依然时尚。</p><p>「定目标」从来就不是一件容易的事情，今年我大概花了2周的时间进行反思，围绕着<code>2018年度目标</code>反复想了很多，今天总算有一个阶段性输出。</p><p>受到一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MjM5NDg2NjA4MQ==&mid=2650942174&idx=1&sn=2a2f055d182f42db7ece55ecd5cf5fd9&chksm=bd77bc108a003506eecd5824271b8c1b5e85a0be3e93dbd56a36d29a1208a745fc1ed9f63203&mpshare=1&scene=1&srcid=0103o4APzX0rLyrUi5Un8N4x%23rd" target="_blank" rel="noopener">《有了这个，别再说自己定下目标后坚持不下来了》</a>的影响，我发现定目标就是面向未来规划能力的一个重要体现。面向开放性的未来时空，其实大部分人都不太会直接具备太多想象力，而是通过反复对现状的思考，提升对时间宏观维度的把握，最终将每一个大的想法分解成<code>smart</code>标准的小想法，坚持执行，及时调整，最终达成。</p><h3 id="宏观时间感"><a href="#宏观时间感" class="headerlink" title="宏观时间感"></a>宏观时间感</h3><p>也是最近一两年，才迫切的感觉到<code>时间</code>其实是最宝贵的资源。当某段时间觉得自己在混沌度日，没有成长的时候，猛然觉察的那一瞬间往往是极不开心和恐慌的。同时又发现自己杂事缠身，一天其实还是挺忙碌的，只是时间质量不高，大部分浪费在琐碎，懵圈中。看了上面说的文章以后，我把自己的时间整理了一下，出了几个表格，发现人生清爽多了。</p><ol><li>时间宏观总表</li></ol><p><img src="http://blog-yee.qiniudn.com/%E6%97%B6%E9%97%B4%E5%AE%8F%E8%A7%82%E6%80%BB%E8%A1%A8.png" alt></p><p>通过这个宏观总表，我知道自己大概还有15000天左右的自然生命时间，第一次看到这个数据的时候，心情是挺复杂的，<code>15000</code>到底是多呢，还是少呢;<code>15000</code>到底是遥远呢，还是圣经上所说的<code>日子近了</code>呢？有了这个表格，现阶段面向<code>长远未来</code>（5年，10年）的规划我依然做不出来，但是通过这个表，我觉得我对时间的宏观维度有了新的感觉，一方面，「长远未来」其实并没有那么遥不可及，量化下来，数量级非常小；另一方面，「长远未来」真的是由大量独立的一天组成的，「如何过好一天，就如何过好一生」这句话我有了更深刻的感受，将专注力放在每天的时间质量上，保证每一天都有相对成长和输出，进而逐步提升时间的宏观感觉（1周、1个月、3个月、6个月），最终建立长远规划能力。</p><ol start="2"><li>工作日时间开销</li></ol><p><img src="http://blog-yee.qiniudn.com/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%BC%80%E9%94%80.png" alt></p><p>这个表记录了我自己从早上6点起床到晚上23：30睡觉一天的整个时间分配情况，根据这个情况，得到了一个大概的时间分配：</p><p><img src="http://blog-yee.qiniudn.com/%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB.png" alt></p><p>这里使用了一个参数定义，将时间质量分为5类，分类定义如下：</p><p><img src="http://blog-yee.qiniudn.com/%E4%BA%8B%E5%8A%A1%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E8%A1%A8.png" alt></p><p>可以看到，我在A类事务（创造类）的时间消化比较小（6小时），而在E类（生活类/娱乐类）上花了大量时间，E类时间分散在很多时间段，构成了一个小型的碎片化低质量时间群组，往往是这些事情（娱乐，刷网页等）无形中占据了一整天，甚至这种状态会持续影响第二天或以后很多天。其实话说回来，一个人如果能真正保持一天有6个小时的创造性输出，那日积月累也是很可观的呀，可是我自认为并没有什么持续积累，我想原因是一方面我没有定好目标，就算 有输出，也被淹没在日常琐事当中，另一方面，这个6个小时其实是有水分的，我现在的状态不一定完全达到了。当然，要做到这样，自制力强一点，其实真的比较简单。</p><p>仔细观察了我自己的时间分配以后，我把时间分配调整了一下，大概会是这样：</p><p><img src="http://blog-yee.qiniudn.com/%E6%97%A5%E5%B8%B8%E5%BC%80%E9%94%80%E4%BC%98%E5%8C%96%E7%89%88.png" alt></p><p>直接的汇总效果：</p><p><img src="http://blog-yee.qiniudn.com/%E5%88%86%E7%B1%BB%E6%B1%87%E6%80%BB%E4%BC%98%E5%8C%96.png" alt></p><p>调整的基本思路就是将缩短E类时间，增加A类时间。基本上调整为每天有8个小时的创造类事务，用于支撑目标执行。</p><h3 id="SMART目标"><a href="#SMART目标" class="headerlink" title="SMART目标"></a>SMART目标</h3><p><code>smart</code>原则对于制定目标非常有帮助，其大概描述如下：</p><blockquote><p>1）目标必须是具体的（Specific）</p><p>2）目标必须是可以衡量的（Measurable）</p><p>3）目标必须是可以达到的（Attainable）</p><p>4）目标必须和其他目标具有相关性（Relevant）</p><p>5）目标必须具有明确的截止期限（Time-based）</p></blockquote><p>很多人目标制定的非常模糊，如：</p><blockquote><p>我今年要减肥。（减多少？什么时间完成减肥？减不了怎么办？）</p><p>今年我也要读书，养成阅读习惯。（读什么方向的书？今年要读多少本？每个月大概读几本？）</p></blockquote><p>这样的错误我也犯过不少，无法量化的目标都是自欺欺人。我建议目标描述尽量包含各类数字，这样表达更为清晰，给自己的暗示和要求也更明确。我自己定的目标大概如下：</p><p><img src="http://blog-yee.qiniudn.com/2018%E7%9B%AE%E6%A0%87.png" alt></p><ol><li>对于习惯类目标，我的描述非常清晰，<code>时间</code>,<code>频率</code>,<code>任务指标</code>都是数据描述，非常明确，不给自己留后路。</li><li>宏观类目标，本身可以拆解为很多小目标，所以我尽量以<code>方向指导</code>维度进行描述，后续需要拆解为不同阶段的不同指标，也可能增加/删减。</li><li>思维类目标，目前还没有特别清晰的体系，只是作为一个大分支用于提醒自己注意这方面目标的培养和设定。</li></ol><p>第一次这么系统性的执行目标设定这件事情，持续执行和调整，每一件事情都做透吧。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开心是自己主动要来的</title>
      <link href="/2018/01/04/%E5%BC%80%E5%BF%83%E6%98%AF%E8%87%AA%E5%B7%B1%E4%B8%BB%E5%8A%A8%E8%A6%81%E6%9D%A5%E7%9A%84/"/>
      <url>/2018/01/04/%E5%BC%80%E5%BF%83%E6%98%AF%E8%87%AA%E5%B7%B1%E4%B8%BB%E5%8A%A8%E8%A6%81%E6%9D%A5%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>2018年元旦归来就碰到了一系列的加班，加班是讨论下一个创新产品的方向和思路，整个过程大家都不在状态，我自己也觉得这个产品方向很局限，感觉仅仅只是为了应对大老板的任务，包括思考的方式、执行的路径我都认为很不专业，一如既往的野路子的感觉。昨晚10点多下班回到家以后，感觉身心俱惫，不知道这样是为了啥，反思当天的工作，上午开了一个会，下午开了2个会，晚上继续开会，一天就过去了，自己收获到了什么，我也不知道。一瞬间非常非常不开心，那种沮丧的感觉，何等的似曾相识，曾经压得我喘不过气来，我总是在想，什么时候才能脱离这种外部环境带来的不开心，进一步又在思考，「那到底什么时候我才是真正开心的呢？」。马上想起白天和一个朋友聊天的时候也谈到这个问题，我发现其实我已经有答案了，只是没有把这个答案提升到「认知」高度来对待，所以经常忽略了。</p><blockquote><p>朋友：你心中的目标是啥？（现在）</p><p>我：   17年，为了这个问题，困惑了好久。 我到底有啥目标，到底要干啥？特别痛苦。但是,<em>我观察到了自己一点。有短期目标并且真正去执行的时候，我最开心</em>。</p><p>朋友：我觉得我远离工作的时候最开心😂，去北大学习那一周最开心。</p><p>我：为啥呢?</p><p>朋友：觉得学到了东西长了见识呗，觉得没有白活，觉得自己在成长，在变化。</p><p>我：    我有一个感觉，自己有成长的时候，自己能系统性的输出一个模型的时候，，就是感觉「真正活着」，这个时候最开心。</p></blockquote><p>如果说非得找出这一天对我最有价值的时间，就是上面这段对话吧。后面反思这个点的时候，感觉有如醍醐灌顶，「开心/不开心」只是当前状态的一种浅表达，知道了什么能让自己开心（定目标和方向），进一步主动思考，去推动并践行自己乐意做的事情（主动规划并执行），那么自己做的事情不就都是开开心心的了嘛。</p><p>以「开会」这件事情为例，其实如果提前思考，在关键节点和选择上做好判断，完全可以开心的处理好这件事情。我这里梳理了一下重要的流程：</p><p><img src="http://blog-yee.qiniudn.com/%E5%BC%80%E4%BC%9A%E9%97%AE%E9%A2%98-2.png" alt></p><p>「开会」本身解决的是沟通和协调问题，之所以大部分人对开会这件事情抵触，并且觉得是浪费时间，其实原因只有一个：「客观或主观的参与度不足」。如上图所示，只要对会议主题做好判断，并且在会议中积极参与，主动推进会议结论的导出，我相信大部分人不会因为开会不开心了。我观察自己开会结束以后不开心的原因:</p><blockquote><ol><li>会议主题对我来说不重要，我又身不由己的陪着，过程中往往在玩手机，效率极低，最后发觉浪费了一个下午。（分支1， 应该主动快速做出结论，推进会议结束）</li><li>会议的结论输出不是由我主导输出的，开会结束以后给自己派了一堆活，非常不爽。（缺乏提前思考和主动，被被人推着走，在放羊/砍柴的模型中，自己属于<code>砍柴</code>的角色）</li></ol></blockquote><p>反而，那些由我主动发起的会议，结束之后我都比较开心。原因其实非常简单，<em>因为这些议题我提前做了准备，大部分议题都有了我自己想要的明确目标，把大家召集在一起开会就是一起沟通派活，把事情都安排出去并推进执行，所以我并不会有浪费时间的感觉，开心极了</em>。</p><p>思考到了这个层次，我发现了一个重要的认知：</p><blockquote><p>开心是自己主动要来的。</p></blockquote><p>当对一个主题提前并主动进行了思考和规划，一方面走在了别人的前面，成为这个事情的主导者，另一方面作为探索者真正享受了这整个过程，<code>参与感</code>爆棚，最后的结论和认知都是自己的，那我和文中朋友的共鸣感就是相似的：</p><blockquote><p>觉得学到了东西长了见识呗，觉得没有白活，觉得自己在成长，在变化。</p></blockquote><p>因为成长，因为充实，而开心。</p><p>而开心的源头，还是在于主动思考，主动规划，主动定目标。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>兴趣模型之消费型/生产型</title>
      <link href="/2017/12/07/%E5%85%B4%E8%B6%A3%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%B6%88%E8%B4%B9%E5%9E%8B-%E7%94%9F%E4%BA%A7%E5%9E%8B/"/>
      <url>/2017/12/07/%E5%85%B4%E8%B6%A3%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%B6%88%E8%B4%B9%E5%9E%8B-%E7%94%9F%E4%BA%A7%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>前段时间在阅读《精进》时，有个章节专门谈到了「兴趣」这个主题，作者采铜顺手就把兴趣分为了「消费型兴趣」和「生产型兴趣」，都还没有看他详细拆解这个定义，我就感觉瞬间被这个提法给击中了，不由感叹作者高超的观察总结能力，虽然我自己也知道兴趣有受损型与收益型之分，却仅仅从兴趣带来的结果做表层分类，采铜的分类定义却是依赖于两个细分维度，进一步分析兴趣的影响，最终提炼出深入浅出的概念，非常容易引发共鸣并被人接受。</p><p>采铜从兴趣带来的结果出发，从「收益」、「半衰期」两个维度构建了4个象限，把兴趣做了细分，非常清晰。图示如下：</p><p><img src="http://blog-yee.qiniudn.com/%E5%85%B4%E8%B6%A3%E6%A8%A1%E5%9E%8B.png" alt></p><p>从上图可以看出，仅仅从「收益」角度看，没法足够完整地量化兴趣本身带来的影响，如：</p><blockquote><p>谁说「玩一下午游戏的收益（满足感）」比不上「练一个小时书法的收益（技能提升）」？</p></blockquote><p>而且仅仅从「收益」角度看，也会把人带偏，最终会以功利性来量化兴趣价值，与兴趣本身的定义相去甚远。「半衰期」的维度补充说明了兴趣带来的影响，而且指导人从更长远的时间维度看问题，整个思维会更为完备。</p><p>从上图中不难发现，第一、四象限是典型的生产型兴趣，而第二、三象限则属于消费型兴趣，他们的区别我简单总结如下：</p><table><thead><tr><th></th><th>生产型</th><th>消费型</th></tr></thead><tbody><tr><td>特点</td><td>资源投入型导向。需要投入时间、练习、精力、思考等一系列所谓资源，在这个过程中，人们会收获精神满足、自我提升、情感回报等，持续时间比较长。</td><td>欲望释放型导向。需要付出金钱、时间等消费性资源，在此过程中，人们会获得娱乐休闲、压力释放等回报，持续时间短暂。</td></tr></tbody></table><p>我自己反思，既没有特别让自己沉溺到无法自拔的消费型兴趣，也没有特别有亮点的生产型兴趣。在日常生活中，确实有那么一些小兴趣，都比较明显的影响到了生活。</p><h4 id="消费型兴趣"><a href="#消费型兴趣" class="headerlink" title="消费型兴趣"></a>消费型兴趣</h4><p>我有个特别花时间的兴趣，就是看电影。从大学时代拥有自己电脑开始，就一发不可收的开始了我自己的观影之路，那时候如饥似渴的搜罗各种高分片，有段时间天天在豆瓣上研究各种好片的规律，我发现电影质量的好坏与导演、演员的关系特别大，如果因为某部电影特别符合自己的胃口，我就会特别关注下导演和主演，然后会把这个导演/演员之前所有电影全部恶补一遍，我印象最深刻的是第一次接触到「黑色幽默」这种类型片，知道了大名鼎鼎的导演盖里奇，那段时间把他所有的电影全部补上了，而他的成名作《两杆大烟枪》我看了不下10遍。今天想到「看电影」这个兴趣，特意去豆瓣上看了下自己的观影记录：</p><p><img src="http://blog-yee.qiniudn.com/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1.png" alt></p><p>看到这个数据简直吓自己一大跳，这10年来，我竟然不知不觉已经看了500+电影，按平均2小时的时长来算（还不算里面包含了大量剧集类作品），累积至少花了1000+小时，也就是有42天不吃不喝全部在看电影。实话实话，在看电影的过程中，带给了我无数的乐趣，透过电影，我知晓世界上存在着我完全无法触及的另一面，也无形中提升了我的审美观。但是于我而言，观影这件事情始终处于「消费型」层面，这个兴趣无形中也带给我了很多看不见的受损，我印象比较深刻的有2点：</p><blockquote><ol><li>严重影响休息而不自知。有段时间养成了中午休息时间边吃饭边看电影的习惯，到了该午睡的时候，因为电影中的剧情刚好走到冲突处，这时候往往睡意全无，于是继续看电影，过了午休时间，整个下午都哈欠连天，与别人沟通，开会的时候都注意力无法集中，严重影响工作效率。</li><li>养成了拖延的坏习惯。有段时间我发现自己执行能力很差，自己反思观察了一下，我发现那段时间刚好在看大热的纸牌屋，回到家在电脑桌前，一般会优先看一集纸牌屋，再去处理下任务。而看完电影以后，往往时间也不够了，就会说服自己明天在处理吧，这样一来，任务拖延的特别明显，自己情绪也很不好。</li></ol></blockquote><p>消费型兴趣本身没有问题，问题消费的带来的半衰期短，很容易触发重复消费以获取更多的快感。人们无法自制的一个重要原因也在于此，享乐给人的感觉永远都是稍纵即逝，抓不住，只有超越享乐型需求，才能真正自律。</p><h4 id="生产型兴趣"><a href="#生产型兴趣" class="headerlink" title="生产型兴趣"></a>生产型兴趣</h4><p>在反思自己的兴趣体系时，我发现自己没有真正把一件兴趣做到了相对专业的程度，所谓生产型兴趣，不仅仅是要在较长的半衰期周期内获取回报，更重要的是在相应点上有了一定的专业性积累，我有一些存在生产属性的兴趣，如阅读、写作、跑步等，但无一不显得泛泛之辈，没有可以特别拿出来说说的。这个结论让人非常沮丧，虽然也偶尔能从一些生产型兴趣中获得意外红利，如跑步让我心情平静，写作让我思考更加缜密，也能验证自己的学习效果，但是缺乏长远的兴趣规划，始终是一个半吊子水准，非常可惜。</p><p>应该反思一下自己的天赋和兴趣，尝试找一到两个点来做长期积累，一年以后再看看生产型兴趣带来的收益吧。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>放弃向往已久的事物是一种怎样的体验？</title>
      <link href="/2017/12/04/%E6%94%BE%E5%BC%83%E5%90%91%E5%BE%80%E5%B7%B2%E4%B9%85%E7%9A%84%E4%BA%8B%E7%89%A9%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C%EF%BC%9F/"/>
      <url>/2017/12/04/%E6%94%BE%E5%BC%83%E5%90%91%E5%BE%80%E5%B7%B2%E4%B9%85%E7%9A%84%E4%BA%8B%E7%89%A9%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>今天放弃了之前梦想了很久的，属于国内互联网公司第二梯队的offer，婉拒邮件发出之前，踌躇了半天，发出去之后，也怅然了半天，选择就是这样吧，「取舍」总有一些难的。</p><p><img src="http://blog-yee.qiniudn.com/offer.jpeg" alt></p><p>​                        (反复敲了又删，删了又敲的婉拒邮件)</p><p><img src="http://blog-yee.qiniudn.com/hr.jpeg" alt></p><p>​                            (跟HR简单的沟通)</p><p>一直期待自己进入国内一流互联网团队，无论从镀金的角度，还是学习的角度，还是上升的角度来说，这样的团队可遇不可求，而且在长沙这种小城市，这样的机会并不是特别多。更重要的，这个offer含金量还挺高的，给我的评级居然是一直我不太自信的「专家」，算是非常不错的肯定和信任了。</p><p>其实做出这个决定，相当于给自己未来2~~3年投下了一个赌注吧。对于脚踏实地的人来说，没有一次选择能决定命运，《精进》里面也说到：</p><blockquote><p>选择是可以不断被修正的，就算当时做出了错误的判断和抉择，厉害的人也可以通过新的选择做出修正，让自己的路往正确的方向铺设。</p></blockquote><p>人生最怕的就是失去目标，蹉跎时光，当初历下心智要坚持每天写作，仅仅几天就断了，当然这段时间在不断的准备面试和反思审视自己，这样的过程也有不少提升，可是，写作应该是一种习惯，哪怕极少的30分钟，只要在输出，我就觉得自己在活着，这一天没有白活，这个习惯应该要持续坚持下去的。</p><p>不管怎么样，今天过完了，做了决定，就收拾好情绪，把每一天活好。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>驾考复盘</title>
      <link href="/2017/09/30/%E9%A9%BE%E8%80%83%E5%A4%8D%E7%9B%98/"/>
      <url>/2017/09/30/%E9%A9%BE%E8%80%83%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>昨天终于完成了驾考，顺利拿到了驾驶证。考完科目4的那一瞬间，感觉整个人都松了一口气，特别放松。总算是了了一件事情，驾考是一件需要不断投入精力，时间，关注力的事情，像我这种所有项目全部一把过的人，应该还算是幸运的，内心都是非常疲惫的，其他运气没那么好的同学，如果需要补考重来，内心的煎熬更是可想而知。</p><p>有一个小背景就是：</p><blockquote><p>在15年我就驾考报名了，练了一段时间的科目2，和当时的教练处不好关系，把C1换成了C2，同时换了个教练。结果准备去重新学习的时候，外派到北京呆了半年，中间就完全中断了。今年从北京回来，也一直拖延，直到驾考新规出来了，在2017年10月份将执行新规，难度更大了，我才慌忙从9.5号联系新教练开始训练，终于在9.29号顺利通过所有科目考试，结束驾考。</p></blockquote><p>对于这整个事情，我想我的收获不仅仅只是拿到了一个驾驶证，更重要的是这整个过程不少值得复盘和思考的点，我在学习的过程中心态也一直在不断的发生变化，我觉得自己能更好的驾驭自己的情绪，能更好的面对困难和挑战，应该说，朝着「更好的自己」迈出了一小步。</p><h3 id="1-拖延只是表象，找出背后的原因很重要"><a href="#1-拖延只是表象，找出背后的原因很重要" class="headerlink" title="1. 拖延只是表象，找出背后的原因很重要"></a>1. 拖延只是表象，找出背后的原因很重要</h3><p>我不知道别人驾考的情绪是怎么样的，我想在大的环境下，没有几个人是开开心心完成整个训练过程的。我在第一个教练那儿学习的时候，教练的态度比较恶劣，动不动就是藐视智商的言论，一方面我比较敏感，另一方面我其实也很紧张，那些天我觉得每天都生活得紧张兮兮的，每当到了去驾校学习的时间，我的内心非常抵触，但是又不得不去，到最后心里都在盼望能突然下大雨，或者突然需要加班，让我有一个说服自己的理由，能不去训练就不去。后面实际的情况是，我的训练总是断断续续，没有持续的积累，总是有各种「忙」的理由，最后在一次和教练的沟通中爆发了，我突然觉得我没法继续了，不考了，一了百了。当时深陷压抑的情绪中，没有抽身思考。现在想来，反复拖延一件事情，把其他事情的优先级提高，高过于它，一定是内心在抵触它。市面上有很多治疗拖延症的方法论，在我看来都是特别矫情，无非就是给自己营造出一种仪式感，强制自己培养一个习惯，如这些社群中非常热衷的签到、打卡，这些都过于表面。人更倾向于做自己开心享受的事情，解决拖延症最重要的是思考「到底在抵触什么」，将认知层面的问题想清楚了，才有可能根据本质问题提出解决方案。</p><h3 id="2-被大部分人忽略的「老师的作用」"><a href="#2-被大部分人忽略的「老师的作用」" class="headerlink" title="2. 被大部分人忽略的「老师的作用」"></a>2. 被大部分人忽略的「老师的作用」</h3><p>在动手能力方面，我一直很弱。所以在我的潜意识里，要驾驭汽车这件事情，对我来说难度很高。在第一个教练那里学习的时候，我特别紧张，在教练看来就是笨手笨脚，简直不知道要浪费他多少时间才能教好，带我真的是亏大了。这种观点甚至影响了自认为还有点思辨能力的我，有段时间我真的觉得对教练挺抱歉的，自己太笨了，如果顺利过了，要给他额外一点补偿。当然最后散了，另外换了新的教练。</p><p>新教练位女性，而且是和我同在一个教会的基督徒。她的风格就完全不一样，基本上对事不对人，我们弄错了的地方，她会严肃指出来，平时主要是嘻嘻哈哈说笑，绝不会进行智商侮辱和言语攻击，在这里学习的气氛完全不一样，整个过程我觉得很轻松，一次抵触情绪也没有过，即使在后面科目3考试在即，我还完全没有找到感觉的时候，当时压力很大，我跟她说大不了我提前取消考试预约吧，她听了以后马上就安慰我，说她都准备好了，要我有信心，肯定没问题的。后面是在考试的前3天，她给我安排了每天两次的训练机会，我明显感觉到每次训练都比上次有进步，在考试前一天，我已经可以做到任何指令都准确执行。 换到以前，我无法想象在「操作动手」这件事情上，我能有这样的进步迭代速度。我想这里大部分的功能在于老师吧，老师营造出了好的学习气氛，给了学生足够的信心，能面对看似巨大的挑战，完成了在学生认知范围内不可能完成的事情。</p><p>复盘这个事情，我觉得我的小孩们的学习一定是要快乐的。如果他们不快乐，强烈抵触某个课程，我和他们一起找原因，我相信每个人在陌生的事物面前，都有不适应的过程，这个过程需要优秀的老师带领。做优秀的引导者，这个是老师的底线职责。不要把白纸交在水平低劣的画家手里，白纸上的作品品质低劣，是画家本身水平残缺。</p><h3 id="3-学习是有方法论的"><a href="#3-学习是有方法论的" class="headerlink" title="3. 学习是有方法论的"></a>3. 学习是有方法论的</h3><p>「学习方法论」这个宏大的命题不知道养活了多少自媒体。在我看来其实特别简单，就是学生时代，老师不断在强调的3个步骤：课前预习、有效听课、课后复习。</p><p>在驾考这件事情上，我发现科目2与科目3的考核体系完全不一样，科目二重在考核「精准度」，所以教练侧重于教你看点，到点打方向盘，到点踩停等等。我在学习科目二的时候，发现这与我的职业吻合度很高，都是小项目，过程就是按步骤来执行就可以，特别适合系统化记忆和理解。而科目三侧重于「临时反应」，它虽然也一系列项目，但首先这些项目是无序的，碰到什么项目就执行什么，其次它们不要求精准性，而要求你根据实际场景做成反应，内容更多更杂。教练一上来也没有跟我说总共有多少项目，要怎么怎么弄，就是碰到啥路口就教我怎么做，这个我第一天完全适应不了，事后我马上上网查资料，把科目三相关的考核项目全部列了出来，然后学习它的扣分规则（课前预习），在实际训练的时候就有的放矢，针对认识上的盲点仔细练习（有效听课），当训练结束以后，反思一下自己出问题的地方，有时候坐在后面看别人训练，也看他们的扣分点是啥，提醒自己都要注意修正（课后复习）。这样一整套方法执行下来，我觉得效果特别好，科目三前后训练不到6天就顺利考试了。</p><p>其实还有其他很多零碎的小认知，我想这些认知在某个时间点迸发出来的时候，能让我们心头一凛，在那么一段时间内知行合一去落在实践中，我们的生命就是在变好吧。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>早知未来，会过现在</title>
      <link href="/2017/09/29/%E6%97%A9%E7%9F%A5%E6%9C%AA%E6%9D%A5%EF%BC%8C%E4%BC%9A%E8%BF%87%E7%8E%B0%E5%9C%A8/"/>
      <url>/2017/09/29/%E6%97%A9%E7%9F%A5%E6%9C%AA%E6%9D%A5%EF%BC%8C%E4%BC%9A%E8%BF%87%E7%8E%B0%E5%9C%A8/</url>
      
        <content type="html"><![CDATA[<p>前几天读到一篇灵修分享，观点特别棒。特此转抄记录，希望自己能有这样的心态，把「结局已知，过程未知」作为人生的重要认知，在信仰上能践行，在生活中能有思考和应用。</p><p>以下为原文：</p><blockquote><p> 昨天听单牧师讲道，他说自己当年读小人书的时候，十分入迷。他的心会随故事情节一起跌宕起伏，每当好人遭难，小人得志，坏人发达时，他也是忧伤难过，愤愤不平。因此，读书不再是享受，而是“难受”。</p><p> 后来，他改变了阅读的方法。读一段开头之后，就直接读结尾。那时的作者都比较“仁慈“，结局总是正义战胜邪恶，主人公也总能过上幸福的生活。因此，当他再读中间部分时，无论故事主角的遭遇多么艰难曲折，他都不会过于担心。用他自己的话讲，想着结尾看过程，少了一些悬念、刺激，但多了一份从容、洒脱。</p><p> 这种“结局已知，过程未知”的读书方法，像极了人生。自出生起，人就注定要死。从这个角度看，人生没有悬念。但是，从生的到死的过程，却是未知，包括何时死，如何死也是未知。因此，人生又可说是充满了悬念。</p><p> 倘若每个人都想着死亡度今生，那一定会少一些斤斤计较，多一点宽厚包容。只是，太多的人并不关心结局，甚至选择无视，否则，哪还有理由不择手段的争名夺利。</p><p> 的确，有人不同意这种“剧透式”的阅读方法，也不愿多想自己的最终的结局，宁愿在纠结、忐忑、或者是好奇中等待结尾的到来。可人生毕竟不同于文学作品，小说写错了可以更改，人生活错了却不能重来。更何况，这本书不喜欢可以另外换一本，但人生却不由自主。若对未来完全未知，当巨大的患难临到时，人如何有勇气活下去？</p><p> 在先知以赛亚的信息里，犹大人要受到神严厉的惩罚。他周边的列国，就是腓利士人、摩押人、埃及人，亚述人，巴比伦人等都会成为神的工具，轮番来攻击他们。最终，他们将亡国于巴比伦。若只是看过程，人们会认为这些国家强大无比，甚至觉得他们的神明也比犹大人的神强。但是，在先知的眼睛里，他看到了更远的未来。</p><p> 无论这些敌人现在多么强大，对犹大人进行着怎样的打击和奴役，他们都有一个统一的结果，那就是必要灭亡，神的子民却要复兴，全地的人更是要提说、敬拜耶和华的名。</p><p> 先知的预言，宣告了列强的结局。当犹大人受他们欺压时，会因为知道结局而不至于求死，乃是充满盼望。因为提前知道了未来，他们可以度过艰难的岁月。而且，当先知的预言应验时，他们的信心会更加得到坚立，可以迎接更大的挑战。</p><p> 就人类最终的结局来说，圣经也已早早给出了答案：世界的末了，罪人灭亡，义人得生。基督得胜，撒旦失败。这些，都是圣经中最为明显的启示。因此，当我们处境艰难时，不妨也多想想未来的终局。相信，你也会跟保罗一样，对眼前许多的苦楚不那么介意了。事实上，耶稣能胜过苦难，也是因为看到了那摆在前面的喜乐。</p><p> 早知未来，并非让人生失去悬念，更不会让人生失去精彩。每一天，我们如何活？每件事，我们作何选择？我们在世具体的时间有多长？等等，这些都是未知，我们也充满好奇。因此，神让我们知道最终的结局，不是让我们像预知了足球比赛的比分一样活的索然无味，乃是在兴奋和期待之余，少了一份恐惧、害怕，多了一份淡定和从容。</p><p> 只是，还是要提醒，先知不同于小人书的作者，他们预言的结局不是看一眼就可以了，乃是需要信心来接受。惟有信神是掌管历史的主，那预定的结局才会与你我有益。</p><p> 早知未来，只为活好现在。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何与这个「功利、焦虑、碎片化」的世界对抗</title>
      <link href="/2017/08/28/%E5%A6%82%E4%BD%95%E4%B8%8E%E8%BF%99%E4%B8%AA%E3%80%8C%E5%8A%9F%E5%88%A9%E3%80%81%E7%84%A6%E8%99%91%E3%80%81%E7%A2%8E%E7%89%87%E5%8C%96%E3%80%8D%E7%9A%84%E4%B8%96%E7%95%8C%E5%AF%B9%E6%8A%97/"/>
      <url>/2017/08/28/%E5%A6%82%E4%BD%95%E4%B8%8E%E8%BF%99%E4%B8%AA%E3%80%8C%E5%8A%9F%E5%88%A9%E3%80%81%E7%84%A6%E8%99%91%E3%80%81%E7%A2%8E%E7%89%87%E5%8C%96%E3%80%8D%E7%9A%84%E4%B8%96%E7%95%8C%E5%AF%B9%E6%8A%97/</url>
      
        <content type="html"><![CDATA[<p>微信公众号带来了自媒体的崛起，各种意见领袖可以轻易的让自己的观点轻松触达上百万的用户。我们的信息渠道也逐渐由各类公众号，知乎、微博的timeline所占领，我们所关注的这些KOL，他们的文字在有意无意的影响、重构我们的认知和三观。这些信息洪流里面，有些人发现 了「知识付费」这个命题是成立的，16年开始，各类付费专栏突然一下子就大量冒了出来，我关注一批这样的公众号，他们的特点是在早期输出比较有质量的内容，吸引到一定的粉丝量级后，宣布开个付费圈，圈内分享各种干货。宣告开圈的帖子都会有意无意的告诉你，入了圈子就代表你追求进步，入了圈子就代表你是精英，入了圈子你的成功就是触手可及了。特别有意思的是，这些KOL一定会强调的一件事情是，在中国当下，阶级固化已成为既定事实，精英阶级的大门正以有史以来最快的速度向寒门关闭，要想对抗这种现状，就得有方法、有策略的去努力，去认知，去赶上这趟末班车。这样的文字，说实话，对于渴望进步，出生平凡的我来说，很有感染力，一方面文章对我这种目标群体的肯定（追求进步的好青年）让我很享受，另一方面精英社会的大门马上要紧闭让我很焦虑，而快速搭车跻身上流社会简直就是人人就有的梦想和啊。基本上，这种文章一出来，我就要紧张好半天，总觉得慢跑一步就会被社会给抛弃了，后面看得多麻木了，更是在反思自己是不是已经放弃进步了。</p><p>其实，我的内心，虽然也向往这些KOL描绘的精英生活，但是总是隐隐约约觉得，这些调调哪里不太对，却有说不太上来，直到最近在思考，他们所宣讲的这套理论，和十几年前的成功学没有本质区别啊，就是利用了人想突破阶层的想法，换了一套皮肤（强调认知、努力方法论），内核（崇拜金钱成功）还是一样的。在我看来，不管它们的说辞怎么变化，他们所利用人性的弱点是一致的：</p><ul><li>功利。他们会举例说一大堆少年成名的案例，告诉你你和他们之间唯一的区别只是认知差别，思维差别，而这些，都可以通过优秀的方法论，刻意练习去弥补，等功课到位了，你也能想少年英雄一把。</li><li>焦虑。他们会把北上广深的房价、科比的凌晨四点的太阳搬出来，告诉你对内需求来说，买房的难度这么大，对外对比来说，比你优秀的人比你还努力，营造出一种非常焦虑的气氛，恨不得马上付费入圈，就能华丽晋升精英阶层了。</li><li>碎片化。因为移动互联网的普及，人的信息渠道已经被简短的碎片化信息所充斥，当人们丧失了阅读长篇幅的信息的耐心和能力，基本上也就丧失了思考能力和有价值是输入源，更进一步为这些知识大V扩展了目标群体，人们就想嗷嗷待哺的婴儿，吃着大V们定制的知识食谱。</li></ul><p>我在想，我能保持自认为的清醒，除了我不追求上进不愿入圈以外，是不是还有其他可以武装自己的方式，我仔细想了下，应该还是有可以去做的点：</p><ol><li>有自己的价值观。当我的价值观里面对「浮躁、功利」无感时，自然而然会辨别过滤这部分的信息。</li><li>思考走在大V的前头。当大V们的某些观点我刚好有过思考，而且在他们前面的时候，我想，被忽悠的可能性会小很多吧。</li><li>主动消除碎片化，培养吃大餐的能力，能持续阅读真正有深度的书籍，而不是仅仅能挑拨情绪的小文字。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「忙」这件小事</title>
      <link href="/2017/08/27/%E3%80%8C%E5%BF%99%E3%80%8D%E8%BF%99%E4%BB%B6%E5%B0%8F%E4%BA%8B/"/>
      <url>/2017/08/27/%E3%80%8C%E5%BF%99%E3%80%8D%E8%BF%99%E4%BB%B6%E5%B0%8F%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="http://blog-yee.qiniudn.com/%E5%BF%99%E6%88%90%E7%8B%97.jpg" alt></p><p>前段时间因为工作调整的原因，莫名其妙好几个项目的事情同时堆了过来，我发现自己挂在口头最多的话就是</p><blockquote><p>我好忙，事情挺多，你这事情先缓缓吧。</p></blockquote><p>现代社会节奏这么快，不跟别人说自己在忙都不好意思打招呼。<code>表面上的忙</code>其实还好处理，大不了就是加加班、熬个夜，把事情给做完嘛。其实我比较后怕的是<code>表面上的忙</code>所带来的<code>内心的慌乱</code>。当待处理的事情排山倒海涌过来的时候，这里面有明天要跟老板做的汇报，有要抓的项目上线进度，还有自己需要参与的各种执行性质的任务，咋看过去，每一块都是大事情，每一件都是不好啃的骨头，所有的事情都堆在一起了，不知道从哪儿下手比较好，这个时候，该死的拖延症有意无意的在心里冒出声音来:</p><blockquote><p>现在没心情处理，要不先磨下洋工，反正时间还早？</p><p>报告的事情晚上熬夜弄吧，那时候安静，有灵感。</p><p>这个模块就放周末吧，整整两天呢，应该够了。</p></blockquote><p>平心而论，这样的场景重复过无数次，熬到最后一秒钟才完成的工作不少，延期的事情，放弃的事情那就更是数不胜数了。</p><p>过完那忙碌的几周以后，某个早晨，我在步行上班的路上，突然一个想法蹦出来了，</p><blockquote><p> 像我这种微不足道的平凡人，面对工作和生活尚有这么多的「忙」的时候，那些改变世界的伟大人物，他们每天要考虑的事情，要做出的重大决策，要参与的会议和事务，不知道比我多了多少去了，他们如何解决这种又忙又乱的问题？</p></blockquote><p>马上我就认识我这个想法的逻辑问题了： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">他们可能比较忙，但肯定不会乱.</span><br><span class="line">这些人每天的工作，都是在一周前，甚至一个月前就已经计划好了的，就算有些临时的调整，但是大的事务，总的进度和方向基本不会有太大变化。他们要做的就是延长执行时间（加班、熬夜、周末），按照既定目标执行就行了。</span><br></pre></td></tr></table></figure><p>我甚至马上发现了一个很重要的认知：<code>「忙」本身不是问题，「乱」才是。</code></p><p>所以，关于「忙」这件小事，本质的问题是什么呢：</p><blockquote><p>如何解决和避免多事务出现时「乱」的状况</p></blockquote><p>就我自己的经验而言，「乱」也是分为两个维度来看：</p><ul><li><p>认知维度。事情突然一起涌入的时候，内心肯定是存在抵触情绪的。特别是那些看起来难度比较大，持续时间比较长的事情，肯定希望有多远离多远，这样的情绪是引发拖延症的最大祸首。另一方面，从寻求舒适区的角度来说，我们的内心会主动选择性忽略这些事情，只要不是太紧急，就会一直放到那里，直到交账的前几天才匆匆忙忙处理。吃过几次苦头以后，我认识到「事情不会因为我的逃避而消失」，后面的经验是主动去面对这些事情，把它进行分解消化，一点点执行，反而质量比较好，而且最后发现根本没有我想象中的那么难。</p></li><li><p>执行维度。这个其实也是思考的缺位造成的，当需要同时处理很多事情的时候，之前的习惯是这也弄下，那也看下，这样效率很低，感觉自己特别忙，但是真正完成的模块并不多，好几天过去了，这些事情还是都需要关注，横向注意力丝毫不能收拢，精力的消耗非常大。后面发现不能再这样下去了，必须要做出改变。我把项目管理工具<code>tower</code>用上了，把所有的事情分解成一个个的任务项，在处理一个任务的时候，其他的事情就一概不管，每完成一条任务，就标记已完成，最后一天下来，看到任务看板上都是已完成的任务，心里特别有成就感，也不觉得那么累了。而且我对整个事情的进度有了更直观的认知，内心的那种慌乱感也大大减弱了，这个算是最大的收获吧。</p><p><img src="http://blog-yee.qiniudn.com/tower.jpg" alt></p></li></ul><p>其实可以预见，随着年龄的增长，职位的变化，工作和生活的事情等都会慢慢越来越多。之前总在幻想「完成这个项目就好了，换个地方就好了」，这些想法本质上都在逃避和忽视，不能真正解决问题，通过对这些事情的复盘和反思，能有一些成型的认知输出，以期做到「忙而不乱」吧。</p><p>最后，一些认知总结：</p><ul><li><p>人总会放大未知事情的难度，越过山丘以后，往往会发现之前被无限放大的困难不过如此。</p></li><li><p>不逃避，敢于直面是克服拖延症的利器，越早介入待执行的任务，越早输出执行计划，拖延症就越没有存在的空间。</p></li><li><p>规划任务，分解任务，执行任务的仪式感很重要，把任务一条条标记为已完成的时候，能有效治愈疲惫感和焦虑感。</p><p>​</p></li></ul><hr><p>用输出倒逼思考，坚持写作100天。  1/100</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记--职场上升期，压力焦虑怎么破？</title>
      <link href="/2016/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%81%8C%E5%9C%BA%E4%B8%8A%E5%8D%87%E6%9C%9F%EF%BC%8C%E5%8E%8B%E5%8A%9B%E7%84%A6%E8%99%91%E6%80%8E%E4%B9%88%E7%A0%B4%EF%BC%9F/"/>
      <url>/2016/10/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E8%81%8C%E5%9C%BA%E4%B8%8A%E5%8D%87%E6%9C%9F%EF%BC%8C%E5%8E%8B%E5%8A%9B%E7%84%A6%E8%99%91%E6%80%8E%E4%B9%88%E7%A0%B4%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>偶然在知乎live上参加了一场live，主题是<a href="https://www.zhihu.com/lives/764595337913454592" target="_blank" rel="noopener">职业上升期，压力焦虑怎么破？</a>， 刚好自己也有这方面的困惑，而且还挺严重，严重到影响到自己工作，生活，情绪。听完以后，受益颇多，这里把笔记记录下来，有不少部分是只值得自己好好去实践的。</p><p>live的主题虽然是「职场压力焦虑」，其实内容覆盖到了职场的价值观，个人天赋，能力提升，职场倦怠，压力模型，情绪管理等方面，可惜内容比较浅，因为其实每一个主题都可以说得特别深，一个小时是在没法说得太细，不过里面已经提到了一些非常好的角度，提供了不少非常有价值的模型，我这里一一记录下来。</p><h3 id="职场倦怠期"><a href="#职场倦怠期" class="headerlink" title="职场倦怠期"></a>职场倦怠期</h3><p>溪子老师首先讲了关于她的一个小故事。她在美国读书的时候，环境特别好，天是蓝蓝的，树叶是绿油油的，可是她就是提不起劲儿来，不想去学校读书。她在想，她到底是怎么了，费了那么大劲儿来到美国，难道就是陷入为了这样的状态吗？后面她才知道，这是到了一个「职场倦怠期」。这段经历我特别有共鸣，很多时候我也是觉得特别没劲，其实需要做的事情有很多，就是没有动力去做，觉得这一切都没有意义。</p><blockquote><p>溪子说，「职场倦怠期」分为两种情况：</p><ol><li>情绪枯竭</li><li>职业效能感低</li></ol></blockquote><p>用「开车」来打比喻， <code>情绪枯竭</code>就好比想要开车却没有油，而<code>职业效能感低</code>是指可以开车，油也够，但是觉得开车不好玩，不想去开。</p><p><code>职场倦怠期</code>的现象要从驱动力的角度来考虑。老师给出了一个实验：</p><blockquote><table><thead><tr><th></th><th>第一组</th><th>第二组</th></tr></thead><tbody><tr><td>规则</td><td>每安装完一个乐高玩具都付给他一定的薪酬，3美元起步，下次安装完薪酬比上次少给0.3元，直到不想他觉得不想安装为止。</td><td>每安装完一个乐高玩具都付给他一定的薪酬，3美元起步，下次安装完薪酬比上次少给0.3元，直到不想他觉得不想安装为止。比第一组多一点的是：他安装完毕以后当场拆除玩具。</td></tr><tr><td>完成度</td><td>11个</td><td>7个</td></tr></tbody></table></blockquote><p>这个实验的结论是：</p><blockquote><p>当把金钱当做某项工作的外部奖励时，行为主体就会失去对这项工作的内在驱动，奖励只会给人短暂的刺激，如同强行提神的咖啡因，消耗的是内在驱动力，受损的是长期积极性</p></blockquote><p>同时这里有一句名言来佐证<code>内在驱动力</code>的巨大价值。</p><blockquote><p>服从能让我们度过每个白天，但投入让我们度过每个黑夜。</p></blockquote><p>那<code>内在驱动力</code>包含哪些部分呢？具体如下：</p><ul><li>内在愉悦感</li><li>成就感</li><li>创造性</li><li>自豪感</li><li>意义感</li></ul><p>当我们的工作能给我们这些内在回馈时，它往往比外在回报更有吸引力，让我们不由自主的投入，如果我们和工作的关系一直是这种<code>投入 &lt;--&gt; 内在驱动力</code>的良性循环，<code>职场倦怠期</code>也自然而然就减少甚至没有了。</p><h3 id="MBTI模型"><a href="#MBTI模型" class="headerlink" title="MBTI模型"></a>MBTI模型</h3><p>溪子老师天马行空，我没听明白怎么就转到了这个模型，不可否认，<code>MBTI</code>模型对职场认知颇有意义。</p><p><img src="http://blog-yee.qiniudn.com/MBTI.jpg" alt></p><p>我对这个模型的认识是，我们对比参照去发现自己如何与这个世界发生关系，修正自己不那么擅长的那一部分。</p><h3 id="如何发现自己的天赋"><a href="#如何发现自己的天赋" class="headerlink" title="如何发现自己的天赋"></a>如何发现自己的天赋</h3><p><img src="http://blog-yee.qiniudn.com/%E5%A4%A9%E8%B5%8B%E6%A8%A1%E5%9E%8B.png" alt></p><p>这个模型一看下来，发现自己差距好大。</p><h3 id="WOOP思维心理学"><a href="#WOOP思维心理学" class="headerlink" title="WOOP思维心理学"></a>WOOP思维心理学</h3><p>心理比对——W（愿望，Wish）→O（结果，Outcome）→O（障碍，Obstacle）→P（计划，Plan)</p><p>在心怀梦想的同时，考虑到阻碍梦想达成的现实。</p><blockquote><p>对未来抱有乐观幻想的人（基本上指的是我们所有人）——其实是把自己放在了一个两难境地：一方面，他们不自觉地放松下来，迷惑自己的大脑说梦想已经实现；而与此他们的美梦又把他们的认知能力束缚在这些梦想里面，将那些可能会促使他们站到梦想外面、对其进行客观审视、继而改弦易撤的信息挡在外面。</p></blockquote><p>让人行动起来的最好的办法就是让他们心怀梦想，然后立刻将阻碍梦想实现的现实放在他们面前。两者的对峙被作者称为<strong>「心理对比」</strong>。</p><p>图例如下：</p><p><img src="http://blog-yee.qiniudn.com/woop.jpg" alt></p><p>应用示例：</p><blockquote><p>我希望今天晚上进行健身锻炼，但是往往一天忙下来特别累，一回到家就只想躺着。很多次都是白天信誓旦旦一定要坚持，一到下班就完全没有动力了。这种情况自己的心里预期特别差，觉得自己没有自控能力，没有意志力。</p><p>应用woop的话应该这么处理：</p><ol><li><p>最佳结果： 坚持锻炼</p></li><li><p>障碍： 精力不足，时间不够</p></li><li><p>计划： 如果我今天准时下班，那么就去锻炼；如果又要加班，则改变锻炼计划；</p><p>或者： 如果我今天下班后精力充沛，则坚持锻炼</p></li></ol></blockquote><h3 id="情绪管理"><a href="#情绪管理" class="headerlink" title="情绪管理"></a>情绪管理</h3><p><code>情绪管理</code>特别重要，这也是我之前一直忽视的问题，溪子老师提供了一个非常不错的而且可惜的实践方案：</p><ol><li>记录我情绪</li><li>思考 「我感到XXX，是因为XXX」</li><li>连续21天，每天写下3件让自己感谢的新事情</li><li>记录过去24小时内所经历的一件积极的事情。</li></ol><h3 id="职场焦虑来源"><a href="#职场焦虑来源" class="headerlink" title="职场焦虑来源"></a>职场焦虑来源</h3><p>职场焦虑来源有很多，我自己现阶段主要有：</p><ol><li>多线程，长时间的工作状态，让人觉得精神高度紧张</li><li>自我期待高</li><li>在意别人怎么看自己</li><li>技能安全感低</li><li>没有合理计划，忙闲时间无法合理配备</li></ol><p>最后一句话，我特别喜欢：</p><blockquote><p>厌倦需要变化，焦虑需要学习，失落需要价值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知乎live笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记-暗时间-1</title>
      <link href="/2016/03/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9A%97%E6%97%B6%E9%97%B4-1/"/>
      <url>/2016/03/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%9A%97%E6%97%B6%E9%97%B4-1/</url>
      
        <content type="html"><![CDATA[<p><a href="http://book.douban.com/subject/6709809/" target="_blank" rel="noopener">暗时间</a> 这本书内容比较散，我想把阅读过程整理一下，增加有效阅读吧。今天的内容是第一章「暗时间」的主题。</p><h2 id="什么是-暗时间"><a href="#什么是-暗时间" class="headerlink" title="什么是 暗时间 ?"></a>什么是 <code>暗时间</code> ?</h2><p>关于<code>暗时间</code>，书中也没有给出明确的定义，我的理解是这样的：</p><blockquote><p>顾名思义，<code>暗时间</code>是指在暗处不能轻易<code>被发现</code>、<code>被利用</code>的时间。 </p></blockquote><p>以「一天」为单位，每个人所拥有的时间总量都是一样的，但是，有的人在相同的时间内有更多的<code>有效思维时间</code>，那这段时间其实就是他多出来的。书中开篇就拿「电脑」做了例子来说明：</p><blockquote><p>你有一台电脑，装好系统以后就搁置在那儿，它有被实际使用了吗？没有。因为CPU运行的是空闲进程。运行空闲进程是一天，运行大数据计算也是一天，价值却是完全不同的。</p></blockquote><h2 id="暗时间对于我们在事情的时间投入上有什么意义？"><a href="#暗时间对于我们在事情的时间投入上有什么意义？" class="headerlink" title="暗时间对于我们在事情的时间投入上有什么意义？"></a><code>暗时间</code>对于我们在事情的时间投入上有什么意义？</h2><p>我们常常有一个疑问：</p><blockquote><p>为什么我在这件事情投入了这么多时间，却收效甚微？</p></blockquote><p>其实，<code>投入时间</code>这个说法本身就是<code>荒唐</code>的。 决定收效的应该是<code>时间 X 效率</code>，你可能花了很长一段时间在一件事情上，却发现事情毫无进展；这时候，你应该思考这样一个问题：</p><blockquote><p>我这一整段投入的时间，等于真正流逝的时间吗？</p></blockquote><p>我想绝大部分的答案是「No」。</p><p>我来描述下，<code>投入的时间</code>尽量等于<code>流逝的时间</code>的一个怎样的状态。</p><blockquote><p>你会把要做的事情，要学的东西常驻于你的大脑中，时刻给予它最高的优先级，你走路的时候吃饭的时候做梦的时候，心心念念想的就是这件事情，你的CPU总是分配给它，这个时候你的思维时间就被利用到了极致，你所投入的时间就真正等于实际流逝的时间，因为你的CPU是满载的。</p></blockquote><p>所以，<code>暗时间</code>对于<code>时间投入</code>的意义是什么？我的理解是这样的：</p><blockquote><p><code>暗时间</code>占据<code>时间投入</code>的很大部分，在这段时间中执行的是有效思考，它对于事情的成效起了绝对关键性作用，在他人看来就是你的效率很高，他人看不到你的<code>暗时间</code>投入，认为在相同时间条件下，你的成果产出会明显快于平均水平。</p></blockquote><h2 id="那些利用好了暗时间的人，他们的生命会有什么不一样？"><a href="#那些利用好了暗时间的人，他们的生命会有什么不一样？" class="headerlink" title="那些利用好了暗时间的人，他们的生命会有什么不一样？"></a>那些利用好了<code>暗时间</code>的人，他们的生命会有什么不一样？</h2><p>简而言之，这些人能在<code>不止</code>一个领域做到很卓越。他们留给别人最大的疑惑就是：</p><blockquote><p>这人怎么会有这么多的时间来学习，来折腾？</p></blockquote><p>推荐阅读<a href="https://www.zhihu.com/question/28517512" target="_blank" rel="noopener">在多个领域有所成就的人是怎么做到的？</a></p><h2 id="如何才能有效利用「暗时间」？"><a href="#如何才能有效利用「暗时间」？" class="headerlink" title="如何才能有效利用「暗时间」？"></a>如何才能有效利用「暗时间」？</h2><p>关于利用「暗时间」，书中大致列了3点：</p><ul><li>快速进入状态的能力</li><li>养成能长时间保持思考状态的习惯</li><li>抗干扰的能力</li></ul><p>「快速进入状态」的诀窍在于「减少上下文切换」。当我们同时处理多任务的时候，在任务切换的过程中，至少需要做两个事情：</p><ol><li>暂停当前的事情，当你再次回来的时候，需要重新梳理你之前的状态。</li><li>投入一个新的任务，这时候你需要梳理新任务的上下文</li></ol><p>「熟悉新任务上下文」的时间就是被浪费的「暗时间」。所以要尽可能少的并发执行任务，或者具备快速进入新任务状态的能力。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb索引最佳实践</title>
      <link href="/2016/01/30/mongodb%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2016/01/30/mongodb%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>前几天公司的一个核心服务突然断断续续抽风，访问奇慢，经排查定位是我们的mongdb数据库read响应很慢，有几张表的read响应时间居然达到8-10S，数据量实在不大，也就200W多一点，后面分析慢查询日志，根据日志判断，尝试了很多次加索引，磕磕碰碰弄了好几次才解决问题。这次事件给我一个很大的警醒，对于数据量与日俱增的生产系统，负责人一定要具备应对突发事件的技术能力。</p><p>因着这个事件，我专门抽出一整段时间来阅读了mongdb官方的<a href="https://docs.mongodb.org/v3.0/core/indexes-introduction/" target="_blank" rel="noopener">索引文档</a>，并逐一做了验证，将这些过程记录下来。</p><h3 id="认识-explain"><a href="#认识-explain" class="headerlink" title="认识 explain()"></a>认识 explain()</h3><p>在介入索引的实际内容之前，我们需要先认识一个工具<code>explain()</code>。 因为索引的理论知识其实很简单，我们需要知道去验证我们设置的索引是否有效，是否真的按照我们的想法在发挥作用，而<code>explain()</code>为我们提供了详细的反馈信息。</p><p><code>explain()</code>是mongodb提供的一个专门用于分析mongdb操作执行效率的工具，它有三种模式：</p><ul><li><p>queryPlanner</p></li><li><p>executionStats</p></li><li><p>allPlansExecution</p></li></ul><p>其中 <code>queryPlanner</code> 为默认模式，而 <code>allPlansExecution</code> 信息最为详细，建议使用此模式进行分析。</p><p>我们来看一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行分析</span></span><br><span class="line">db.ServiceInvokerSeq.find( </span><br><span class="line">    &#123; </span><br><span class="line">         <span class="string">"serviceId"</span>:ObjectId(<span class="string">"556bf36bfa0bab5b3fd30189"</span>),</span><br><span class="line">         <span class="string">"sdCode"</span> : <span class="string">"ORDER003"</span>, </span><br><span class="line">         <span class="string">"en"</span> : <span class="string">"b1bdb597"</span>, </span><br><span class="line">    &#125;</span><br><span class="line">).explain(<span class="string">"allPlansExecution"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回信息</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"queryPlanner"</span> : &#123;</span><br><span class="line">        <span class="string">"plannerVersion"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"namespace"</span> : <span class="string">"weipos.ServiceInvokerSeq"</span>,</span><br><span class="line">        <span class="string">"indexFilterSet"</span> : <span class="keyword">false</span>,</span><br><span class="line">        <span class="string">"parsedQuery"</span> : &#123;</span><br><span class="line">            <span class="string">"$and"</span> : [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"en"</span> : &#123;</span><br><span class="line">                        <span class="string">"$eq"</span> : <span class="string">"b1bdb597"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"sdCode"</span> : &#123;</span><br><span class="line">                        <span class="string">"$eq"</span> : <span class="string">"ORDER003"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"serviceId"</span> : &#123;</span><br><span class="line">                        <span class="string">"$eq"</span> : ObjectId(<span class="string">"556bf36bfa0bab5b3fd30189"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"winningPlan"</span> : &#123;</span><br><span class="line">            <span class="string">"stage"</span> : <span class="string">"KEEP_MUTATIONS"</span>,</span><br><span class="line">            <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">                <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                <span class="string">"filter"</span> : &#123;</span><br><span class="line">                    <span class="string">"sdCode"</span> : &#123;</span><br><span class="line">                        <span class="string">"$eq"</span> : <span class="string">"ORDER003"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">                    <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                    <span class="string">"keyPattern"</span> : &#123;</span><br><span class="line">                        <span class="string">"serviceId"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"en"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"time"</span> : <span class="number">1</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"indexName"</span> : <span class="string">"serviceId_1_en_1_time_1"</span>,</span><br><span class="line">                    <span class="string">"isMultiKey"</span> : <span class="keyword">false</span>,</span><br><span class="line">                    <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                    <span class="string">"indexBounds"</span> : &#123;</span><br><span class="line">                        <span class="string">"serviceId"</span> : [</span><br><span class="line">                            <span class="string">"[ObjectId('556bf36bfa0bab5b3fd30189'), ObjectId('556bf36bfa0bab5b3fd30189')]"</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">"en"</span> : [</span><br><span class="line">                            <span class="string">"[\"b1bdb597\", \"b1bdb597\"]"</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">"time"</span> : [</span><br><span class="line">                            <span class="string">"[MinKey, MaxKey]"</span></span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"rejectedPlans"</span> : [ ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"executionStats"</span> : &#123;</span><br><span class="line">        <span class="string">"executionSuccess"</span> : <span class="keyword">true</span>,</span><br><span class="line">        <span class="string">"nReturned"</span> : <span class="number">1367</span>,</span><br><span class="line">        <span class="string">"executionTimeMillis"</span> : <span class="number">3</span>,</span><br><span class="line">        <span class="string">"totalKeysExamined"</span> : <span class="number">1367</span>,</span><br><span class="line">        <span class="string">"totalDocsExamined"</span> : <span class="number">1367</span>,</span><br><span class="line">        <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">            <span class="string">"stage"</span> : <span class="string">"KEEP_MUTATIONS"</span>,</span><br><span class="line">            <span class="string">"nReturned"</span> : <span class="number">1367</span>,</span><br><span class="line">            <span class="string">"executionTimeMillisEstimate"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"works"</span> : <span class="number">1368</span>,</span><br><span class="line">            <span class="string">"advanced"</span> : <span class="number">1367</span>,</span><br><span class="line">            <span class="string">"needTime"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"needFetch"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"saveState"</span> : <span class="number">10</span>,</span><br><span class="line">            <span class="string">"restoreState"</span> : <span class="number">10</span>,</span><br><span class="line">            <span class="string">"isEOF"</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">"invalidates"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">                <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">                <span class="string">"filter"</span> : &#123;</span><br><span class="line">                    <span class="string">"sdCode"</span> : &#123;</span><br><span class="line">                        <span class="string">"$eq"</span> : <span class="string">"ORDER003"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"nReturned"</span> : <span class="number">1367</span>,</span><br><span class="line">                <span class="string">"executionTimeMillisEstimate"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"works"</span> : <span class="number">1368</span>,</span><br><span class="line">                <span class="string">"advanced"</span> : <span class="number">1367</span>,</span><br><span class="line">                <span class="string">"needTime"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"needFetch"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"saveState"</span> : <span class="number">10</span>,</span><br><span class="line">                <span class="string">"restoreState"</span> : <span class="number">10</span>,</span><br><span class="line">                <span class="string">"isEOF"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"invalidates"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"docsExamined"</span> : <span class="number">1367</span>,</span><br><span class="line">                <span class="string">"alreadyHasObj"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">                    <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,</span><br><span class="line">                    <span class="string">"nReturned"</span> : <span class="number">1367</span>,</span><br><span class="line">                    <span class="string">"executionTimeMillisEstimate"</span> : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"works"</span> : <span class="number">1368</span>,</span><br><span class="line">                    <span class="string">"advanced"</span> : <span class="number">1367</span>,</span><br><span class="line">                    <span class="string">"needTime"</span> : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"needFetch"</span> : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"saveState"</span> : <span class="number">10</span>,</span><br><span class="line">                    <span class="string">"restoreState"</span> : <span class="number">10</span>,</span><br><span class="line">                    <span class="string">"isEOF"</span> : <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"invalidates"</span> : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"keyPattern"</span> : &#123;</span><br><span class="line">                        <span class="string">"serviceId"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"en"</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">"time"</span> : <span class="number">1</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"indexName"</span> : <span class="string">"serviceId_1_en_1_time_1"</span>,</span><br><span class="line">                    <span class="string">"isMultiKey"</span> : <span class="keyword">false</span>,</span><br><span class="line">                    <span class="string">"direction"</span> : <span class="string">"forward"</span>,</span><br><span class="line">                    <span class="string">"indexBounds"</span> : &#123;</span><br><span class="line">                        <span class="string">"serviceId"</span> : [</span><br><span class="line">                            <span class="string">"[ObjectId('556bf36bfa0bab5b3fd30189'), ObjectId('556bf36bfa0bab5b3fd30189')]"</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">"en"</span> : [</span><br><span class="line">                            <span class="string">"[\"b1bdb597\", \"b1bdb597\"]"</span></span><br><span class="line">                        ],</span><br><span class="line">                        <span class="string">"time"</span> : [</span><br><span class="line">                            <span class="string">"[MinKey, MaxKey]"</span></span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="string">"keysExamined"</span> : <span class="number">1367</span>,</span><br><span class="line">                    <span class="string">"dupsTested"</span> : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"dupsDropped"</span> : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"seenInvalidated"</span> : <span class="number">0</span>,</span><br><span class="line">                    <span class="string">"matchTested"</span> : <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"allPlansExecution"</span> : [ ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"serverInfo"</span> : &#123;</span><br><span class="line">        <span class="string">"host"</span> : <span class="string">"iZ25zhv23mwZ"</span>,</span><br><span class="line">        <span class="string">"port"</span> : <span class="number">27017</span>,</span><br><span class="line">        <span class="string">"version"</span> : <span class="string">"3.0.0"</span>,</span><br><span class="line">        <span class="string">"gitVersion"</span> : <span class="string">"a841fd6394365954886924a35076691b4d149168"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个返回结果乍一看非常复杂，我们需要抽丝剥茧，层层定位真正对我们有意义的信息，下面我列了一些我们需要关注的内容：</p><h4 id="executionTimeMillis"><a href="#executionTimeMillis" class="headerlink" title="executionTimeMillis"></a>executionTimeMillis</h4><p><code>executionTimeMillis</code>的意义是语句的执行时间，我们当然希望这个值越小越好。仔细观察，我们发现会存在<code>3</code>个<code>executionTimeMillis</code>,分别如下：</p><ul><li><p>executionStats.executionTimeMillis<br>  该query的整体查询时间</p></li><li><p>executionStats.executionStages.executionTimeMillisEstimate<br>  该查询根据index去检索document获取1367行具体数据的时间</p></li><li><p>executionStats.executionStages.inputStage.executionTimeMillisEstimate<br>  该查询扫描1367行index所用时间</p></li></ul><h4 id="扫描数-VS-返回数"><a href="#扫描数-VS-返回数" class="headerlink" title="扫描数 VS 返回数"></a>扫描数 VS 返回数</h4><p>这里主要涉及到3个item：</p><ul><li>nReturned<br>  返回条目数</li><li>totalKeysExamined<br>  索引扫描条目数</li><li>totalDocsExamined<br>  文档扫描条目数</li></ul><p>这三个数据最优状态应该是这样的：</p><blockquote><p>nReturned=totalKeysExamined  &amp;&amp;  totalDocsExamined=0</p></blockquote><p>也就是说， 用索引就完成了数据的查询，返回的文档数刚好被索引扫描全部查找到(nReturned=totalKeysExamined)，而且没有扫描额外的文档(totalDocsExamined=0)</p><p>当然，如下状态也是可以接受的：</p><blockquote><p>nReturned=totalKeysExamined=totalDocsExamined</p></blockquote><p>这种情况是正常的索引利用，没有多余的文档扫描。</p><p>如果加上排序，为了保证排序<code>不</code>在内存中完成，我们可以在保证nReturned=totalDocsExamined的基础上，totalKeysExamined可以大于totalDocsExamined与nReturned，因为在数量大的情况下，相对于「把sort放到内存中」，「totalKeysExamined&gt;totalDocsExamined」还是挺划算的。</p><h4 id="stage-分析"><a href="#stage-分析" class="headerlink" title="stage 分析"></a>stage 分析</h4><p>这里说的<code>stage</code>是指<code>winningPlan.stage</code> 或者<code>executionStages.stage</code>还有<code>inputStage.stage</code>. 为啥要说<code>stage</code>呢，是因为它就决定了扫描范围，说白了，它影响了<code>totalKeysExamined</code>,<code>totalDocsExamined</code>这二者的值。</p><p><code>stage</code> 的值分别有：</p><ul><li>COLLSCAN      （×）<br>  全表扫描</li><li>IXSCAN        （√）<br>  索引扫描</li><li>FETCH         （√）<br>  根据索引去检索指定document</li><li>SHARD_MERGE    （-）<br>  将各个分片返回数据进行merge</li><li>SORT          （×）<br>  表明在内存中进行了排序</li><li>LIMIT         （√）<br>  使用limit限制返回数</li><li>SKIP          （-）<br>  使用skip进行跳过</li><li>IDHACK        （√）<br>  针对_id进行查询</li><li>SHARDING_FILTER （-）<br>  通过mongos对分片数据进行查询</li><li>COUNT         （×）<br>  利用db.coll.explain().count()之类进行count运算</li><li>COUNTSCAN     （×）<br>  count不使用用Index进行count时的stage返回</li><li>COUNT_SCAN    （√）<br>  count使用了Index进行count时的stage返回</li><li>SUBPLA        （×）<br>  未使用到索引的$or查询的stage返回</li></ul><p>如上，我对这些类型的优劣已经做了基本判断，后续会有一个详细的例子来说明如何一步步进行索引优化分析。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>在分析不同索引的不同特性之前，先把一些语法性的东西捋一遍。</p><ul><li>创建索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.ensureIndex(&#123;a:<span class="number">1</span>,b:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><ul><li>查看集合的所有索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.getIndexes();</span><br></pre></td></tr></table></figure><ul><li>删除索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按索引名来删除</span></span><br><span class="line">db.collection.dropIndex(<span class="string">"a_1_b_1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按字段名删除</span></span><br><span class="line">db.collection.dropIndex(&#123;a:<span class="number">1</span>,b:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>索引重建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.reIndex()</span><br></pre></td></tr></table></figure><ul><li>修改索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// To modify an existing index, you need to drop and recreate the index.</span></span><br></pre></td></tr></table></figure><ul><li>强制使用索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制使用索引名</span></span><br><span class="line">db.collection.find(&#123;&#125;).hint(<span class="string">"a_1_b_1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制使用索引字段域</span></span><br><span class="line">db.collection.find(&#123;&#125;).hint(&#123;a:<span class="number">1</span>,b:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="索引细分"><a href="#索引细分" class="headerlink" title="索引细分"></a>索引细分</h3><p>首先，我们来瞟一眼mongodb的索引结构图</p><p><img src="http://7arnte.com1.z0.glb.clouddn.com/mongodb.index.png" alt></p><p>从图中看出，索引部分内容不多，我们需要知道的是其适合的使用场景，以及需要知道避开限制它们发挥作用的限制点。</p><h4 id="单键索引-Single-Field"><a href="#单键索引-Single-Field" class="headerlink" title="单键索引 Single-Field"></a>单键索引 Single-Field</h4><p><code>单键索引</code> 是指只有一个字段域(field)的索引，一般使用场景很受限。官方文档额外提到了3个<a href="https://docs.mongodb.org/manual/core/index-single/#cases" target="_blank" rel="noopener">case</a>.</p><ul><li>_id</li><li>Indexes on Embedded </li><li>Indexes on Embedded Documents</li></ul><p>这些基本上不用多说， 了解一下就好。在实际环境中，抛开<code>简单日志性表</code>,<code>业务性</code>属性比较强的表一般都不是<code>单键索引</code>所能支撑的，所以在建索引的时候，一定要综合考虑下，不能仅仅为了满足当前需求，简单粗暴直接加上单键索引。因为你一旦这么做了，你会发现最后你的表中有很多不同字段的单键索引，他们要联合起作用的话就比较麻烦。</p><h4 id="复合索引-compound"><a href="#复合索引-compound" class="headerlink" title="复合索引 compound"></a>复合索引 compound</h4><p><code>复合索引</code>应该是适用场景最广的一种索引，它包含了多个field，所以细节比较复杂，我们在这里一一进行分析。</p><ul><li>1.排序顺序(Sort Order)</li></ul><p><code>排序顺序(Sort Order)</code> 对于复合索引来说特别重要，先看看官网的描述：</p><blockquote><p>Indexes store references to fields in either ascending (1) or descending (-1) sort order. For single-field indexes, the sort order of keys doesn’t matter because MongoDB can traverse the index in either direction. <code>However</code>, for compound indexes, sort order can <code>matter</code> in determining whether the index can support a sort operation.</p></blockquote><p>对于<code>单键索引</code>来说， <code>Sort Order</code>没那么重要，因为mongodb能从两个方向(升序，降序)使用索引。 但是对于<code>复合索引</code>来说，索引中的排序顺序是由多个field决定的，一旦某个field顺序有误，则导致索引无法被命中。下面看看一个例子：</p><p>首先，存在一个这样的索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.events.createIndex( &#123; <span class="string">"username"</span> : <span class="number">1</span>, <span class="string">"date"</span> : -<span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure><p>可以命中索引的情况有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配索引本身的排序顺序</span></span><br><span class="line">db.events.find().sort( &#123; username: <span class="number">1</span>, date: -<span class="number">1</span> &#125; )</span><br><span class="line"><span class="comment">// 匹配索引本身的排序顺序的「反序」</span></span><br><span class="line">db.events.find().sort( &#123; username: -<span class="number">1</span>, date: <span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure><p>这里，我们来用<code>explain()</code>说话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    // 执行查询</span><br><span class="line">    db.events.find().sort( &#123; username: 1, date: -1 &#125; ).explain();</span><br><span class="line"></span><br><span class="line">    // explain result</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;queryPlanner&quot; : &#123;</span><br><span class="line">        &quot;plannerVersion&quot; : 1,</span><br><span class="line">        &quot;namespace&quot; : &quot;test.events&quot;,</span><br><span class="line">        &quot;indexFilterSet&quot; : false,</span><br><span class="line">        &quot;parsedQuery&quot; : &#123;</span><br><span class="line">            &quot;$and&quot; : [ ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;winningPlan&quot; : &#123;</span><br><span class="line">            &quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">            &quot;inputStage&quot; : &#123;</span><br><span class="line">                &quot;stage&quot; : &quot;IXSCAN&quot;,   // 使用索引扫描，最高效的stage</span><br><span class="line">                &quot;keyPattern&quot; : &#123;</span><br><span class="line">                    &quot;username&quot; : 1,</span><br><span class="line">                    &quot;date&quot; : -1</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;indexName&quot; : &quot;username_1_date_-1&quot;, // 命中的索引名</span><br><span class="line">                &quot;isMultiKey&quot; : false,</span><br><span class="line">                &quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">                &quot;indexBounds&quot; : &#123;</span><br><span class="line">                    &quot;username&quot; : [</span><br><span class="line">                        &quot;[MinKey, MaxKey]&quot;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;date&quot; : [</span><br><span class="line">                        &quot;[MaxKey, MinKey]&quot;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;rejectedPlans&quot; : [ ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;serverInfo&quot; : &#123;</span><br><span class="line">        &quot;host&quot; : &quot;yijianbodeMacBook-Air.local&quot;,</span><br><span class="line">        &quot;port&quot; : 27017,</span><br><span class="line">        &quot;version&quot; : &quot;3.0.2&quot;,</span><br><span class="line">        &quot;gitVersion&quot; : &quot;nogitversion&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如下的情况则<code>不</code>能命中索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// date 字段排序顺序不匹配</span></span><br><span class="line">db.events.find().sort( &#123; username: <span class="number">1</span>, date: <span class="number">1</span> &#125; )</span><br><span class="line"><span class="comment">// username 字段排序顺序不匹配</span></span><br><span class="line">db.events.find().sort( &#123; username: -<span class="number">1</span>, date: -<span class="number">1</span> &#125; )</span><br></pre></td></tr></table></figure><p>同样，这里我们也用<code>explain()</code>来说话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     <span class="comment">// 执行查询</span></span><br><span class="line">     db.events.find().sort( &#123; username: <span class="number">1</span>, date: <span class="number">1</span> &#125; ).explain();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// explain result</span></span><br><span class="line">     &#123;</span><br><span class="line">    <span class="string">"queryPlanner"</span> : &#123;</span><br><span class="line">        <span class="string">"plannerVersion"</span> : <span class="number">1</span>,</span><br><span class="line">        <span class="string">"namespace"</span> : <span class="string">"test.events"</span>,</span><br><span class="line">        <span class="string">"indexFilterSet"</span> : <span class="keyword">false</span>,</span><br><span class="line">        <span class="string">"parsedQuery"</span> : &#123;</span><br><span class="line">            <span class="string">"$and"</span> : [ ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"winningPlan"</span> : &#123;</span><br><span class="line">            <span class="string">"stage"</span> : <span class="string">"SORT"</span>, <span class="comment">// 在内存中排序了，要尽量避免的事情！</span></span><br><span class="line">            <span class="string">"sortPattern"</span> : &#123;</span><br><span class="line">                <span class="string">"username"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"date"</span> : <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">                <span class="string">"stage"</span> : <span class="string">"COLLSCAN"</span>, <span class="comment">// 全表扫描！绝对要避免的事情！</span></span><br><span class="line">                <span class="string">"filter"</span> : &#123;</span><br><span class="line">                    <span class="string">"$and"</span> : [ ]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"direction"</span> : <span class="string">"forward"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"rejectedPlans"</span> : [ ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"serverInfo"</span> : &#123;</span><br><span class="line">        <span class="string">"host"</span> : <span class="string">"yijianbodeMacBook-Air.local"</span>,</span><br><span class="line">        <span class="string">"port"</span> : <span class="number">27017</span>,</span><br><span class="line">        <span class="string">"version"</span> : <span class="string">"3.0.2"</span>,</span><br><span class="line">        <span class="string">"gitVersion"</span> : <span class="string">"nogitversion"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://docs.mongodb.org/manual/tutorial/sort-results-with-indexes/#sort-on-multiple-fields" target="_blank" rel="noopener">官方文档</a>对于这个特性有比较详细的说明，值得一看。</p><ul><li>2.索引前缀(Prefixes) </li></ul><p><code>索引前缀</code>正是复合索引的魅力所在之处，它能灵活的支撑不同的字段组合查询场景。</p><p>例如存在这么一个索引：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.gift.ensureIndex(&#123; "item": 1, "location": 1, "stock": 1 &#125;);</span><br></pre></td></tr></table></figure><p>那么，这个索引存在两个索引前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- &#123;item:<span class="number">1</span>&#125;</span><br><span class="line">- &#123;item:<span class="number">1</span>,location&#125;</span><br></pre></td></tr></table></figure><p>所以，如下这些查询都是能命中索引的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.gift.find(&#123;item:<span class="number">1</span>&#125;); <span class="comment">// #1</span></span><br><span class="line">db.gift.find(&#123;item:<span class="number">1</span>,location&#125;); <span class="comment">// #2</span></span><br><span class="line">db.gift.find(&#123; <span class="string">"item"</span>: <span class="number">1</span>, <span class="string">"location"</span>: <span class="number">1</span>, <span class="string">"stock"</span>: <span class="number">1</span> &#125;); <span class="comment">// #3</span></span><br><span class="line">db.gift.find(&#123; <span class="string">"item"</span>: <span class="number">1</span>, <span class="string">"stock"</span>: <span class="number">1</span> &#125;); <span class="comment">// #4</span></span><br></pre></td></tr></table></figure><p>需要说明的是， <code>#4</code>效率是会低于 <code>#2</code> 的。而没有带前缀的查询都是无法命中索引的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.gift.find(&#123;<span class="string">"location"</span>: <span class="number">1</span>, <span class="string">"stock"</span>: <span class="number">1</span> &#125;); <span class="comment">// #1</span></span><br><span class="line">db.gift.find(&#123;<span class="string">"stock"</span>: <span class="number">1</span> &#125;); <span class="comment">// #2</span></span><br></pre></td></tr></table></figure><ul><li>3.索引交叉(Index Intersection)</li></ul><p><code>索引交叉</code>是指当一个表存在多个索引，在某个查询当中同时使用了不同索引进行查询的情况。</p><p>例如存在这么两个索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; qty: <span class="number">1</span> &#125;</span><br><span class="line">&#123; item: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>下面这个查询就会触发索引交叉机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.orders.find( &#123; item: &quot;abc123&quot;, qty: &#123; $gt: 15 &#125; &#125; )</span><br></pre></td></tr></table></figure><p>当索引中存在<code>复合索引</code>，结合<code>索引交叉</code>机制时，也同样满足<code>索引前缀</code>原则，这个算是mongodb对于索引命中率的优化，详情可以参考<a href="https://docs.mongodb.org/manual/core/index-intersection/#index-prefix-intersection" target="_blank" rel="noopener">官方文档</a></p><h4 id="多键索引-Multikey-Indexes"><a href="#多键索引-Multikey-Indexes" class="headerlink" title="多键索引(Multikey Indexes)"></a>多键索引(Multikey Indexes)</h4><p><code>多键索引</code>是指建在<code>array</code>类型上的索引。</p><blockquote><p>MongoDB automatically creates a multikey index if any indexed field is an array; you do not need to explicitly specify the multikey type.</p></blockquote><p>用的场景很窄，不多说，直接看<a href="https://docs.mongodb.org/manual/core/index-multikey/" target="_blank" rel="noopener">文档</a></p><h4 id="地理位置索引-GEO"><a href="#地理位置索引-GEO" class="headerlink" title="地理位置索引(GEO)"></a>地理位置索引(GEO)</h4><p>这类索引是mongodb索引的一大亮点，基于LBS的应用服务都能用上，非常方便，因为平时用的不深，场景也比较单一，不再多说。</p><h4 id="全文搜索-Text"><a href="#全文搜索-Text" class="headerlink" title="全文搜索(Text)"></a>全文搜索(Text)</h4><p>不支持中文，对于我们来说基本等于没用。</p><h4 id="哈希索引-Hashed"><a href="#哈希索引-Hashed" class="headerlink" title="哈希索引(Hashed)"></a>哈希索引(Hashed)</h4><p><code>哈希索引</code>是指以数据的哈希值作为索引值，它的特性是速度快。</p><blockquote><p>Hashed indexes maintain entries with hashes of the values of the indexed field. The hashing function collapses embedded documents and computes the hash for the entire value but <code>does not support</code> multi-key (i.e. arrays) indexes.</p></blockquote><p>注意一下它的语法：</p><blockquote><p>db.active.createIndex( { a: “hashed” } )</p></blockquote><p>这种索引比较适合一些格式固定但是数据量比较大的字段，例如<code>身份证号码</code>，<code>手机号码</code>等。 hash 值的计算和匹配都是mongodb自动完成的，不需要开发者参与，非常方便。</p><p>说完了索引的<code>类型</code>，再来看看索引的<code>属性</code>。</p><h4 id="时效性-ttl"><a href="#时效性-ttl" class="headerlink" title="时效性 ttl"></a>时效性 ttl</h4><p><code>ttl</code> 可以让mongodb自动按时间来移除数据，对于一些日志数据表来说，非常方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.eventlog.createIndex( &#123; <span class="string">"lastModifiedDate"</span>: <span class="number">1</span> &#125;, &#123; expireAfterSeconds: <span class="number">3600</span> &#125; )</span><br></pre></td></tr></table></figure><p><code>expireAfterSeconds</code> 这个属性就是表示此索引具备了<code>ttl</code>特性，单位为秒。</p><p>这个属性的原理如下：</p><blockquote><p>A background thread in mongod reads the values in the index and removes expired documents from the collection.</p></blockquote><p>有不少限制：</p><blockquote><ol><li>TTL indexes are a single-field indexes. Compound indexes do not support TTL and ignores the expireAfterSeconds option.</li><li>The _id field does not support TTL indexes.</li><li>You cannot create a TTL index on a capped collection because MongoDB cannot remove documents from a capped collection.</li><li>You cannot use createIndex() to change the value of expireAfterSeconds of an existing index. Instead use the collMod database command in conjunction with the index collection flag. Otherwise, to change the value of the option of an existing index, you must drop the index first and recreate.</li><li>If a non-TTL single-field index already exists for a field, you cannot create a TTL index on the same field since you cannot create indexes that have the same key specification and differ only by the options. To change a non-TTL single-field index to a TTL index, you must drop the index first and recreate with the expireAfterSeconds option.</li></ol></blockquote><p>这部分内容<a href="https://docs.mongodb.org/manual/core/index-ttl/" target="_blank" rel="noopener">官方文档</a>说的很详细，建议细读。</p><h4 id="唯一性-Unique"><a href="#唯一性-Unique" class="headerlink" title="唯一性 Unique"></a>唯一性 Unique</h4><p>唯一索引非常好理解，语法如下：</p><blockquote><p>db.members.createIndex( { “user_id”: 1 }, { unique: true } )</p></blockquote><p>需要注意下，当索引字段域缺少了数据时，mongodb默认会存储一个null值，这意味着如果再次有缺失值，则会触发<code>唯一性</code>机制，操作会报错。</p><p>同时有这么一个限制：</p><blockquote><p>You may not specify a unique constraint on a hashed index.</p></blockquote><h4 id="稀疏性-Sparse-Partial"><a href="#稀疏性-Sparse-Partial" class="headerlink" title="稀疏性 Sparse|Partial"></a>稀疏性 Sparse|Partial</h4><p><code>稀疏性</code> 对于索引的灵活性特别有意义。它可以把索引建在只感兴趣的数据上。需要特别说明的是，<code>sparse</code>是<code>3.2</code> 之前的支持方式，<code>3.2</code>版本开始支持<code>partial</code>，它的性能更高，同时定义方式也更为灵活。如果mongdb版本为3.2以上，建议直接使用<code>Partial</code>.</p><p>还是来看一下语法吧:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 只对rating大于5的数据索引</span></span><br><span class="line">db.restaurants.createIndex(</span><br><span class="line">   &#123; cuisine: <span class="number">1</span> &#125;,</span><br><span class="line">   &#123; partialFilterExpression: &#123; rating: &#123; $gt: <span class="number">5</span> &#125; &#125; &#125;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 只对name存在的数据索引, Sparse就只支持此模式</span></span><br><span class="line">db.contacts.createIndex(</span><br><span class="line">   &#123; name: <span class="number">1</span> &#125;,</span><br><span class="line">   &#123; partialFilterExpression: &#123; name: &#123; $exists: <span class="keyword">true</span> &#125; &#125; &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="https://docs.mongodb.org/manual/core/index-partial/#index-type-partial" target="_blank" rel="noopener">文档</a>的话也是值得通读一遍的。</p><h3 id="优化实践"><a href="#优化实践" class="headerlink" title="优化实践"></a>优化实践</h3><p>在了解了mongodb的索引机制以后，下面以一个实例来展示索引优化的过程。</p><p>首先，我们有一个集合gift，它的数据如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84cbbdd239ce1b21b90f"</span>), <span class="string">"item"</span> : <span class="number">1</span>, <span class="string">"location"</span> : <span class="string">"changsha"</span>, <span class="string">"stock"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84cbbdd239ce1b21b910"</span>), <span class="string">"item"</span> : <span class="number">2</span>, <span class="string">"location"</span> : <span class="string">"beijing"</span>, <span class="string">"stock"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84cbbdd239ce1b21b911"</span>), <span class="string">"item"</span> : <span class="number">3</span>, <span class="string">"location"</span> : <span class="string">"changsha"</span>, <span class="string">"stock"</span> : <span class="number">20</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84cbbdd239ce1b21b912"</span>), <span class="string">"item"</span> : <span class="number">4</span>, <span class="string">"location"</span> : <span class="string">"guangzhou"</span>, <span class="string">"stock"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84cbbdd239ce1b21b913"</span>), <span class="string">"item"</span> : <span class="number">5</span>, <span class="string">"location"</span> : <span class="string">"tianjing"</span>, <span class="string">"stock"</span> : <span class="number">26</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84cbbdd239ce1b21b914"</span>), <span class="string">"item"</span> : <span class="number">6</span>, <span class="string">"location"</span> : <span class="string">"changsha"</span>, <span class="string">"stock"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84cbbdd239ce1b21b915"</span>), <span class="string">"item"</span> : <span class="number">7</span>, <span class="string">"location"</span> : <span class="string">"yiyang"</span>, <span class="string">"stock"</span> : <span class="number">64</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84cbbdd239ce1b21b916"</span>), <span class="string">"item"</span> : <span class="number">8</span>, <span class="string">"location"</span> : <span class="string">"changsha"</span>, <span class="string">"stock"</span> : <span class="number">34</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84cbbdd239ce1b21b917"</span>), <span class="string">"item"</span> : <span class="number">9</span>, <span class="string">"location"</span> : <span class="string">"wuhan"</span>, <span class="string">"stock"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"56ad84ccbdd239ce1b21b918"</span>), <span class="string">"item"</span> : <span class="number">10</span>, <span class="string">"location"</span> : <span class="string">"shenzheng"</span>, <span class="string">"stock"</span> : <span class="number">34</span> &#125;</span><br></pre></td></tr></table></figure><p>我们想要执行的语句如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.gift.find(&#123;item :&#123;<span class="string">"$gt"</span>:<span class="number">4</span>&#125;,location:<span class="string">"changsha"</span>&#125;).sort(&#123;stock:-<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>首先，看下无索引的explain()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"queryPlanner"</span> : &#123;...&#125; <span class="comment">// 略去</span></span><br><span class="line">         </span><br><span class="line">    <span class="string">"executionStats"</span> : &#123;</span><br><span class="line">        <span class="string">"executionSuccess"</span> : <span class="keyword">true</span>,</span><br><span class="line">        <span class="string">"nReturned"</span> : <span class="number">2</span>,            <span class="comment">// 返回2</span></span><br><span class="line">        <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="string">"totalKeysExamined"</span> : <span class="number">0</span>,   <span class="comment">// 索引扫描数0 </span></span><br><span class="line">        <span class="string">"totalDocsExamined"</span> : <span class="number">10</span>,  <span class="comment">// 文档扫描数10</span></span><br><span class="line">        <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">            <span class="string">"stage"</span> : <span class="string">"SORT"</span>,      <span class="comment">// 内存排序</span></span><br><span class="line">            <span class="string">"nReturned"</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">"executionTimeMillisEstimate"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"works"</span> : <span class="number">16</span>,</span><br><span class="line">            <span class="string">"advanced"</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">"needTime"</span> : <span class="number">12</span>,</span><br><span class="line">            <span class="string">"needFetch"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"saveState"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"restoreState"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"isEOF"</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">"invalidates"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"sortPattern"</span> : &#123;</span><br><span class="line">                <span class="string">"stock"</span> : -<span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"memUsage"</span> : <span class="number">164</span>,</span><br><span class="line">            <span class="string">"memLimit"</span> : <span class="number">33554432</span>,</span><br><span class="line">            <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">                <span class="string">"stage"</span> : <span class="string">"COLLSCAN"</span>,  <span class="comment">// 全表扫描</span></span><br><span class="line">                <span class="string">"filter"</span> : &#123;</span><br><span class="line">                    <span class="string">"$and"</span> : [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"location"</span> : &#123;</span><br><span class="line">                                <span class="string">"$eq"</span> : <span class="string">"changsha"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="string">"item"</span> : &#123;</span><br><span class="line">                                <span class="string">"$gt"</span> : <span class="number">4</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"serverInfo"</span> : &#123;&#125;, <span class="comment">// 略去</span></span><br><span class="line">    <span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，性能非常低，列一下可优化的点：</p><ul><li>全表扫描 </li><li>内存排序 </li><li>totalDocsExamined&gt;(nReturned=totalKeysExamined=0)</li></ul><p>首先考虑内存排序问题，先对排序字段加个索引，看看效果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">db.gift.ensureIndex(&#123;stock:<span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// explain result</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="string">"executionStats"</span> : &#123;</span><br><span class="line">        <span class="string">"executionSuccess"</span> : <span class="keyword">true</span>,</span><br><span class="line">        <span class="string">"nReturned"</span> : <span class="number">2</span>,</span><br><span class="line">        <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="string">"totalKeysExamined"</span> : <span class="number">10</span>,  <span class="comment">// 索引扫描数还是很大</span></span><br><span class="line">        <span class="string">"totalDocsExamined"</span> : <span class="number">10</span>,  <span class="comment">// 文档扫描数还是很大（全表）</span></span><br><span class="line">        <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">            <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"$and"</span> : [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"location"</span> : &#123;</span><br><span class="line">                            <span class="string">"$eq"</span> : <span class="string">"changsha"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"item"</span> : &#123;</span><br><span class="line">                            <span class="string">"$gt"</span> : <span class="number">4</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"nReturned"</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">"executionTimeMillisEstimate"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"works"</span> : <span class="number">11</span>,</span><br><span class="line">            <span class="string">"advanced"</span> : <span class="number">2</span>,</span><br><span class="line">            <span class="string">"needTime"</span> : <span class="number">8</span>,</span><br><span class="line">            <span class="string">"needFetch"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"saveState"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"restoreState"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"isEOF"</span> : <span class="number">1</span>,</span><br><span class="line">            <span class="string">"invalidates"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"docsExamined"</span> : <span class="number">10</span>,</span><br><span class="line">            <span class="string">"alreadyHasObj"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="string">"inputStage"</span> : &#123;</span><br><span class="line">                <span class="string">"stage"</span> : <span class="string">"IXSCAN"</span>,  <span class="comment">// 启用索引了，不再内存排序</span></span><br><span class="line">                <span class="string">"nReturned"</span> : <span class="number">10</span>,</span><br><span class="line">                <span class="string">"executionTimeMillisEstimate"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"works"</span> : <span class="number">10</span>,</span><br><span class="line">                <span class="string">"advanced"</span> : <span class="number">10</span>,</span><br><span class="line">                <span class="string">"needTime"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"needFetch"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"saveState"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"restoreState"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"isEOF"</span> : <span class="number">1</span>,</span><br><span class="line">                <span class="string">"invalidates"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"keyPattern"</span> : &#123;</span><br><span class="line">                    <span class="string">"stock"</span> : <span class="number">1</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"indexName"</span> : <span class="string">"stock_1"</span>,</span><br><span class="line">                <span class="string">"isMultiKey"</span> : <span class="keyword">false</span>,</span><br><span class="line">                <span class="string">"direction"</span> : <span class="string">"backward"</span>,</span><br><span class="line">                <span class="string">"indexBounds"</span> : &#123;</span><br><span class="line">                    <span class="string">"stock"</span> : [</span><br><span class="line">                        <span class="string">"[MaxKey, MinKey]"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"keysExamined"</span> : <span class="number">10</span>,</span><br><span class="line">                <span class="string">"dupsTested"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"dupsDropped"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"seenInvalidated"</span> : <span class="number">0</span>,</span><br><span class="line">                <span class="string">"matchTested"</span> : <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>把查询条件也加上索引</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上索引</span></span><br><span class="line">db.gift.ensureIndex(&#123;item:<span class="number">1</span>,location:<span class="number">1</span>,stock:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// explain result</span></span><br><span class="line"><span class="string">"executionStats"</span> : &#123;</span><br><span class="line">    <span class="string">"executionSuccess"</span> : <span class="keyword">true</span>,</span><br><span class="line">    <span class="string">"nReturned"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"totalKeysExamined"</span> : <span class="number">6</span>,  <span class="comment">// 索引过滤没有起作用，居然比totalDocsExamined大</span></span><br><span class="line">    <span class="string">"totalDocsExamined"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">        <span class="string">"stage"</span> : <span class="string">"SORT"</span>,  <span class="comment">// 内存排序</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>经过分析：</p><blockquote><p>item 为区间查询，它作为索引的前缀字段，必然影响索引的扫描范围</p></blockquote><p>所以调整一下索引的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上索引</span></span><br><span class="line">db.gift.ensureIndex(&#123;location:<span class="number">1</span>,item:<span class="number">1</span>,stock:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="comment">// explain result</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"executionStats"</span> : &#123;</span><br><span class="line">    <span class="string">"executionSuccess"</span> : <span class="keyword">true</span>,</span><br><span class="line">    <span class="string">"nReturned"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"totalKeysExamined"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"totalDocsExamined"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">        <span class="string">"stage"</span> : <span class="string">"SORT"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析结果：</p><blockquote><p>nReturned=totalKeysExamined=totalDocsExamined</p></blockquote><p>非常完美对不对，至少说明扫描范围已经控制到了极限。</p><p>但是需要注意<code>stage=SORT</code>, 在数据量非常大的场景中，我们应该尽量消除这个因素，让排序尽量通过索引完成。</p><p>再次修改索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引</span></span><br><span class="line">db.gift.ensureIndex(&#123;location:<span class="number">1</span>,stock:<span class="number">1</span>,item:<span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// explain result</span></span><br><span class="line"><span class="string">"executionStats"</span> : &#123;</span><br><span class="line">    <span class="string">"executionSuccess"</span> : <span class="keyword">true</span>,</span><br><span class="line">    <span class="string">"nReturned"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"executionTimeMillis"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"totalKeysExamined"</span> : <span class="number">4</span>,</span><br><span class="line">    <span class="string">"totalDocsExamined"</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">"executionStages"</span> : &#123;</span><br><span class="line">        <span class="string">"stage"</span> : <span class="string">"FETCH"</span>,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>stage=FETCH</code>, 虽然totalKeysExamined&gt;totalDocsExamined,但是相对于「sort」带来的消耗，多扫描几条数据根本不值一提。</p><p>到此，索引优化的示例就结束了，从这个示例中我们可以得出一个「小原则」：</p><blockquote><p>当我们的的一个查询覆盖了「精确匹配」，「范围查询」，「排序」等3个场景时，复合索引的顺序应该是这样： 精度匹配字段, 排序字段, 范围查询字段。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码之外-sphinx</title>
      <link href="/2016/01/18/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96-sphinx/"/>
      <url>/2016/01/18/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96-sphinx/</url>
      
        <content type="html"><![CDATA[<p>使用<code>markdown</code>写了一段时间博客以后，觉得它真的是作为文字输出的不二之选，学习门槛低，编辑工具多，输出样式简单大气；在公司的内部的一些技术文档，接口文档，API文档等场景我也一直在使用<code>markdown</code>作为文档格式。</p><p>但是业内基于markdown的写作普遍认同比较松散，模板大部分倾向于<code>博客型</code>，追求视觉花样，对于要<code>文档型</code>等严肃场景没有比较好的模板支持，所以我一直在寻求这方面的模板，但一直没有满意，偶然有一天，我发现了 <a href="https://readthedocs.org/" target="_blank" rel="noopener">readthedocs</a>， 这个基本上就是严谨文档场景的完美模板呀。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码之外-sublime</title>
      <link href="/2016/01/18/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96-sublime/"/>
      <url>/2016/01/18/%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96-sublime/</url>
      
        <content type="html"><![CDATA[<p>除了笨重的IDE之外，对于文本编辑器的选择挺重要的，我对编辑器的选择有这么几个原则：</p><ul><li>轻量级而基础功能够用</li><li>功能可扩展</li><li>经得住历史考验，不会被频繁替换，徒增更换学习成本</li></ul><p><code>sublime</code> 几乎就是这几个原则的理想实现，用了大概2年了，陆陆续续给了不少惊喜，基本上是不用再考虑换其它的编辑器了。</p><p>下面则是关于sublime的一些使用介绍。(注意，本文基于MAC OS进行编写，快捷键等方式请参照官方自行切换)</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这个不用说了，直接 <a href="http://www.sublimetext.com/" target="_blank" rel="noopener">官网</a>下载吧。如果想要破解版的，自己找，百度云一堆。</p><h3 id="插件管理器"><a href="#插件管理器" class="headerlink" title="插件管理器"></a>插件管理器</h3><p>sublime之所以能做到功能可扩展，无非是因为有一套完整的插件管理机制，而且它的插件库内容之丰富，让人叹为观止。</p><p>要能安装插件，首先要做的是安装<code>插件管理器</code>,安装步骤如下：</p><ul><li><p>按 「 Ctr+` 」调用出命令行面板；</p></li><li><p>粘贴如下命令到命令行并回车：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), <span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</span><br></pre></td></tr></table></figure></li><li><p>重启sublime</p></li><li><p>如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。</p></li></ul><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><code>插件管理器</code>安装完毕以后，可以通过如下方式进行插件安装：</p><ul><li>按键 <code>Super+Shift+P</code>，调出<code>万能面板</code>；</li><li>输入 <code>install package</code></li><li>输入你要安装的包名，回车，静静等待；</li></ul><p>下面是一些我推荐的插件：</p><ul><li>All Autocomplete</li><li>Clickable URLs</li><li>MarkdownEditing</li><li>Pretty JSON</li><li>sublime-rst-completion</li><li>Theme - Soda SolarizedDark</li><li>Anaconda</li><li>SideBarEnhancements</li></ul><p>要查看已经安装了那些插件，可以在<code>万能面板</code>中输入<code>list package</code>;</p><p>注意，此处再次引出了<code>万能面板</code>的概念，它是sublime里面最重要的一个操作入口，可以在里面完成99%的管理操作；</p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p>首先说明，快捷键可以自己任意定义，为了保留平时在开发工具<code>IntellJ</code>中的习惯，我改了部分快捷键，我的快捷键配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[     </span><br><span class="line"></span><br><span class="line">// 预览MD</span><br><span class="line"> &#123; <span class="attr">"keys"</span>: [<span class="string">"alt+p"</span>], <span class="attr">"command"</span>: <span class="string">"markdown_preview"</span>, <span class="attr">"args"</span>: &#123; <span class="attr">"target"</span>: <span class="string">"browser"</span>&#125; &#125;,</span><br><span class="line"></span><br><span class="line">// 删除当前行</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"super+d"</span>], <span class="attr">"command"</span>:<span class="string">"run_macro_file"</span>, <span class="attr">"args"</span>: &#123;<span class="attr">"file"</span>:<span class="string">"Packages/Default/Delete Line.sublime-macro"</span>&#125; &#125;,</span><br><span class="line"></span><br><span class="line">// 复制选中行到行后</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"super+alt+down"</span>], <span class="attr">"command"</span>:<span class="string">"duplicate_line"</span> &#125;,</span><br><span class="line"></span><br><span class="line">// gb一次选中所有的</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"super+g"</span>],<span class="attr">"command"</span>: <span class="string">"find_all_under"</span> &#125;,</span><br><span class="line"></span><br><span class="line">// 与上行互换</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"alt+up"</span>], <span class="attr">"command"</span>:<span class="string">"swap_line_up"</span> &#125;,</span><br><span class="line">// 与下行互换</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"alt+down"</span>], <span class="attr">"command"</span>:<span class="string">"swap_line_down"</span> &#125;,</span><br><span class="line">// 提示</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"alt+/"</span>,<span class="string">"alt+/"</span>], <span class="attr">"command"</span>:<span class="string">"insert_best_completion"</span> &#125;,</span><br><span class="line"></span><br><span class="line">// 替换窗口</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"super+r"</span>], <span class="attr">"command"</span>: <span class="string">"show_panel"</span>, <span class="attr">"args"</span>: &#123;<span class="attr">"panel"</span>: <span class="string">"replace"</span>, <span class="attr">"reverse"</span>: <span class="literal">false</span>&#125; &#125;,</span><br><span class="line"></span><br><span class="line">// 从当前任意位置跳到下一行</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"shift+enter"</span>], <span class="attr">"command"</span>: <span class="string">"run_macro_file"</span>, <span class="attr">"args"</span>: &#123;<span class="attr">"file"</span>: <span class="string">"res://Packages/Default/Add Line.sublime-macro"</span>&#125; &#125;,</span><br><span class="line"></span><br><span class="line">//跳转到</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"super+1"</span>], <span class="attr">"command"</span>: <span class="string">"show_overlay"</span>, <span class="attr">"args"</span>: &#123;<span class="attr">"overlay"</span>: <span class="string">"goto"</span>, <span class="attr">"text"</span>: <span class="string">":"</span>&#125; &#125;,</span><br><span class="line">&#123; <span class="attr">"keys"</span>: [<span class="string">"super+2"</span>], <span class="attr">"command"</span>: <span class="string">"show_overlay"</span>, <span class="attr">"args"</span>: &#123;<span class="attr">"overlay"</span>: <span class="string">"goto"</span>, <span class="attr">"text"</span>: <span class="string">"@"</span>&#125; &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>想要知道具体怎么去配置这些快捷键，建议抽个时间过一遍<a href="http://docs.sublimetext.info/en/latest/index.html" target="_blank" rel="noopener">官方文档</a>；</p><p>sublime的快捷键太灵活，一时半会很难消化，建议分类整理；</p><h4 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h4><ul><li>打开万能面板</li></ul><blockquote><p>Super+Shift+P</p></blockquote><p>在<code>万能面板</code>中可以做很多有用的事情，常见的有：</p><pre><code>+ 包管理(install, remove, list)+ 设置文件格式（set syntax）+ 常见配置修改(key binding,preferences)+ 格式化(json format, html format...)+ 文件管理（remove,rename,copy name, copy path....）</code></pre><ul><li>跳转到任意文件</li></ul><blockquote><p>Super + P</p></blockquote><ul><li>文件内跳转到指定方法，变量定义</li></ul><blockquote><p>Super +P ; 输入 @「方法名」</p></blockquote><ul><li>文件内跳转到行，</li></ul><blockquote><p>Super +P ; 输入 ：「行号」</p></blockquote><ul><li>调出控制台</li></ul><blockquote><p>Ctrl + `</p></blockquote><h4 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h4><ul><li>删除当前行</li></ul><blockquote><p>Super +D </p></blockquote><ul><li>跳转到下一行</li></ul><blockquote><p> Shift + Enter</p></blockquote><ul><li>移动光标到行首</li></ul><blockquote><p> Ctrl + A 或者 Command + Left</p></blockquote><ul><li>移动到光标到行末尾</li></ul><blockquote><p> Ctrl + E 或者 Command + Right</p></blockquote><ul><li>移动到下一个单词</li></ul><blockquote><p>Ctrl + W</p></blockquote><ul><li>移动到上一单词</li></ul><blockquote><p>Ctrl + B</p></blockquote><ul><li>列编辑模式</li></ul><blockquote><p>Alt + 鼠标左键</p></blockquote><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><ul><li>选择相同的单词</li></ul><blockquote><p>Super + G</p></blockquote><ul><li>选择一行</li></ul><blockquote><p>Super+Shift+Right</p></blockquote><ul><li>选择一个单词</li></ul><blockquote><p> Ctrl+Shift+Right</p></blockquote><ul><li>选择{}/()中的内容</li></ul><blockquote><p>Ctrl+Shift+M</p></blockquote><ul><li>在{}/()起始位置切换光标</li></ul><blockquote><p> Ctrl +M</p></blockquote><h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><ul><li>查找</li></ul><blockquote><p>Super + F</p></blockquote><ul><li>替换</li></ul><blockquote><p>Super + R</p></blockquote><p>sublime的玩法可以够你玩一整年，基本操作的话，把这篇文章里面的都消化掉就差不多了，毕竟只是一个工具，要在实际操作中积累经验。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty实践分享</title>
      <link href="/2015/09/19/Netty%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB/"/>
      <url>/2015/09/19/Netty%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>好久没有更新博客了，前段时间给团队小伙伴做了一个关于netty的分享，因为做的是Keynote，直接把链接放这里吧。</p><p><a href="http://7arnte.com1.z0.glb.clouddn.com/Netty实践分享.pdf" target="_blank" rel="noopener">阅读地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于websocket的一点认识</title>
      <link href="/2015/05/24/%E5%85%B3%E4%BA%8Ewebsocket%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%A4%E8%AF%86/"/>
      <url>/2015/05/24/%E5%85%B3%E4%BA%8Ewebsocket%E7%9A%84%E4%B8%80%E7%82%B9%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><code>WebSocket</code>的概念伴随着<code>html5</code>的出现，其实已经出来很多年了，但是浏览器的支持实现，服务端的支持实现各不相同，Java范畴内也是最近才统一了API实现标准，我匆匆看了一下Oracle提供的实现api，还是比较简洁的，这个<a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html" target="_blank" rel="noopener">jsr356 规范</a>一定要看看。</p><p>说到<code>WebSocket</code>协议,必须先说说<code>http</code>协议，我们都知道，<code>http</code>协议最显著的特征就是其通信方式为经典的<code>请求/应答</code>模式，这种模式存在这么几个问题：</p><ul><li><p>浪费资源</p><p>  每一次请求都要重新建立一个HTTP连接（底层是TCP），非常浪费资源，如果碰上https等认证过程，每一次请求的验证过程更是缓慢。</p></li></ul><ul><li><p>服务端很被动</p><p>  其实不是<code>很</code>，是<code>只能</code>。 服务端只能被动响应客户端的请求，不能主动推送信息给客户端。在需要通知的场景，如聊天室，游戏，客户端应用需要不断地轮询服务器，虽然后面发展出了所谓的<code>comet</code>技术,使用所谓的<code>伪长连接</code>，相对于<code>轮询</code>提升了一些性能，但是还是没有从本质上解决问题。</p></li></ul><p><code>WebSocket</code>的出现就是为了解决这些问题，它和<code>http</code>协议的关系很暧昧，本质上来说，WebSocket是不限于HTTP协议的，但是由于现存大量的HTTP基础设施，代理，过滤，身份认证等等，WebSocket借用HTTP和HTTPS的端口。由于使用HTTP的端口，因此TCP连接建立后的握手消息是基于HTTP的，由服务器判断这是一个HTTP协议，还是WebSocket协议。WebSocket连接除了建立和关闭时的握手，数据传输和HTTP没丁点关系了。</p><p>在阅读完上文提到的<code>jsr356规范</code>以后，我这里做了一个<code>web聊天室</code>的demo，看下代码吧，非常简洁。</p><p>首先是服务端,涉及到了这么几个逻辑：</p><ul><li>websocket服务的定义</li><li>各种事件的监听</li><li>消息编码/消息解码</li></ul><h4 id="websocket服务的定义"><a href="#websocket服务的定义" class="headerlink" title="websocket服务的定义"></a>websocket服务的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了服务的访问，消息编解码逻辑类</span></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(value = <span class="string">"/chat/&#123;username&#125;"</span>, encoders = MsgEncoder.class, decoders = MsgDecoder.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务端各种事件的监听"><a href="#服务端各种事件的监听" class="headerlink" title="服务端各种事件的监听"></a>服务端各种事件的监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//  建立连接</span></span><br><span class="line"><span class="meta">@OnOpen</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Session session, @PathParam(<span class="string">"username"</span>)</span> String username) </span>&#123;</span><br><span class="line">     SESSIONS.add(session);</span><br><span class="line">     DBObject data = <span class="keyword">new</span> BasicDBObject(<span class="string">"username"</span>, username);</span><br><span class="line">     <span class="comment">// 有人上线，向所有的人广播通知</span></span><br><span class="line">     Msg msg = <span class="keyword">new</span> Msg(Msg.type_0_online, data);</span><br><span class="line">     sendMsg(msg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 关闭连接</span></span><br><span class="line"> <span class="meta">@OnClose</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Session session, @PathParam(<span class="string">"username"</span>)</span> String username) </span>&#123;</span><br><span class="line">     SESSIONS.remove(session);</span><br><span class="line">     DBObject data = <span class="keyword">new</span> BasicDBObject(<span class="string">"username"</span>, username);</span><br><span class="line">     <span class="comment">// 有人下线，向所有的人广播通知</span></span><br><span class="line">     Msg msg = <span class="keyword">new</span> Msg(Msg.type_1_offline, data);</span><br><span class="line">     sendMsg(msg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送消息</span></span><br><span class="line"> <span class="meta">@OnMessage</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">message</span><span class="params">(Session session, Msg msg, @PathParam(<span class="string">"username"</span>)</span> String username) </span>&#123;</span><br><span class="line">     <span class="comment">// 将消息发送给聊天室的在线用户</span></span><br><span class="line">     sendMsg(msg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 广播消息的逻辑</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (Session session : SESSIONS) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 此处直接发送Bean消息对象，消息编码器会将其编码为JSON格式，再传递给客户端</span></span><br><span class="line">             session.getBasicRemote().sendObject(msg);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (EncodeException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>再来看看客户端的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startWebSocket</span>(<span class="params">url, onopen, onmessage, onclose</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ws = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">'WebSocket'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">        ws = <span class="keyword">new</span> WebSocket(url);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'MozWebSocket'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">        ws = <span class="keyword">new</span> MozWebSocket(url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">'Websocket is not supportted '</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ws.onopen = onopen;</span><br><span class="line">    ws.onclose = onclose;</span><br><span class="line">    ws.onmessage = onmessage;</span><br><span class="line">    <span class="built_in">window</span>.ws = ws;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最核心的逻辑都在这个方法里面了，是不是非常简单，下面看看效果图吧。<br><img src="http://i1.tietuku.com/8b51cc223dde3efb.gif" alt></p><p>最后，附上<a href="https://gitcafe.com/yee/mychat.git" target="_blank" rel="noopener">源码地址</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> websocket </tag>
            
            <tag> java-core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-passes-by-reference-Or-by-value</title>
      <link href="/2015/03/22/Java-passes-by-reference-Or-by-value/"/>
      <url>/2015/03/22/Java-passes-by-reference-Or-by-value/</url>
      
        <content type="html"><![CDATA[<p>This is a classic question of Java. Many similar questions have been asked on stackoverflow, and there are a lot of incorrect/incomplete answers. The question is simple if you don’t think too much. But it could be very confusing, if you give more thought to it. </p><h3 id="1-A-code-fragment-that-is-interesting-amp-confusing"><a href="#1-A-code-fragment-that-is-interesting-amp-confusing" class="headerlink" title="1. A code fragment that is interesting &amp; confusing"></a>1. A code fragment that is interesting &amp; confusing</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String x = new String(&quot;ab&quot;);</span><br><span class="line">    change(x);</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void change(String x) &#123;</span><br><span class="line">    x = &quot;cd&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It prints “ab”. </p><h3 id="2-What-the-code-really-does"><a href="#2-What-the-code-really-does" class="headerlink" title="2.What the code really does?"></a>2.What the code really does?</h3><p>When the string “ab” is created, Java allocates the amount of memory required to store the string object. Then, the object is assigned to variable x, the variable is actually assigned a reference to the object. This reference is the address of the memory location where the object is stored.</p><p>The variable x contains a reference to the string object. x is not a reference itself! It is a variable that stores a reference(memory address).</p><p>Java is pass-by-value ONLY. When x is passed to the change() method, a copy of value of x (a reference) is passed. The method change() creates another object “cd” and it has a different reference. It is the variable x that changes its reference(to “cd”), not the reference itself.</p><p>The following diagram shows what it really does.<br><img src="http://i3.tietuku.com/b4b342ceca152207.jpg" alt></p><h3 id="3-conclusion"><a href="#3-conclusion" class="headerlink" title="3. conclusion"></a>3. conclusion</h3><blockquote><p>Java is always pass-by-value. Primitive data types and object reference are just values. </p></blockquote><h3 id="4-one-more-question"><a href="#4-one-more-question" class="headerlink" title="4. one more question"></a>4. one more question</h3><p>why the member value of the object can get changed?</p><p>here is the code :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Apple &#123;</span><br><span class="line">    public String color=&quot;red&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Apple apple = new Apple();</span><br><span class="line">        System.out.println(apple.color);</span><br><span class="line"> </span><br><span class="line">        changeApple(apple);</span><br><span class="line">        System.out.println(apple.color);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void changeApple(Apple apple)&#123;</span><br><span class="line">        apple.color = &quot;green&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since the orignal and copied reference refer the same object, the member value gets changed.<br><img src="http://i3.tietuku.com/9e9069348b30aaef.jpg" alt></p><p>a same phenomenon will be found in <code>collection situation</code>. </p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A-story-about-strategy-pattern</title>
      <link href="/2015/03/21/A-story-about-strategy-pattern/"/>
      <url>/2015/03/21/A-story-about-strategy-pattern/</url>
      
        <content type="html"><![CDATA[<p>In a long time period, <code>Strategy pattern</code> is too abstract to understand  for me. i can’t get the concept of strategy, and i can’t handler the situation for it. but i am totally free now, becouse i read a story about it :</p><blockquote><p>Suppose Mike sometimes speeds when driving, but he doesn’t always do that. He may be stopped by a police officer. It’s possible that the police is very nice, who would let him go without any ticket or with a simple warning. (Let call this kind of police “NicePolice”.) Also it’s possible that he may be caught by a hard police and gets a ticket. (Let’s call this kind of police “HardPolice”.) He doesn’t know what kind of police would stop him, until he actually gets caught, that is, run-time. </p></blockquote><p>the story can be transformed into a <code>Class Diagram</code> like this:<br><img src="http://i2.tietuku.com/0b38597bba4cb809.jpg" alt></p><p>this is a perfect story for me! i completly understand the <code>strategy</code> is the key point, it is the abstraction of different algorithm.</p><p>now i can get a list of this situation:</p><ul><li>spring mvc’s view template</li><li>Arrays.sort()</li></ul><h3 id="spring-mvc’s-view-template"><a href="#spring-mvc’s-view-template" class="headerlink" title="spring mvc’s view template"></a>spring mvc’s view template</h3><p>in spring mvc, there are 3 view templates(JSP,velocity,freemark) to choose. you can choose any of them , all you need to do is configuire it in the applicationContext.xml. actually, the idea of  view template is the abstract of  strategy, and the specific view is the real algorithm.</p><h3 id="Arrays-sort"><a href="#Arrays-sort" class="headerlink" title="Arrays.sort()"></a>Arrays.sort()</h3><p>when we talk about <code>sort</code>, we can’t avoid the <code>compare</code>. there are 2 ways to do this:</p><ul><li>comparetor</li><li>Comparable<br>back into <code>Arrays.sort()</code>, <code>Comparable</code> is been used.and in this situation, <code>Comparable</code> is the absolute strategy, the real <code>comparable implement</code> is the algorithm, you can change the <code>implement</code> to change the <code>strategy</code>.</li></ul><p>anyway, i love the story. it help me to understand, hope that help you too.</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>What-exactly-is-null-in-Java</title>
      <link href="/2015/03/21/What-exactly-is-null-in-Java/"/>
      <url>/2015/03/21/What-exactly-is-null-in-Java/</url>
      
        <content type="html"><![CDATA[<p>I read a great article about <code>null in java</code>  today. now i reprint it here. if you want to make a deep understanding about <code>null</code>, I recommand you read it.</p><p>the bellow is the article:</p><hr><p>Let’s start from the following statement:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String x = null;</span><br></pre></td></tr></table></figure><h3 id="1-What-exactly-does-this-statement-do"><a href="#1-What-exactly-does-this-statement-do" class="headerlink" title="1. What exactly does this statement do?"></a>1. What exactly does this statement do?</h3><p>Recall what is a variable and what is a value. A common metaphor is that a variable is similar to a box. Just as you can use a box to store something, you can use a variable to store a value. When declaring a variable, we need to set its type.</p><p>There are two major categories of types in Java: primitive and reference. Variables declared of a primitive type store values; variables declared of a reference type store references. In this case, the initialization statement declares a variables “x”. “x” stores String reference. It is null here.</p><p>The following visualization gives a better sense about this concept.<br><img src="http://i2.tietuku.com/af0575c8f8f96916.png" alt></p><p>If x = “abc”, it looks like the following:<br><img src="http://i2.tietuku.com/d8418d4ed50b6664.png" alt></p><h3 id="2-What-exactly-is-null-in-memory"><a href="#2-What-exactly-is-null-in-memory" class="headerlink" title="2. What exactly is null in memory?"></a>2. What exactly is null in memory?</h3><p>What exactly is null in memory? Or What is the null value in Java?</p><p>First of all, null is not a valid object instance, so there is no memory allocated for it. It is simply a value that indicates that the object reference is not currently referring to an object. </p><p>From <a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.4" target="_blank" rel="noopener">JVM Specifications</a>:</p><blockquote><p>The Java Virtual Machine specification does not mandate a concrete value encoding null.</p></blockquote><p>I would assume it is all zeros of something similar like itis on other C like languages. </p><h3 id="3-What-exactly-is-x-in-memory"><a href="#3-What-exactly-is-x-in-memory" class="headerlink" title="3. What exactly is x in memory?"></a>3. What exactly is x in memory?</h3><p>Now we know what null is. And we know a variable is a storage location and an associated symbolic name (an identifier) which contains some value. Where exactly x is in memory?</p><p>From <a href="http://www.programcreek.com/2013/04/jvm-run-time-data-areas/" target="_blank" rel="noopener">the diagram of JVM run-time data areas</a>, we know that since each method has a private stack frame within the thread’s steak, the local variable are located on that frame. </p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSO-prictice-in-web</title>
      <link href="/2015/03/14/SSO-prictice-in-webmd/"/>
      <url>/2015/03/14/SSO-prictice-in-webmd/</url>
      
        <content type="html"><![CDATA[<p>A few weeks ago, our team meet a problem that how multi-web-app share the  information of user’s sign state. here is the situation:</p><blockquote><p>there are 3 web systems, user can login in them with the same account, when a user login in the first system, he can access the the second or the third without loginning agian.</p></blockquote><p>the key problem laies in how to share the loginning state. <code>SSO</code>  is exactly designed for this situation. <code>SSO</code> is the short name for <code>Single Sign On</code>, which means that user need to sign on only once, and he can access any other relative site. it is the most popular solution for integrating multi-site. for example, when you access <code>sina.com.cn</code> with your account, you can access <code>weibo.com</code>,<code>news.sina.com.cn</code> and so on, you need to input your account only once. </p><p>anyway, the most important part we want to figure out is   <code>how SSO works</code>, my understanding is as follows: </p><blockquote><p>There must exist a <code>SSO</code> service for all site in the whole system, the service privid <code>common  entry for loginning</code>,<code>account api</code>,<code>the management of user&#39;s online state</code> .</p></blockquote><h3 id="1-common-entry-for-loginning"><a href="#1-common-entry-for-loginning" class="headerlink" title="1.common entry for loginning"></a>1.common entry for loginning</h3><p>actually, the point for common laies in <code>login action</code>, you can design diffent loginning’page for diffent site, but the logic for loginning action must be the same, usually, <code>login action</code> contains these thing:</p><ul><li>validate the account </li><li>allocate account’s token , store the token into cookies</li><li>if the valid account’s token exists in the cookies, there is no need to login , redirect to the site.</li></ul><p>hear is my code for entry :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;index&quot;)</span><br><span class="line">   public ModelAndView index(</span><br><span class="line">           @RequestParam(&quot;appId&quot;) String appid, // site id</span><br><span class="line">           @RequestParam(&quot;to&quot;) String to, // site callback url</span><br><span class="line">           HttpServletRequest req, HttpServletResponse res, ModelMap data) throws Exception &#123;</span><br><span class="line">       if (!ObjectId.isValid(appid)) &#123;</span><br><span class="line">           throw new Exception(&quot;error appId&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       ObjectId appId = new ObjectId(appid);</span><br><span class="line">       DBCollection coll = portalMongo.getAppCollection();</span><br><span class="line">       DBObject app = coll.findOne(new BasicDBObject(&quot;_id&quot;, appId));</span><br><span class="line">       if (app == null) &#123;</span><br><span class="line">           throw new Exception(&quot;error appId, app doesn&apos;t exists!&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // if the valid account&apos;s token exists in the cookies, there is no need to login , redirect to the site.</span><br><span class="line"></span><br><span class="line">       String token = CookieUtils.findACookieToken(req);</span><br><span class="line">       if (token != null &amp;&amp; verifyTokenValid(token)) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               String url = buildRedirectUrl(to, token);</span><br><span class="line">               res.sendRedirect(url);</span><br><span class="line">               return null;</span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       data.put(&quot;app&quot;, app);</span><br><span class="line">       data.put(&quot;to&quot;, to);</span><br><span class="line"></span><br><span class="line">       return new ModelAndView(&quot;sso/index&quot;, &quot;data&quot;, data);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>here is the code for <code>login action</code> :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;doLogin&quot;, method = RequestMethod.POST)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public AjaxData doLogin(</span><br><span class="line">            @RequestParam(&quot;loginname&quot;) String loginname,</span><br><span class="line">            @RequestParam(&quot;password&quot;) String password,</span><br><span class="line">            @RequestParam(&quot;to&quot;) String to,</span><br><span class="line">            @RequestParam(&quot;appId&quot;) ObjectId appId,</span><br><span class="line">            HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">        AjaxData data = new AjaxData();</span><br><span class="line">        </span><br><span class="line">        DBCollection collAdminUser = weiposMongo.getAdminUserCollection();</span><br><span class="line">        DBObject admin = collAdminUser.findOne(new BasicDBObject(&quot;loginname&quot;, loginname));</span><br><span class="line">        if (admin == null) &#123;</span><br><span class="line">            data.info = &quot;用户不存在&quot;;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line">        String passMd5 = MD5.getMD5(password.getBytes());</span><br><span class="line">        if (!passMd5.equals((String) admin.get(&quot;password&quot;))) &#123;</span><br><span class="line">            data.info = &quot;密码不正确&quot;;</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DBObject log = new BasicDBObject();</span><br><span class="line">        log.put(&quot;to&quot;, to);</span><br><span class="line">        log.put(&quot;loginAppId&quot;, appId);</span><br><span class="line">        log.put(&quot;loginTime&quot;, Calendar.getInstance().getTime());</span><br><span class="line">        log.put(&quot;status&quot;, 1);</span><br><span class="line">        log.put(&quot;accountId&quot;, admin.get(&quot;_id&quot;));</span><br><span class="line">        DBCollection collSSOLog = portalMongo.getSSOLogCollection();</span><br><span class="line">        collSSOLog.insert(log);</span><br><span class="line"></span><br><span class="line">        // 写Cookie</span><br><span class="line">        String token = log.get(&quot;_id&quot;).toString();</span><br><span class="line">        CookieUtils.writeACookieToken(resp, token);</span><br><span class="line">        HashMap&lt;String, Object&gt; ret = new HashMap&lt;String, Object&gt;();</span><br><span class="line">        ret.put(&quot;token&quot;, token);</span><br><span class="line">        ret.put(&quot;to&quot;, to);</span><br><span class="line"></span><br><span class="line">        String url = buildRedirectUrl(to, token);</span><br><span class="line">        ret.put(&quot;url&quot;, url);</span><br><span class="line"></span><br><span class="line">        data.status = 1;</span><br><span class="line">        data.info = &quot;登录成功！&quot;;</span><br><span class="line">        data.data = ret;</span><br><span class="line"></span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-account-api"><a href="#2-account-api" class="headerlink" title="2. account api"></a>2. account api</h3><p>when an user signs in from the <code>common login entry</code>, which means the  <code>SSO service</code> allocated a <code>account token</code> to a site, and restored the token into the cookies. <code>account api</code> privid the the api to get account’s data by token. <code>the account token</code> is the unique key to comfirm the account. <code>SSO service</code> can handle all request for any site in the system by the <code>account api</code>, and the sites can share account’s data  by this api.</p><p>here is the code:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;getUserByToken&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public AjaxData getUserByToken(@RequestParam(&quot;token&quot;) String token, HttpServletRequest req, HttpServletResponse res, ModelMap data) &#123;</span><br><span class="line"></span><br><span class="line">    AjaxData ad = new AjaxData();</span><br><span class="line">    if (!ObjectId.isValid(token)) &#123;</span><br><span class="line">        ad.info = &quot;Token无效&quot;;</span><br><span class="line">        return ad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DBCollection collSSOLog = portalMongo.getSSOLogCollection();</span><br><span class="line">    DBObject log = collSSOLog.findOne(new BasicDBObject(&quot;_id&quot;, new ObjectId(token)));</span><br><span class="line">    if (log == null) &#123;</span><br><span class="line">        ad.info = &quot;Token无效&quot;;</span><br><span class="line">        return ad;</span><br><span class="line">    &#125;</span><br><span class="line">    int status = (Integer) log.get(&quot;status&quot;);</span><br><span class="line">    if (status != 1) &#123;</span><br><span class="line">        ad.info = &quot;Token已失效&quot;;</span><br><span class="line">        return ad;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;String, Object&gt; ret = new HashMap&lt;String, Object&gt;();</span><br><span class="line">    ret.put(&quot;token&quot;, token);</span><br><span class="line"></span><br><span class="line">    ObjectId accountId = (ObjectId) log.get(&quot;accountId&quot;);</span><br><span class="line">    DBCollection collAdminUser = weiposMongo.getAdminUserCollection();</span><br><span class="line">    DBObject admin = collAdminUser.findOne(new BasicDBObject(&quot;_id&quot;, accountId));</span><br><span class="line">    if (admin == null) &#123;</span><br><span class="line">        ad.info = &quot;Token数据异常&quot;;</span><br><span class="line">        return ad;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.put(&quot;accountId&quot;, admin.get(&quot;_id&quot;).toString());// 管理员ID</span><br><span class="line">    ret.put(&quot;name&quot;, admin.get(&quot;name&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ad.data = ret;</span><br><span class="line">    ad.status = 1;</span><br><span class="line">    ad.info = &quot;登录成功！&quot;;</span><br><span class="line">    return ad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-the-management-of-user’s-online-state"><a href="#3-the-management-of-user’s-online-state" class="headerlink" title="3. the management of user’s online state"></a>3. the management of user’s online state</h3><p><code>online state</code> is the most important part in the whole things. let’s clean these things up.</p><ul><li>when an user is loginning, the <code>login action</code> handle the submit.</li><li><code>login action</code> will allocate a token, and restored it to the browers’ cookies by response object.</li><li>any other request from browers will find the token from cookies, and then it can been thought  online by <code>SSO service</code>, <code>SSO service</code> will redirect  to the <code>callback url</code> .</li><li>when any site sign out, the <code>SSO service</code> will mark the token ,and the token will be expired.</li></ul><p>as you see, it’s not that complicated, i give a demo show about this.<br>i preclaim two things:</p><ul><li><p>sso service url</p><blockquote><p>http:192.168.1.119:8080/portal/</p></blockquote></li><li><p>site url</p><blockquote><p>http:192.168.1.119:8080/pdemo</p></blockquote></li></ul><p>step 1. when i tap <code>site url</code>, the browers will redirect to the loginning page in the <code>sso service</code>.<img src="http://i3.tietuku.com/a7227465ccddf0c1.gif" alt></p><p>step 2. when i input the account to sign in the <code>sso service</code>, the browers will take me back to the site in the step 1.<br><img src="http://i3.tietuku.com/2fff82ca3c22bcfd.gif" alt></p><p>so , except for the site demo code, the <code>SSO service</code> is completed intruduced , hope that help you.</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> sso </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb分片</title>
      <link href="/2014/08/09/mongodb%E5%88%86%E7%89%87/"/>
      <url>/2014/08/09/mongodb%E5%88%86%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h3 id="什么叫做分片"><a href="#什么叫做分片" class="headerlink" title="什么叫做分片"></a>什么叫做分片</h3><blockquote><p>Sharding is the process of storing data records across multiple machines and is MongoDB’s approach to meeting the demands of data growth. As the size of the data increases, a single machine may not be sufficient to store the data nor provide an acceptable read and write throughput. Sharding solves the problem with horizontal scaling. With sharding, you add more machines to support data growth and the demands of read and write operations.</p></blockquote><p>mongodb的官方文档上面对分片做了一些简单的说明，基本上可以提炼出这么几个关键字：</p><ul><li>多机器存储数据</li><li>更高的的读写性能</li><li>水平扩展</li></ul><hr><p>这这里就不再过多的讨论概念，优缺点等问题，本文定位于快速搭建一个简单完整的分片集群环境。</p><p>mongodb 的Shard机制需要这么几个对象：</p><ul><li>分片数据服务器</li><li>配置服务器</li><li>路由服务器</li></ul><p>下面开始进行搭建工作。</p><h3 id="1-准备服务器配置"><a href="#1-准备服务器配置" class="headerlink" title="1. 准备服务器配置"></a>1. 准备服务器配置</h3><p>我们的分片测试服务器全部放在本机，结构是这样的：</p><p>|  服务器 | port |<br>| :——:| :——-:|:——-: |<br>| shard server s0|20001|<br>| shard server s1|20002|<br>| config server  |30000|<br>| route server   |40000|</p><p>因为启动mongod实例需要大量参数，我建议全部写到配置文件里面，然后统一通过<code>-f file.conf</code>参数启动。<br>我建了一个文件夹<code>/data/mongo-shard/conf</code>,针对每个服务器分别写了一份配置文件：<br><img src="http://ww3.sinaimg.cn/large/a42ec2f7gw1ej65n7sjk7j2056031mx2.jpg" alt="Alt text"><br>分别来看看：<br><strong>分片服务器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 1. 分片服务器 s0.conf</span><br><span class="line">dbpath = /data/mongo-shard/data/shard-s0</span><br><span class="line">port=20000</span><br><span class="line"></span><br><span class="line">logpath =/data/mongo-shard/log/s0.log</span><br><span class="line">logappend = true</span><br><span class="line"></span><br><span class="line">fork = true</span><br><span class="line">rest = true</span><br><span class="line"></span><br><span class="line">shardsvr = true</span><br><span class="line">directoryperdb = true</span><br><span class="line"></span><br><span class="line">//2. 分片服务器  s1.conf</span><br><span class="line">dbpath = /data/mongo-shard/data/shard-s1</span><br><span class="line">port=20001</span><br><span class="line"></span><br><span class="line">logpath =/data/mongo-shard/log/s1.log</span><br><span class="line">logappend = true</span><br><span class="line"></span><br><span class="line">fork = true</span><br><span class="line">rest = true</span><br><span class="line"></span><br><span class="line">shardsvr = true</span><br><span class="line">directoryperdb = true</span><br><span class="line"></span><br><span class="line">// 3. 配置服务器 config.conf</span><br><span class="line">dbpath = /data/mongo-shard/data/config</span><br><span class="line">port=30000</span><br><span class="line"></span><br><span class="line">logpath =/data/mongo-shard/log/config.log</span><br><span class="line">logappend = true</span><br><span class="line"></span><br><span class="line">fork = true</span><br><span class="line">rest = true</span><br><span class="line"></span><br><span class="line">configsvr = true</span><br><span class="line">directoryperdb = true</span><br><span class="line"></span><br><span class="line">// 4. 路由服务器 route.conf</span><br><span class="line">configdb = 127.0.0.1:30000  ##路由监听的配置服务器</span><br><span class="line">port=40000</span><br><span class="line"></span><br><span class="line">logpath =/data/mongo-shard/log/route.log</span><br><span class="line">logappend = true</span><br><span class="line"></span><br><span class="line">fork = true</span><br><span class="line">chunkSize = 1 ##分片大小为1M</span><br></pre></td></tr></table></figure><h3 id="2-启动服务器"><a href="#2-启动服务器" class="headerlink" title="2. 启动服务器"></a>2. 启动服务器</h3><p>分别将分片服务器，配置服务器，路由服务器一一启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//分片服务器</span><br><span class="line">mongod -f /data/mongo-shard/conf/s0.conf;</span><br><span class="line">mongod -f /data/mongo-shard/conf/s1.conf</span><br><span class="line"></span><br><span class="line">//配置服务器</span><br><span class="line">mongod -f /data/mongo-shard/conf/config.conf;</span><br><span class="line"></span><br><span class="line">//路由服务器</span><br><span class="line">mongos -f /data/mongo-shard/conf/route.conf</span><br></pre></td></tr></table></figure><p>检查一下是否都正常：<br><img src="http://ww3.sinaimg.cn/large/a42ec2f7gw1ej65nn8u8pj20o904et9o.jpg" alt="Alt text"><br>启动没有问题，可以进行后续操作了。</p><h3 id="3-进行分片配置"><a href="#3-进行分片配置" class="headerlink" title="3. 进行分片配置"></a>3. 进行分片配置</h3><h4 id="3-1-首先，连接到路由服务器上面的admin库"><a href="#3-1-首先，连接到路由服务器上面的admin库" class="headerlink" title="3.1 首先，连接到路由服务器上面的admin库"></a>3.1 首先，连接到路由服务器上面的admin库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo admin -port 40000</span><br></pre></td></tr></table></figure><h4 id="3-2-分片配置"><a href="#3-2-分片配置" class="headerlink" title="3.2 分片配置"></a>3.2 分片配置</h4><p>执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123;addshard:&quot;127.0.0.1:20000&quot;&#125;);</span><br><span class="line">db.runCommand(&#123;addshard:&quot;127.0.0.1:20001&quot;&#125;);</span><br></pre></td></tr></table></figure><p>如果一切正常，shell将返回：<br><img src="http://ww2.sinaimg.cn/large/a42ec2f7gw1ej65o148whj20gi04z0th.jpg" alt="Alt text"><br>到此，分片配置已经完成。</p><h3 id="3-3-对库表进行分片"><a href="#3-3-对库表进行分片" class="headerlink" title="3.3 对库表进行分片"></a>3.3 对库表进行分片</h3><p>分片最终还是要作用在具体的库表上，现在我们对<code>test.user</code>进行分片操作，此时<code>user</code>还不存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// test数据库启用分片</span><br><span class="line">db.runCommand(&#123;enablesharding:&quot;test&quot;&#125;);</span><br><span class="line"></span><br><span class="line">// 对user进行分片，并制定分片的Key为 _id</span><br><span class="line">db.runCommand(&#123;shardcollection:&quot;test.user&quot;,key:&#123;_id:1&#125;&#125;);</span><br></pre></td></tr></table></figure><p>此时还看不到任何现象，我们可以往<code>test.user</code>中插入一些数据，看看分片情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">use test;</span><br><span class="line"></span><br><span class="line">for(var i=0;i&lt;100000;i++)&#123;</span><br><span class="line">    var sex = i%2;</span><br><span class="line">    var age = i / 100 ;</span><br><span class="line">    var u = &#123;</span><br><span class="line">               &quot;name&quot;:&quot;name_&quot;+i,</span><br><span class="line">               &quot;sex&quot;:sex,&quot;age&quot;:age</span><br><span class="line">            &#125;;</span><br><span class="line">    db.user.insert(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程有些慢，一方面是因为数据来比较大，另一方面是因为插入的同时也在进行分片操作。</p><p>执行完毕以后，可以验证分片是否运行了。<br>首先看看<code>user</code>的当前情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.stats();</span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/a42ec2f7gw1ej65olpkq4j20dn0bsaav.jpg" alt="Alt text"><br><img src="http://ww2.sinaimg.cn/large/a42ec2f7gw1ej65ozy35cj20eo0hiabc.jpg" alt="Alt text"></p><p>可以看到<code>user</code>确实已经分片了，数据分布在两个分片服务器上面。</p><p>刚刚提到<code>user</code>是先分片后插入数据，其实对于已经存在数据的Collection进行分片操作也是一样的效果，只要执行<code>shardcollection</code>命令，mongodb会自动把数据搬移到不同的分片上。</p><h3 id="4-分片的运维"><a href="#4-分片的运维" class="headerlink" title="4. 分片的运维"></a>4. 分片的运维</h3><p>分片的维护工作也是很重要的一部分，现在看看这些常用的命令。</p><h4 id="4-1-查看所有分片服务器"><a href="#4-1-查看所有分片服务器" class="headerlink" title="4.1 查看所有分片服务器"></a>4.1 查看所有分片服务器</h4><blockquote><p>db.runCommand({listshards:1});<br><img src="http://ww2.sinaimg.cn/large/a42ec2f7gw1ej65penw3kj20j609oaah.jpg" alt="Alt text"></p></blockquote><h4 id="4-2-查看分片信息"><a href="#4-2-查看分片信息" class="headerlink" title="4.2 查看分片信息"></a>4.2 查看分片信息</h4><blockquote><p>printShardingStats();<br><img src="http://ww3.sinaimg.cn/large/a42ec2f7gw1ej65pvfsioj20rr0hgwhe.jpg" alt="Alt text"></p></blockquote><h4 id="4-3-判断当前连接环境是否是Sharding"><a href="#4-3-判断当前连接环境是否是Sharding" class="headerlink" title="4.3  判断当前连接环境是否是Sharding"></a>4.3  判断当前连接环境是否是Sharding</h4><blockquote><p>db.runCommand({isdbgrid:1});<br><img src="http://ww4.sinaimg.cn/large/a42ec2f7gw1ej65qn3icdj20le01n3ym.jpg" alt="Alt text"></p></blockquote><h4 id="4-4-新增sharding节点"><a href="#4-4-新增sharding节点" class="headerlink" title="4.4 新增sharding节点"></a>4.4 新增sharding节点</h4><blockquote><p>db.runCommand({addshard:”localhost:20003”});</p></blockquote><h4 id="4-5-删除sharding节点"><a href="#4-5-删除sharding节点" class="headerlink" title="4.5 删除sharding节点"></a>4.5 删除sharding节点</h4><blockquote><p>db.runCommand({removeshard:”localhost:20003”});</p></blockquote><h3 id="5-后续"><a href="#5-后续" class="headerlink" title="5 后续"></a>5 后续</h3><p>现在的生产环境中是不会使用这么简单的分片架构的，一般是会把<code>分片服务器</code>这部分做成<code>复制集</code>，只要就比较好的保证数据的完整性了。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb复制集</title>
      <link href="/2014/08/09/Mongodb%E5%A4%8D%E5%88%B6%E9%9B%86/"/>
      <url>/2014/08/09/Mongodb%E5%A4%8D%E5%88%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>复制机制一直是数据库<code>高可用性</code>设计的重要实现手段。复制机制的优点有：</p><ul><li>主从服务器读写分离，降低主服务器的访问压力</li><li>备份工作放在从服务器，避免备份操作导致主服务器被锁</li><li>当主服务器出现故障，可以快速切换到从服务器，减少宕机时间。</li></ul><p>mongodb提供了两种复制机制:</p><ul><li>主从复制（官方已不推荐）</li><li>复制集</li></ul><p>接下来，我们尝试从无到有建立一个复制集，并参与到建立以后的读写分离，主从切换，故障转移，增减节点等运维工作。</p><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><p>我们在一台机器上建立拥有三个节点的mongodb复制集，它们相应的参数如下：</p><table><thead><tr><th align="center">配置参数</th><th align="center">dbpath</th><th align="center">port</th></tr></thead><tbody><tr><td align="center">server0</td><td align="center">/data/mongo/data/r0</td><td align="center">28010</td></tr><tr><td align="center">server1</td><td align="center">/data/mongo/data/r1</td><td align="center">28011</td></tr><tr><td align="center">server2</td><td align="center">/data/mongo/data/r2</td><td align="center">28012</td></tr></tbody></table><p>同时，共用参数：</p><ul><li>logpath: /data/mongo/log/mongo.log</li><li>key: /data/mongo/key/key-file</li></ul><p>这里要做这么几个事情：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1. data,log文件夹的创建</span><br><span class="line">mkdir -pv /data/mongo/data/r0</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">//2. key-file文件，注意权限，不能太OPen</span><br><span class="line">openssl rand -base64 741 &gt; mongodb-keyfile</span><br><span class="line">chmod 600 mongodb-keyfile</span><br><span class="line"></span><br><span class="line">//3. 为了方便，把启动参数全部写到相应的3个配置文件（s0.conf, s1.conf , s2.conf）里面</span><br><span class="line"></span><br><span class="line">dbpath = /data/mongo/data/r0</span><br><span class="line">port=28010</span><br><span class="line">logpath = /data/mongo/log/mongo.log</span><br><span class="line">logappend = true</span><br><span class="line">fork = true</span><br><span class="line">rest = true</span><br><span class="line">replSet=rs0  ##replSet的名字，其他节点要一样</span><br><span class="line">keyFile=/data/mongo/key/mongodb-keyfile</span><br></pre></td></tr></table></figure><h3 id="2-启动mongod"><a href="#2-启动mongod" class="headerlink" title="2. 启动mongod"></a>2. 启动mongod</h3><p>这里要把三个节点依次启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongod -f /data/mongo/conf/s0.conf</span><br><span class="line">mongod -f /data/mongo/conf/s1.conf</span><br><span class="line">mongod -f /data/mongo/conf/s2.conf</span><br></pre></td></tr></table></figure><h3 id="3-连接到s0，把所有的成员加入"><a href="#3-连接到s0，把所有的成员加入" class="headerlink" title="3. 连接到s0，把所有的成员加入"></a>3. 连接到s0，把所有的成员加入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//连接</span><br><span class="line">mongo -port 28010;</span><br><span class="line"></span><br><span class="line">//初始化节点</span><br><span class="line">var config_str=&#123;</span><br><span class="line">    _id:&quot;rs0&quot;,members:[</span><br><span class="line">        &#123;_id:0,host:&quot;127.0.0.1:28010&quot;&#125;,</span><br><span class="line">        &#123;_id:1,host:&quot;127.0.0.1:28011&quot;&#125;,</span><br><span class="line">        &#123;_id:2,host:&quot;127.0.0.1:28012&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line">rs.initiate(config_str);</span><br></pre></td></tr></table></figure><p>到此，复制集应该已经建完了。</p><h3 id="4-查看复制集情况"><a href="#4-查看复制集情况" class="headerlink" title="4. 查看复制集情况"></a>4. 查看复制集情况</h3><p>复制集的情况查看有这么一些方面</p><h4 id="4-1-查看配置，可以了解节点信息"><a href="#4-1-查看配置，可以了解节点信息" class="headerlink" title="4.1 查看配置，可以了解节点信息"></a>4.1 查看配置，可以了解节点信息</h4><p><code>rs.conf();</code></p><p><img src="http://ww4.sinaimg.cn/large/a42ec2f7gw1ej64weibtaj20fk0g2mxr.jpg" alt="Alt text"></p><h3 id="4-2-查看复制集的同步情况"><a href="#4-2-查看复制集的同步情况" class="headerlink" title="4.2 查看复制集的同步情况"></a>4.2 查看复制集的同步情况</h3><p><code>db.printSlaveReplicationInfo();</code><br><img src="http://ww2.sinaimg.cn/large/a42ec2f7gw1ej64xpau7yj20ic07z3zn.jpg" alt="Alt text"></p><h3 id="4-3-当前是否是主节点"><a href="#4-3-当前是否是主节点" class="headerlink" title="4.3 当前是否是主节点"></a>4.3 当前是否是主节点</h3><p><code>rs.isMaster()</code><br><img src="http://ww1.sinaimg.cn/large/a42ec2f7gw1ej64y8mpshj20hr0ckdgv.jpg" alt="Alt text"></p><h3 id="4-4-同步日志详情"><a href="#4-4-同步日志详情" class="headerlink" title="4.4 同步日志详情"></a>4.4 同步日志详情</h3><p><code>db.printReplicationInfo();</code><br><img src="http://ww3.sinaimg.cn/large/a42ec2f7gw1ej64yo3zlaj20ka06faaw.jpg" alt="Alt text"></p><p><code>use local;db.oplog.rs.find();</code><br><img src="http://ww4.sinaimg.cn/large/a42ec2f7gw1ej64z8qutfj20ud0cfjvl.jpg" alt="Alt text"></p><h3 id="4-5-测试同步"><a href="#4-5-测试同步" class="headerlink" title="4.5 测试同步"></a>4.5 测试同步</h3><p>上面的几点都只是看下整体配置情况，现在要测试同步机制是否运转起来了。</p><ul><li><p>首先在Primary节点中插入一条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use my;</span><br><span class="line">db.Temp.insert(&#123;name:&quot;jay&quot;&#125;);</span><br></pre></td></tr></table></figure></li><li><p>连接任意一个SECONDARY节点，查看数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongo -port 28012;</span><br><span class="line">use my;</span><br><span class="line">db.Temp.find().sort(&#123;_id:-1&#125;).limit(1);</span><br></pre></td></tr></table></figure></li></ul><p>很有可能，你会得到这个信息：<br><img src="http://ww1.sinaimg.cn/large/a42ec2f7gw1ej64zspp8wj20kj01idg0.jpg" alt="Alt text"></p><p> 这是因为SECONDARY节点还没有开启读操作权限，执行下面的命令，然后再查下：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rs.slaveOk();</span><br><span class="line">db.Temp.find().sort(&#123;_id:-1&#125;).limit(1);</span><br></pre></td></tr></table></figure></p><blockquote><p>Sets the slaveOk property for the current connection. Deprecated. Use readPref() and Mongo.setReadPref() to set read preference.<br> <strong>根据官方的说法，sleveOk()已经被废弃了，现在推荐readPref()|Mongo.setReadPref()|db.getMongo().setSlaveOk()来进行读优先设置</strong></p></blockquote><p> <img src="http://ww2.sinaimg.cn/large/a42ec2f7gw1ej650guf6sj20k502ydg8.jpg" alt="Alt text"><br>数据已经出来了，说明整个复制集是已经正常运转的。</p><ul><li>可以再回头看看同步记录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.oplog.rs.find().sort(&#123;ts:-1&#125;);</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://ww2.sinaimg.cn/large/a42ec2f7gw1ej651ps6y0j20tx02dq3k.jpg" alt="Alt text"><br>可以看到刚刚的同步记录，op=i 表示插入操作。</p><h3 id="5-正常的运维"><a href="#5-正常的运维" class="headerlink" title="5. 正常的运维"></a>5. 正常的运维</h3><p>复制集建立以后，运维过程中经常会遇到的事情有这么几个方面：</p><ul><li>读写分离</li><li>主从切换</li><li>故障转移</li><li>增减节点</li></ul><h4 id="5-1-读写分离"><a href="#5-1-读写分离" class="headerlink" title="5.1 读写分离"></a>5.1 读写分离</h4><p>首先看看复制集设计的初衷：</p><blockquote><p>A replica set is a group of mongod instances that host the same data set. One mongod, the primary, receives all write operations. All other instances, secondaries, apply operations from the primary so that they have the same data set.</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/a42ec2f7gw1ej6527ql5bj20dw0bdt97.jpg" alt="Alt text"></p><p>所以读写分离基本上是复制集的最主要的目的。通过读写分离，由Primary接收所有的写操作，读操作大部分由Secondary分担，这样数据库的性能将大大提升。</p><p>在建立复制集的过程中其实已经遇到了读写分离的问题，需要对Secondary节点进行读操作配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rs.slaveOk();//已废弃</span><br><span class="line">db.getMongo().setSlaveOk()</span><br><span class="line">cursor.readPref()</span><br><span class="line">db.getMongo.setReadPref()</span><br></pre></td></tr></table></figure><h4 id="5-2-主从切换"><a href="#5-2-主从切换" class="headerlink" title="5.2 主从切换"></a>5.2 主从切换</h4><p>什么时候需要主从切换？</p><blockquote><p>当Primary节点负载过大，或者提供了一台性能更好的机器加入复制集，希望把新机器切换为Primary等，实际情况有很多种，主从切换有可能是经常发生的事情。</p></blockquote><p>主从切换主要有两步</p><ul><li>冻结不参与切换的Secondary节点</li><li>对当期主节点进行降级</li></ul><p>下来来看看这个过程,当期的Primary是（s1,port 28011）,我希望把（s0,port 28010切换为Primary）<br><strong>step 1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 对不参与切换的 s2 进行冻结</span><br><span class="line">mongo -port 28012;</span><br><span class="line">rs.freeze(60); // 冻结60秒</span><br></pre></td></tr></table></figure><p><img src="http://ww4.sinaimg.cn/large/a42ec2f7gw1ej652ubt55j209s01mq2u.jpg" alt="Alt text"></p><p><strong>step 2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//对当前的primary进行降级</span><br><span class="line">mongo -port 28011</span><br><span class="line">rs.stepDown(30); // 30秒内完成降级</span><br></pre></td></tr></table></figure><p><img src="./1402970732234.png" alt="Alt text"><br>从图片上看已经降级了</p><p><strong>step 3</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rs.status();</span><br></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/a42ec2f7gw1ej653brsf9j20re04gt9n.jpg" alt="Alt text"><br>s0已经升级成功</p><h4 id="5-3-故障转移"><a href="#5-3-故障转移" class="headerlink" title="5.3 故障转移"></a>5.3 故障转移</h4><p><code>故障转移</code>是高可用性系统的重要标准。而复制集机制就是<code>故障转移</code>的重要手段，下面来测试一下。</p><ul><li>首先，查看一下当前正在正常运行的mongod复制集实例。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep mongod</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://ww1.sinaimg.cn/large/a42ec2f7gw1ej653sk35pj20pi0f975y.jpg" alt="Alt text"></p><ul><li><p>现在我要把primary节点杀掉，看看会出现什么情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 58090</span><br></pre></td></tr></table></figure></li><li><p>连上s1,查看相关当前复制集情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongo -port 28011;</span><br><span class="line">rs.status();</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://ww1.sinaimg.cn/large/a42ec2f7gw1ej654d0m58j20u505vta5.jpg" alt="Alt text"><br><strong>可以看到主节点已经不可用了，但是实际Secondary并没有自动选举出新的Primary，好奇怪，先放这里吧</strong><br><strong>实际情况是：我把s0重启，复制集居然自动选举了，现在s2是Primary</strong></p><h4 id="5-4-增减节点"><a href="#5-4-增减节点" class="headerlink" title="5.4 增减节点"></a>5.4 增减节点</h4><p>增加节点有两种方式：</p><ul><li>通过oplog增加节点</li><li>通过数据库快照和oplog综合增加节点</li></ul><h5 id="5-4-1-通过oplog增加节点"><a href="#5-4-1-通过oplog增加节点" class="headerlink" title="5.4.1 通过oplog增加节点"></a>5.4.1 通过oplog增加节点</h5><p>这个依赖于oplog数据的可靠性，应为oplog是一个CapCollection,数据可能不完整，所以一般不推荐使用。<br>当然这个操作也相对比较简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1. 启动一个新的待添加的节点</span><br><span class="line">mongod -f /data/mongo/conf/s3.conf</span><br><span class="line">// 2. 把这个节点加入</span><br><span class="line">rs.add(&quot;127.0.0.1:28013&quot;);</span><br><span class="line">//3. 静静等待同步结果</span><br><span class="line">rs.status();</span><br></pre></td></tr></table></figure><h5 id="5-4-2-通过数据库快照-oplog增加节点"><a href="#5-4-2-通过数据库快照-oplog增加节点" class="headerlink" title="5.4.2 通过数据库快照+oplog增加节点"></a>5.4.2 通过数据库快照+oplog增加节点</h5><p>这个方法比较讨巧，原理就是先复制一份其他Secondary节点的数据库快照文件，然后在Primary加一条数据用于验证。最后把新节点加入复制集，等60秒查看刚刚的数据同步了没有。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1. 复制数据库文件快照</span><br><span class="line">cp -rv /data/mongo/data/s1  /data/mongo/data/s3</span><br><span class="line"></span><br><span class="line">//2. 连接primary,新增一条验证数据</span><br><span class="line">mongo -port 28012;</span><br><span class="line">use my;</span><br><span class="line">my.Temp.insert(&#123;name:&quot;test&quot;&#125;);</span><br><span class="line"></span><br><span class="line">// 3. 启动一个待添加的节点</span><br><span class="line">mongod -f /data/mongo/conf/s3.conf</span><br><span class="line"></span><br><span class="line">//4. 把这个节点加入</span><br><span class="line">rs.add(&quot;127.0.0.1:28013&quot;);</span><br><span class="line"></span><br><span class="line">//5. 静静等待同步结果</span><br><span class="line">rs.status();</span><br></pre></td></tr></table></figure><p>上面的过程我全程验证了一遍，懒得截图了。</p><h3 id="6-相关链接"><a href="#6-相关链接" class="headerlink" title="6. 相关链接"></a>6. 相关链接</h3><ul><li><a href="http://docs.mongodb.org/manual/core/replication-introduction/" target="_blank" rel="noopener">官方简单介绍</a></li><li><a href="http://docs.mongodb.org/manual/reference/replication/" target="_blank" rel="noopener">官方 reference</a></li><li><a href="http://docs.mongodb.org/ecosystem/drivers/java-replica-set-semantics/" target="_blank" rel="noopener">java driver to replica</a></li><li><a href="http://docs.mongodb.org/ecosystem/drivers/java/" target="_blank" rel="noopener">java-driver</a></li></ul><h3 id="7-后续"><a href="#7-后续" class="headerlink" title="7. 后续"></a>7. 后续</h3><p>花了一个下午学习，一个上午写完这篇笔记。其实还有一个很重要的点没有去研究，先记录到这里。</p><blockquote><p>java driver 与复制集的交互</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步Or异步，阻塞OR非阻塞</title>
      <link href="/2014/08/08/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2014/08/08/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>关于阻塞/非阻塞 | 同步/异步 这两组概念的理解</p><blockquote><p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。<br>1 老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻<br>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀<del>~</del>的噪音。<br>3 老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大<br>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。</p></blockquote><p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</p><p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>同步异步阻塞非阻塞的理解</title>
      <link href="/2014/08/08/%E5%90%8C%E6%AD%A5Or%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9EOR%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
      <url>/2014/08/08/%E5%90%8C%E6%AD%A5Or%E5%BC%82%E6%AD%A5%EF%BC%8C%E9%98%BB%E5%A1%9EOR%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      
        <content type="html"><![CDATA[<p>关于阻塞/非阻塞 | 同步/异步 这两组概念的理解</p><blockquote><p>老张爱喝茶，废话不说，煮开水。<br>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。<br>1 老张把水壶放到火上，立等水开。（同步阻塞）<br>老张觉得自己有点傻<br>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）<br>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀<del>~</del>的噪音。<br>3 老张把响水壶放到火上，立等水开。（异步阻塞）<br>老张觉得这样傻等意义不大<br>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）<br>老张觉得自己聪明了。</p></blockquote><p>所谓同步异步，只是对于水壶而言。<br>普通水壶，同步；响水壶，异步。<br>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。<br>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</p><p>所谓阻塞非阻塞，仅仅对于老张而言。<br>立等的老张，阻塞；看电视的老张，非阻塞。<br>情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NIO中的Selector机制</title>
      <link href="/2014/08/08/NIO%E4%B8%AD%E7%9A%84Selector%E6%9C%BA%E5%88%B6/"/>
      <url>/2014/08/08/NIO%E4%B8%AD%E7%9A%84Selector%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p><code>SelectionKey</code>表示 <code>SelectableChannel</code> 在 <code>Selector</code> 中的注册的标记。</p><p>每次向选择器注册通道时就会创建一个选择键。通过调用某个键的 cancel 方法、关闭其通道，或者通过关闭其选择器来取消 该键之前，它一直保持有效。<code>取消某个键不会立即从其选择器中移除它</code>；相反，会将该键添加到选择器的已取消键集，以便在下一次进行选择操作时移除它。可通过调用某个键的 isValid 方法来测试其有效性。</p><p>选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。</p><ul><li><p>interest 集合, 确定了<code>下一次</code>调用某个选择器的选择方法时，<code>将测试哪类操作的准备就绪信息</code>。创建该键时使用给定的值初始化 interest 集合；之后可通过 interestOps(int) 方法对其进行更改。</p></li><li><p>ready 集合, 标识了这样一类操作，<code>即某个键的选择器检测到该键的通道已为此类操作准备就绪</code>。创建该键时 ready 集合被初始化为零；可以在之后的选择操作中通过选择器对其进行更新，但不能直接更新它。</p></li></ul><p>选择键的 ready 集合指示，其通道对某个操作类别已准备就绪，该指示只是一个提示，并不保证线程可执行此类别中的操作而不导致被阻塞。ready 集合很可能一完成选择操作就是准确的。ready 集合可能由于外部事件和在相应通道上调用的 I/O 操作而变得不准确。</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>选择器维护了三种选择键集：</p><ul><li><p>键集, 包含的键表示当前通道到此选择器的注册。此集合由 keys 方法返回。</p></li><li><p>已选择键集, 是这样一种键的集合，即在前一次选择操作期间，检测每个键的通道是否已经至少为该键的相关操作集所标识的一个操作准备就绪。此集合由 selectedKeys 方法返回。已选择键集始终是键集的一个子集。</p></li><li><p>已取消键集, 是已被取消但其通道尚未注销的键的集合。不可直接访问此集合。已取消键集始终是键集的一个子集。</p></li></ul><p>在新创建的选择器中，这三个集合都是空集合。</p><p>通过某个通道的 register 方法注册该通道时，所带来的副作用是向选择器的键集中添加了一个键。在选择操作期间从键集中移除已取消的键。<code>键集本身是不可直接修改的</code>。</p><p>不管是通过关闭某个键的通道还是调用该键的 cancel 方法来取消键，该键都被添加到其选择器的已取消键集中。<code>取消某个键会导致在下一次选择操作期间注销该键的通道</code>，而在注销时将从所有选择器的键集中移除该键。</p><p><code>通过选择操作将键添加到已选择键集中</code>。可通过调用<code>已选择键集的 remove 方法</code>，或者通过调用从该键集获得的 <code>iterator 的 remove 方法</code>直接移除某个键。通过任何其他方式从<code>不会</code>将键从已选择键集中移除；特别是，它们不会因为影响选择操作而被移除。不能将键直接添加到已选择键集中。</p><h3 id="Selector-select-过程描述"><a href="#Selector-select-过程描述" class="headerlink" title="Selector.select() 过程描述"></a>Selector.select() 过程描述</h3><p>在每次选择操作期间，都可以将键添加到选择器的已选择键集以及从中将其移除，并且可以从其键集和已取消键集中将其移除。执行涉及三个步骤：</p><ol><li><p>将<code>已取消键集</code>中的每个键从所有键集中移除（如果该键是键集的成员），并注销其通道。此步骤使已取消键集成为空集。</p></li><li><p>在开始进行选择操作时，应<code>查询基础操作系统来更新每个剩余通道的准备就绪信息</code>，以执行由其键的相关集合所标识的任意操作。对于已为至少一个这样的操作准备就绪的通道，执行以下两种操作之一：</p><p>2.1 如果该通道的键尚未在已选择键集中，则将其<code>添加</code>到该集合中，并<code>修改</code>其准备就绪操作集，以准确地标识那些通道现在已报告为之准备就绪的操作。丢弃准备就绪操作集中以前记录的所有准备就绪信息。</p><p>2.2 如果该通道的键已经在已选择键集中，则修改其准备就绪操作集，以准确地标识所有通道已报告为之准备就绪的新操作。保留准备就绪操作集以前记录的所有准备就绪信息；换句话说，基础系统所返回的准备就绪操作集是和该键的当前准备就绪操作集按位分开 (bitwise-disjoined) 的。</p></li><li><p>如果在此步骤开始时键集中的所有键都有空的相关集合，则不会更新已选择键集和任意键的准备就绪操作集。如果在步骤 (2) 的执行过程中要将任意键添加到已取消键集中，则处理过程如步骤 (1)。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql语句调优</title>
      <link href="/2014/05/13/mysql%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98/"/>
      <url>/2014/05/13/mysql%E8%AF%AD%E5%8F%A5%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<p>最近在整理一些关于MySQL调优的事情，网络上条条框框的很多，有的内容说的很多，有的说得非常的零碎，说得都对，但总是感觉就是看过就忘记了，这些东西没有系统的分类整理，或者串起来，我按照自己的理解，稍微梳理一下，看看这样子看起来是不是会更有条理一些。</p><p>对于SQL的调优，我觉得大概可以从三个方面思考：</p><ol><li>设计阶段</li><li>索引命中</li><li>通用最佳实践写法</li></ol><h3 id="1-设计阶段"><a href="#1-设计阶段" class="headerlink" title="1. 设计阶段"></a>1. 设计阶段</h3><p>表结构的设计其实已经很大程度上决定了程序上SQL编写以及执行性能。所以这个阶段其实很重要。这这里我们只要记住两条原则：</p><ol><li>列越小速度越快</li><li>表数据越小速度越快</li></ol><p>针对<code>列越小</code>原则，我们的很多观念以及习惯是需要纠正一下的。在我们的数据库设计当中，最常见的一些字段如“type,status”等，这些字段都是参数性质的,常常会放到查询条件中来匹配过滤，一般的做法就是定义为int类型。这个实际上造成了很大的浪费，这种参数化字段往往用tinyint或者ENUM就足够描述了，如果严格按照这个原则去设计库表，会节省很多空间，针对这些字段的查询效率也会高很多。</p><p>至于<code>表数据越小</code>原则，这里我们要用到<code>垂直拆分</code>。来思考一个应用场景，User表中有一个Address系列的字段，这系列字段存储的都是中文，数据量颇为可观，而且这些字段不是特别重要，只有在<code>用户详情</code>页面需要展示一下地址信息，这里我们就可以可以考虑把Address系列字段拆分到一个独立的表，这样可以大大减少User表的数据量，数据量一小，针对User表相应的查询效率也会提升。</p><p>在设计阶段，还有一些原则也是需要遵行的，一般来说我们应该为每个表建立int类型的自增长主键，而不采用像mobile，email这样的业务标示作为主键。</p><h3 id="2-索引命中"><a href="#2-索引命中" class="headerlink" title="2. 索引命中"></a>2. 索引命中</h3><p>索引命中的问题分成两部分来看，我们其实希望尽可能的命中索引，同时希望尽可能的避免使索引失效，这两句话看起来是同一个意思，但是实际上却是两个方向。</p><ol><li>尽可能命中索引</li><li>尽可能避免使索引失效</li></ol><p>对于<code>命中索引</code>这个问题，我们首先要了解索引命中的一个基本原则：<code>最左前缀原则</code>，假设我们在建立了一个复合索引（a,b,c）,那么下面这些情况是可以命中这一索引的：<br>    where a = ‘xxxx’<br>    where a = ‘xxxx’ and b = ‘yyyyy’<br>    where a =’xxxx’ and b =’yyyy’ and c =’zzzz’<br>同时，这样是无法命中索引的：<br>    where b =’yyyy’<br>    where b=’xxxxx’ and c=’yyyy’</p><p>看明白了？对于索引的使用，我们要按照索引定义的字段的先后顺序来摆放，所以要特别留意索引字段的先后顺序。</p><p>对于<code>避免索引失效</code>，我们需要知道这样的情况是会导致索引无法命中而失效的，尽量要避免这样的一些写法：</p><ol><li>索引列上存在Null值，这样的话我们一般需要加 is not null</li><li>union, between…and , in , != 这样的操作都会导致索引无法命中</li><li>索引列上使用了内置函数</li><li>索引列上存在隐式类型转换，如字段是int类型，传入的参数是’1’这样的字符串</li></ol><h3 id="3-通用最佳实践写法"><a href="#3-通用最佳实践写法" class="headerlink" title="3. 通用最佳实践写法"></a>3. 通用最佳实践写法</h3><p>这一部分的话基本上就是大家比较认可的一些高效写法了，死记硬背没有任何一样的，关键是要在实际使用中自律的遵循这些原则。</p><ol><li>按需拿取。完全避免 <code>select *</code> 这种写法，需要多少字段拿多少。</li><li>最强过滤条件前置。 例如 depart_id = ? and age &gt; 30 , 很明显 depart_id这种字段能过滤大部分数据，应该前置，帮助查询分析器减少扫描范围。</li><li>唯一返回则加limit 1.  如果确定查询只会返回一条记录，则加上 limit 1会高效很多。</li><li>对于<code>in</code>子句，应该用<code>exists</code>子句替代。</li><li><code>join</code> 中的关联字段应该保证它们类型一致，同时都加上索引。</li><li>尽量让查询分析器缓存你的SQL语句。我们知道，一个SQL执行次数比较多话，执行引擎会自动缓存它，但是如果SQL中使用了curdate()这样的函数，则无法缓存，应该去掉函数，由外部传入参数。</li></ol><p>关于SQL优化的话题实在太多太多，先写这么些以后慢慢加吧，我觉得这样分类梳理以后更加清晰，不像某些大牛的一下子给你100个招式，看完以后一个也记不住。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell学习入门</title>
      <link href="/2014/05/01/shell%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
      <url>/2014/05/01/shell%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>花了大概一天半的时间比较全面的接触了一下shell脚本，对于这种语言我对自己的要求很简单，不求深度精通，能写工具类脚本，能阅读别人的脚本，能在在相应场合无障碍沟通就好。这里整理一下这个阶段的知识结构，准备再花一到两天时间接触一下一些高级玩法，到时候Shell就算完篇了。</p><hr><p>Shell 也是一门编程语言，学习编程语言我觉得需要关注这么一些点：</p><ul><li><p>数据类型</p></li><li><p>语法/ 结构控制</p></li><li><p>内置函数和变量</p></li></ul><p>只要相应的关注整理一下，入门还是很快的，我相信读完这篇文章以后，你基本上可以认为自己能独立读写一些简单的Shell脚本，可以有底气的说自己是一个初级的Sheller了。</p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>首先要了解一下Shell的变量声明，引用等语法规则。有两个command(<code>declare,local</code>)与变量的声明有关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare  a=1  #声明一个全局变量</span><br><span class="line">local  b=&quot;hello~~&quot;   #声明一个局部变量，一般在函数体中使用</span><br><span class="line">c=1     #实际情况是，这两个command可用可不用,不使用同样可以声明变量</span><br></pre></td></tr></table></figure><p><strong><em>变量的声明特别要注意赋值等号（=）两边不能有空格。</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 2  #这个声明就会失败！！！</span><br></pre></td></tr></table></figure><p>变量声明了以后还有一个<code>变量读取</code>，Shell读取变量的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;var&#125; 或者 $var #作为一个资深Coder，当然知道前者更专业，可以避免在字符串中解析出错</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>shell 不像那些严谨的编程语言有完整的数据体系，我现在接触到的就这么几种：</p><ol><li>字符串</li><li>数值(整形/浮点)</li><li>数组（简单数组/关联数组）</li></ol><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>这个是最常用也是最简单的数据类型了，首先来感受一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello,shell~~&quot; #输出字符串到控制台</span><br><span class="line">echo &quot;hello, shell &quot; &gt; a.txt  #将字符串输入到文件a.txt中，输入之前会清空文件</span><br><span class="line">echo &quot;hello,shell&quot; &gt;&gt; a.txt #将字符串输入到文件a.txt中，输入之前不清空文件</span><br></pre></td></tr></table></figure><p>和其他的编程语言一样，字符串也有相应的一些操作，整理下来基本上就是这么一些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">取字符串长度 :  $&#123;#string&#125;</span><br><span class="line"></span><br><span class="line">子串截取:  </span><br><span class="line">$&#123;string:position:length&#125;  从起始位置截取指定长度</span><br><span class="line">$&#123;string:position&#125;  从起始位置截取到末尾</span><br><span class="line"></span><br><span class="line">子串替换:</span><br><span class="line">$&#123;string/substring/replacement&#125; 替换第一个匹配的子串</span><br><span class="line">$&#123;string//substring/replacement&#125; 替换所有子串</span><br><span class="line"></span><br><span class="line">子串删除</span><br><span class="line">$&#123;string%substring&#125; 从变量$string的结尾, 删除最短匹配$substring的子串</span><br><span class="line">$&#123;string%%substring&#125; 从变量$string的结尾, 删除最长匹配$substring的子串</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><p>数值分为整形和浮点型，他们的操作完全不一样，所以得分开说。<br>数值类型的话关注点就在运算了，Shell对于整形的运算有三种方式，如下：<br>** let  **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=1;</span><br><span class="line">b=2;</span><br><span class="line">let c=a+b;</span><br><span class="line">echo $c;</span><br></pre></td></tr></table></figure><p>** [ ]  中括号**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=1;</span><br><span class="line">b=2;</span><br><span class="line">c=$[a+b];</span><br><span class="line">echo $c;</span><br></pre></td></tr></table></figure><p>** (( )) 双小括号 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=1;</span><br><span class="line">b=2;</span><br><span class="line">c=$(( $a+$b));</span><br><span class="line">echo $c;</span><br></pre></td></tr></table></figure><p><strong>*这里总结一下， 这三种方式还是有一些细微的差别的，let 方式最为简单。[ ]需要注意在外面要用$对返回值进行引用。 (( ))最为复杂容易出错，首先在括号内变量的必须要加$引用，其次左括号必须和变量间有空格。 *</strong></p><p>bash 不支持浮点运算，如果需要进行浮点运算，需要借助<code>bc,awk</code> 处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=$(echo &quot;5.01-4*2.0&quot;|bc)</span><br><span class="line">c=$(awk &apos;BEGIN&#123;print 7.01*5-4.01 &#125;&apos;)</span><br></pre></td></tr></table></figure><p><code>bc,awk</code>我暂时也还没有接触到，先放到这吧。<strong><em>todo</em></strong></p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组的定义(初始化)比较简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr=(0 1 2 3 4 5 6 7 8 9);</span><br><span class="line">或者</span><br><span class="line">arr[0]=0;</span><br><span class="line">arr[1]=1;</span><br><span class="line">arr[2]=2;</span><br></pre></td></tr></table></figure><p>下面就是关于数组的一些操作了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#循环打印数组元素</span><br><span class="line">for  i  in $&#123;arr[@]&#125; ; do</span><br><span class="line">     echo $arr[i]</span><br><span class="line">done;</span><br><span class="line">#这里牵涉到了两个知识点：</span><br><span class="line">#（1）$&#123;arr[@]&#125;  表示数组中的所有元素</span><br><span class="line">#（1）$arr[i]  获取数组元素的形式，其中i为索引</span><br><span class="line"></span><br><span class="line">#顺便说了for结构，对于for结构也可以这样：</span><br><span class="line">for i in 1 2 3 4 5 ;do</span><br><span class="line">    echo $i</span><br><span class="line">done;</span><br><span class="line"></span><br><span class="line"># 还可以这样：</span><br><span class="line">for((i=0;i&lt;=10;i++));do</span><br><span class="line">     echo $i;</span><br><span class="line">done;</span><br><span class="line"></span><br><span class="line">#回到数组，获取数组的长度：</span><br><span class="line">$&#123;#arr[@]&#125;</span><br></pre></td></tr></table></figure><p>数组的基本操作就是这些了，这里所说的数组都是简单数组，它的索引只能是数值，关联数组的不同之处在于索引可以是其他类型如字符串。<code>需要bash4.0以上才支持</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">declare -A phone</span><br><span class="line">phone=([jim]=135 [tom]=136 [lucy]=158)</span><br></pre></td></tr></table></figure><p>数据类型基本上就是这些了，接下来看看一些常见的结构控制及语法。我们都知道程序的结构有三种：</p><ul><li><p>顺序结构</p></li><li><p>选择结构</p></li><li><p>循环结构</p></li></ul><p>就从这个结构来入手语法吧。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>顺序结构就没什么好说的了，重点是后面两种。</p><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><p>选择结构说白了就是会存在逻辑判断，Shell里面也提供两种大结构来支持判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># ------数字比较--------</span><br><span class="line">if test 100 -gt 50 ;</span><br><span class="line">then</span><br><span class="line">      ehco &quot; 100 大于50&quot;;</span><br><span class="line">else</span><br><span class="line">     ehco &quot;100 小于50&quot;</span><br><span class="line">fi</span><br><span class="line"># ------字符串比较--------</span><br><span class="line">if test a \&gt; b ;</span><br><span class="line">then</span><br><span class="line">      ehco &quot; a 大于b&quot;;</span><br><span class="line">else</span><br><span class="line">     ehco &quot;a 小于b&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#------case 子句----------</span><br><span class="line">case &quot;$Keypress&quot; in  </span><br><span class="line">  [[:lower:]]   ) echo &quot;Lowercase letter&quot;;;  </span><br><span class="line">  [[:upper:]]   ) echo &quot;Uppercase letter&quot;;;  </span><br><span class="line">  [0-9]         ) echo &quot;Digit&quot;;;  </span><br><span class="line">  *             ) echo &quot;Punctuation, whitespace, or other&quot;;;  </span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>上面只是简单的示例，现在来说说具体的语法。对于<code>if</code>结构，后面的<code>比较操作</code>有三种写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 1. test</span><br><span class="line">if test 100 -gt 50 ;</span><br><span class="line">then</span><br><span class="line">      ehco &quot; 100 大于50&quot;;</span><br><span class="line">else</span><br><span class="line">     ehco &quot;100 小于50&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 2. [ ]中括号</span><br><span class="line">if [ a \&gt; a  ]</span><br><span class="line">    then</span><br><span class="line">    echo  &quot;a&gt;a&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;a&lt;a&quot;</span><br><span class="line">fi;</span><br><span class="line"></span><br><span class="line"># 3. [[ ]]  双中括号</span><br><span class="line">if [[ a == a &amp;&amp; 2 &gt; 3 ]] </span><br><span class="line">    then</span><br><span class="line">        echo &quot; all true&quot;;</span><br><span class="line">    else</span><br><span class="line">        echo &quot; not all true&quot;;</span><br><span class="line">fi;</span><br></pre></td></tr></table></figure><p>总结一下，这三种写法中 test, [ ] 最为复杂，对于<code>&lt;,&gt;</code>等操作符必须要要转义<code>\&gt;, \&lt;</code>，而且不支持多条件判断，所以一般情况下就用双中括号[[ ]]来得简单。</p><p>shell中提供的支持判断的操作符比较别扭，分别正对字符串，数值比较各有一套：<br><em>字符串比较</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; , &gt;=  : 大于，大于等于</span><br><span class="line">&lt;, &lt;=  : 小于，小于等于</span><br><span class="line">==  :  等于</span><br><span class="line">!= : 不等于</span><br><span class="line">-z  : 字符串为空</span><br><span class="line">-n  : 字符串非空</span><br></pre></td></tr></table></figure><p><em>数值比较</em>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-eq   等于</span><br><span class="line">-ne   不等于</span><br><span class="line">-lt     小于</span><br><span class="line">-le    小于等于</span><br><span class="line">-gt    大于</span><br><span class="line">-ge    大于或等于</span><br></pre></td></tr></table></figure><p><em>文件比较</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-e  文件是否存在      </span><br><span class="line">-f  是一个标准文件          </span><br><span class="line">-d  是一个目录</span><br></pre></td></tr></table></figure><p>个人感觉这个定义好别扭，字符串和数值完全没有必要弄两套比较体系，而且数值比较很直观的东西变得很复杂。接下来，最蛋痛的事情到了，上面说到<code>if</code>后面的写法有三种：<code>test , [] , [[ ]]</code>。其中<code>test, []</code> 是严格按照比较操作符的定义来的，如果是字符串比较，只能用<code>符号比较&gt;,&lt;</code>等，如果是数值比较，只能用<code>文字比较符 -gt ,-lt</code>等，<strong>但是对于[[ ]] 无论是文字比较还是数值比较，两种比较符都可以任意使用</strong>。所以一般建议只用<code>[[]]</code>，你以为这就完了？不，还有一种情况,三目运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $(( 3 &gt; 2?100:999));</span><br><span class="line">echo $(( a &gt; b?101:991));</span><br></pre></td></tr></table></figure><p>三目运算表达式只能用<code>符号比较符 &gt; ，&lt; 等</code>！！！<br>在这一段的学习过程中我是感觉非常混乱，绕了好久才把这些点给理清楚，现在统一总结一下：</p><ol><li><code>test , [] , [[ ]]</code>三种结构中，<code>test ,[]</code> 需要对<code>&lt;,&gt;</code>等转义。而且两种比较符各司其职，不能跨界操作。而 <code>[[]]</code>不需要转义，比较符号也可以跨界操作，非常方便。所以一般就只用<code>[[]]</code>.</li><li>三目运算表达式中的比较只能用<code>符号比较符 &gt;, &lt;</code>.</li></ol><p>Case子句的写法就没这么纠结了，当然在我看来，语法还是很蛋痛的。来记录一下它的语法规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case &quot;$Keypress&quot; in  </span><br><span class="line">  [[:lower:]]   ) echo &quot;Lowercase letter&quot;;;  </span><br><span class="line">  [[:upper:]]   ) echo &quot;Uppercase letter&quot;;;  </span><br><span class="line">  [0-9]         ) echo &quot;Digit&quot;;;  </span><br><span class="line">  *             ) echo &quot;Punctuation, whitespace, or other&quot;;;  </span><br><span class="line">esac</span><br></pre></td></tr></table></figure><ol><li>条件判断分支必须用<code>右括号 )</code>结束。</li><li>条件子句必须用<code>两个分号;;</code>结束。</li></ol><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>Shell的循环结构比较简单，就是for, while。都来看看吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#1. for 指定数组</span><br><span class="line">for loop in 1 2 3 4 5 6</span><br><span class="line">do</span><br><span class="line">  echo $loop</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#2. for 变量自增长</span><br><span class="line">for i in `seq 100`</span><br><span class="line">do</span><br><span class="line">    echo $i;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#3. for 循环已定义数组</span><br><span class="line">arr=(1 2 3  4 5 6 7 8 9 0)</span><br><span class="line">for i in $&#123;arr[@]&#125; ;do</span><br><span class="line">    echo $i;</span><br><span class="line">done;</span><br><span class="line"></span><br><span class="line">#4.  指定范围</span><br><span class="line">for i in &#123;1..10&#125; ;do</span><br><span class="line">    echo $i;</span><br><span class="line">done;</span><br><span class="line"></span><br><span class="line">#45. while (( ))</span><br><span class="line">COUNTER=0</span><br><span class="line">while(($COUNTER&lt;=5))</span><br><span class="line">do</span><br><span class="line">        echo $COUNTER</span><br><span class="line">        let &quot;COUNTER++&quot;;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">#5. while [[ ]]</span><br><span class="line">while [[ $num != 4 ]]</span><br><span class="line">do</span><br><span class="line">    echo $num;</span><br><span class="line">    let &quot;num++&quot;;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><p>循环结构远没有选择结构那么复杂，基本上看看这些示例就OK了。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>语法部分还有一个比较重要的方面就是函数了。函数的定义和其他语言一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function myfun()&#123;</span><br><span class="line">    echo &quot;共传入了:$# 个参数，分别是：&quot; </span><br><span class="line">    for i in $*; do </span><br><span class="line">        echo $i</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"># 1.   $# 参数个数</span><br><span class="line"># 2.  $*  所有参数的数值</span><br><span class="line">#3.  function 可写可不写</span><br></pre></td></tr></table></figure><p>Shell似乎不支持带参函数，所以如何在函数内获取参数呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function myfun()&#123;</span><br><span class="line">     echo $&#123;1&#125;;</span><br><span class="line">         echo $&#123;2&#125;;</span><br><span class="line">         echo $&#123;3&#125;;</span><br><span class="line">&#125;</span><br><span class="line">#按照索引来获取参数就好了。注意，索引从1开始，$&#123;0&#125;获取的是脚本名。</span><br></pre></td></tr></table></figure><p>函数的执行也和其它程序不一样，来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum=0</span><br><span class="line">function myadd()&#123;</span><br><span class="line">    for i in $*; do </span><br><span class="line">        let sum+=$i</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line">myadd 1 2 3 4  # 执行函数</span><br><span class="line">echo $sum;</span><br></pre></td></tr></table></figure><p>如果函数有返回值，则可以直接赋值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function myadd()&#123;</span><br><span class="line">    for i in $*; do </span><br><span class="line">        let sum+=$i</span><br><span class="line">    done</span><br><span class="line">     return $sum;</span><br><span class="line">&#125;</span><br><span class="line">$(myadd 1 2 3 4)  # 执行函数</span><br><span class="line">num=$?  #获取返回值</span><br></pre></td></tr></table></figure><p>到此为止，基本上语法就都走了一遍，接下来要了解一些shell内置的一些变量，命令等，这个是真正能玩转起来的重要因素，看看有哪些东西是需要关注的吧。</p><h3 id="内置变量及命令"><a href="#内置变量及命令" class="headerlink" title="内置变量及命令"></a>内置变量及命令</h3><p>首先来了解一下一些特殊的内置变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$0  脚 本名字</span><br><span class="line">$1- $9  位置参数 #1 - #9</span><br><span class="line">$&#123;10&#125;   位置参数 #10</span><br><span class="line">$#     位置参数的个数</span><br><span class="line">&quot;$*&quot;    所有的位置参数(作为单个字符串) *</span><br><span class="line">&quot;$@&quot;    所有的位置参数(每个都作为独立的字符串)</span><br><span class="line">$&#123;#*&#125;   传递到脚本中的命令行参数的个数</span><br><span class="line">$&#123;#@&#125;   传递到脚本中的命令行参数的个数</span><br><span class="line">$?  返回值</span><br><span class="line">$$  脚本的进程ID(PID)</span><br><span class="line">$-  传递到脚本中的标志(使用set)</span><br><span class="line">$_  之前命令的最后一个参数</span><br><span class="line">$!  运行在后台的最后一个作业的进程ID(PID)</span><br></pre></td></tr></table></figure><p>对于初次接触者，可能这么几个要重点关注下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1. 位置参数，在上面的示例中已经用过，函数内部使用传递参数的写法</span><br><span class="line">$1 - $9 位置参数 #1 - #9</span><br><span class="line">$&#123;10&#125;   位置参数 #10</span><br><span class="line"></span><br><span class="line"># 2.   参数的数量 </span><br><span class="line">$#     位置参数的个数</span><br><span class="line"></span><br><span class="line">#3.  参数的集合，在一些不关心具体参数值的函数中特别有用，例如 add</span><br><span class="line">$@  所有的位置参数(每个都作为独立的字符串)</span><br><span class="line"></span><br><span class="line">#4.  函数的返回值, 不能直接将函数执行后复制给变量，必须通过这个返回值变量</span><br><span class="line">$?  返回值</span><br></pre></td></tr></table></figure><p>命令的话太多了，这里就不纠结这个话题，通篇下来，shell的初步接触应该比较完备了，后续再研究下高端玩法。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm垃圾回收机制探析</title>
      <link href="/2014/03/30/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%8E%A2%E6%9E%90/"/>
      <url>/2014/03/30/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%8E%A2%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>最近比较粗浅的接触了一下JVM，发现有很多东西还是非常有意思的，并不像之前的印象，觉得JVM相关的东西生涩难懂。本文主要记录这段时间内对JVM的接触，主要包括这么几个内容：</p><ul><li><p>JVM结构及内存管理机制</p></li><li><p>JVM垃圾回收常见算法</p></li><li><p>各种垃圾回收器对比分析</p></li><li><p>垃圾回收器参数汇总</p></li></ul><h1 id="1-JVM组成结构"><a href="#1-JVM组成结构" class="headerlink" title="1. JVM组成结构"></a>1. JVM组成结构</h1><p>JVM主要由3部分组成，分别是类加载子系统（ClassLoader），执行引擎（Execute Engine），运行数据区域（Runtime Data Area）。</p><h2 id="1-1-类加载器"><a href="#1-1-类加载器" class="headerlink" title="1.1 类加载器"></a>1.1 类加载器</h2><p>类加载器负责对Class文件的装载工作，JVM内部对ClassLoader也有一套完整的体系结构，ClassLoader主要分为以下几种：</p><ul><li><p>Bootstrap ClassLoader<br>启动类加载器，Classloader体系的根节点，其他ClassLoader都是通过直接或间接继承至它，它在JVM启动时加载，主要加载<java_home>\lib，或是-Xbootclasspath参数指定的路径中的，并且可以被虚拟机识别(仅仅按照文件名识别的)的类库到虚拟机内存中。</java_home></p></li><li><p>Extension ClassLoader<br> 扩展类加载器，继承于Bootstrap，主要负责加载<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库。</java_home></p></li><li><p>Application ClassLoader<br>应用程序类加载器，继承至扩展类加载器，主要负责加载ClassPath路径上的类库，如果应用程序没有自定义自己类加载器，则这个就是默认的类加载器。</p></li></ul><p>类加载器采用双亲委派模型工作，如果一个类加载器收到一个类加载的请求，它首先将这个请求委派给父类加载器去完成，每一个层次类加载器都是如此，则所有的类加载请求都会传送到顶层的启动类加载器，只有父加载器无法完成这个加载请求(即它的搜索范围中没有找到所要的类)，子类才尝试加载。这样做的好处有两点：1）可以避免重复加载，2）安全角度考虑，防止用户自定义类加载器替代Java的核心API。</p><h2 id="1-2-运行数据区"><a href="#1-2-运行数据区" class="headerlink" title="1.2  运行数据区"></a>1.2  运行数据区</h2><p>运行数据区实际上就是JVM的内存管理区，它主要分为5个部分，分别是：</p><ul><li><p>方法区（Method Area）<br>方法区主要存放类信息，类的静态变量，常量，属性，方法等信息。</p></li><li><p>堆（heap）<br>所有通过new操作创建的对象的内存都在堆中分配。堆又被划分为新生代（Young Generation）和旧生代（Tenured Generation）。新生代又被进一步划分为Eden和Survivor区，最后Survivor由From和To组成，新建的对象都是用新生代的Eden分配内存，Eden空间不足的时候，会把存活的对象转移到Survivor中，新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例旧生代。eden,from ,to的默认比例是8：1：1。</p></li><li><p>栈(Stack)<br> 每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果</p></li><li><p>程序计数器(Program Counter Register)</p></li><li><p>本地方法栈(Native Method Stack)<br> 用于支持native方法的执行，存储了每个native方法调用的状态。</p></li></ul><h1 id="2-JVM垃圾回收算法"><a href="#2-JVM垃圾回收算法" class="headerlink" title="2.  JVM垃圾回收算法"></a>2.  JVM垃圾回收算法</h1><p>JVM垃圾回收要经过两个主要过程，垃圾的收集和垃圾的回收，对于垃圾收集，主要有以下两种算法：</p><h2 id="2-1-垃圾收集"><a href="#2-1-垃圾收集" class="headerlink" title="2.1 垃圾收集"></a>2.1 垃圾收集</h2><h3 id="2-1-1-引用计数算法"><a href="#2-1-1-引用计数算法" class="headerlink" title="2.1.1 引用计数算法"></a>2.1.1 引用计数算法</h3><p>   在JDK1.2之前，使用的是引用计数器算法，即当这个类被加载到内存以后，就会产生方法区，堆栈、程序计数器等一系列信息，当创建对象的时候，为这个对象在堆栈空间中分配对象，同时会产生一个引用计数器，同时引用计数器+1，当有新的引用的时候，引用计数器继续+1，而当其中一个引用销毁的时候，引用计数器-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了！<br>   ，但是随着业务的发展，很快出现了一个问题当我们的代码出现下面的情形时，该算法将无法适应：<br>   ObjA.obj = ObjB<br>   ObjB.obj = ObjA<br>   这样的代码会产生如下引用情形 objA指向objB，而objB又指向objA，这样当其他所有的引用都消失了之后，objA和objB还有一个相互的引用，也就是说两个对象的引用计数器各为1，而实际上这两个对象都已经没有额外的引用，已经是垃圾了。</p><h3 id="2-1-2-根搜索算法"><a href="#2-1-2-根搜索算法" class="headerlink" title="2.1.2 根搜索算法"></a>2.1.2 根搜索算法</h3><p>   根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。<br>   目前java中可作为GC Root的对象有：<br>   1、    虚拟机栈中引用的对象（本地变量表）<br>   2、    方法区中静态属性引用的对象<br>   3、    方法区中常量引用的对象<br>   4、    本地方法栈中引用的对象（Native对象）</p><h2 id="2-2-垃圾回收算法"><a href="#2-2-垃圾回收算法" class="headerlink" title="2.2 垃圾回收算法"></a>2.2 垃圾回收算法</h2><p>对于收集到的垃圾，JVM是采用什么算法进行回收的呢？主要有这么几种：</p><ul><li>标记-清除算法</li><li>复制算法</li><li>标记-整理算法</li></ul><h3 id="2-2-1-标记清除算法"><a href="#2-2-1-标记清除算法" class="headerlink" title="2.2.1 标记清除算法"></a>2.2.1 标记清除算法</h3><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如图所示。<br>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片！<br><img src="http://blog-yee.qiniudn.com/jvm%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpg" alt="标记清除算法"></p><h3 id="2-2-2-复制算法"><a href="#2-2-2-复制算法" class="headerlink" title="2.2.2 复制算法"></a>2.2.2 复制算法</h3><p> 复制算法采用从根集合扫描，并将存活对象复制到一块新的，没有使用过的空间中，这种算法当控件存活的对象比较少时，极为高效，但是带来的成本是需要一块内存交换空间用于进行对象的移动<br> <img src="http://blog-yee.qiniudn.com/jvm%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.jpg" alt="复制算法"></p><h3 id="2-2-3-标记整理算法"><a href="#2-2-3-标记整理算法" class="headerlink" title="2.2.3 标记整理算法"></a>2.2.3 标记整理算法</h3><p> 标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。<br> <img src="http://blog-yee.qiniudn.com/jvm%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.jpg" alt="标记整理算法"></p><h2 id="3-JVM-常见垃圾回收器"><a href="#3-JVM-常见垃圾回收器" class="headerlink" title="3. JVM 常见垃圾回收器"></a>3. JVM 常见垃圾回收器</h2><p>为了达到最优效果，JVM分别针对新生代和旧生代实现了不同的垃圾回收器。如图：<br><img src="http://blog-yee.qiniudn.com/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%B1%87%E6%80%BB.jpg" alt="垃圾回收器"></p><h3 id="3-1-串行回收器（Serial）"><a href="#3-1-串行回收器（Serial）" class="headerlink" title="3.1 串行回收器（Serial）"></a>3.1 串行回收器（Serial）</h3><p>Serial收集器是历史最悠久的一个回收器，JDK1.3之前广泛使用这个收集器，目前也是ClientVM下 ServerVM 4核4GB以下机器的默认垃圾回收器。串行收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需要中断所有的用户线程，知道它回收结束为止，因此又号称“Stop The World”的垃圾回收器。</p><h3 id="3-2-ParNew回收器"><a href="#3-2-ParNew回收器" class="headerlink" title="3.2   ParNew回收器"></a>3.2   ParNew回收器</h3><p>ParNew收集器其实就是多线程版本的Serial收集器，同样有<br>Stop The World的问题，他是多CPU模式下的首选回收器（该回收器在单CPU的环境下回收效率远远低于Serial收集器，所以一定要注意场景哦），也是Server模式下的默认收集器。</p><h3 id="3-3-ParallelScavenge"><a href="#3-3-ParallelScavenge" class="headerlink" title="3.3 ParallelScavenge"></a>3.3 ParallelScavenge</h3><p>ParallelScavenge又被称为是吞吐量优先的收集器。</p><h3 id="3-4-SerialOld"><a href="#3-4-SerialOld" class="headerlink" title="3.4 SerialOld"></a>3.4 SerialOld</h3><p>SerialOld是旧生代Client模式下的默认收集器，单线程执行；在JDK1.6之前也是ParallelScvenge回收新生代模式下旧生代的默认收集器，同时也是并发收集器CMS回收失败后的备用收集器。</p><h3 id="3-5-ParallelOld"><a href="#3-5-ParallelOld" class="headerlink" title="3.5 ParallelOld"></a>3.5 ParallelOld</h3><p>ParallelOld是老生代并行收集器的一种，使用标记整理算法、是老生代吞吐量优先的一个收集器。这个收集器是JDK1.6之后刚引入的一款收集器，早期没有ParallelOld之前，吞吐量优先的收集器老生代只能使用串行回收收集器，大大的拖累了吞吐量优先的性能，自从JDK1.6之后，才能真正做到较高效率的吞吐量优先。</p><h3 id="3-6-CMS"><a href="#3-6-CMS" class="headerlink" title="3.6 CMS"></a>3.6 CMS</h3><p>CMS又称响应时间优先(最短回收停顿)的回收器，使用并发模式回收垃圾，使用标记-清除算法，CMS对CPU是非常敏感的，它的回收线程数=（CPU+3）/4，因此当CPU是2核的实惠，回收线程将占用的CPU资源的50%，而当CPU核心数为4时仅占用25%。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步处理窥探</title>
      <link href="/2014/03/06/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%AA%A5%E6%8E%A2/"/>
      <url>/2014/03/06/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E7%AA%A5%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>用过微信网页版的人应该都清楚网页登陆的流程，大致描述一下这个过程：</p><ol><li>打开网页版登陆<a href="https://wx.qq.com/" target="_blank" rel="noopener">链接</a></li><li>页面会显示一个二维码</li><li>用微信客户端扫描二维码，让用户确认登陆网页版</li><li>如果确认登陆，网页版会自动进入聊天界面。</li></ol><p>这个过程的交互方式和一般的WEB应用不太一样，<code>步骤4</code>网页自动跳转，明显是由服务端主动推送了内容给网页端，网页端收到跳转确认后才触发的，这里就引出了今天要讨论的问题：<code>服务端推送技术</code>。服务端推送又称为Comet，服务端异步处理等。很早以前就出现了，但一直没有一个统一的标准，存在着不少Comet技术框架，各个Web容器也各自实现了自己的Comet支持。最近公司的产品也出现了和微信网页版登陆类似的场景，需要用到Comet技术，我简单的研究了下，写下来记录一下。</p><p>针对Comet技术的选择性蛮多，我匆匆看了一下，就有这么3个方案：</p><ul><li><p>Tomcat 内置支持，需要实现CometProcessor接口。但是应用就依赖Tomcat容器了。</p></li><li><p>Servlet3 天然支持，Servlet3提供一套完整的异步处理API，包括AsyncContext,AsyncLiseter,AsyncEvent. 要求Tomcat7.0++。</p></li><li><p>SpringMVC3.2 在Servlet3的基础上做了进一步的封装，编码更为简单，提供Callable，WebAsyncTask，DeferredResult三种方式进行异步编程支持，非常方便。</p></li></ul><p>基于Tomcat的CometProcessor依赖性过大，我基本上不予考虑了。因为时间还算充裕，所以我分别针对Servlet3 和SpringMVC3.2 都做了尝试，其实过程都比较简单，关键是要理解场景。我来介绍下我们产品的实际场景吧，我们要实现的一个功能是扫描动态二维码关注微信公众账号。基本流程是这样的：</p><ol><li>客户端调用服务端接口获取动态二维码以及二维码内容中内置的ID。（这个时候在客户端能看到一个二维码了，等待用户扫描）</li><li>客户端马上调用服务端的一个长连接接口，与服务端建立长连接，等待服务端通知。（这个过程是在后台发生的，用户无法感知）</li><li>用户拿出微信扫描二维码，就会有一个扫描事件通知到服务端的扫描接口。（这个时候服务端接收到扫描动作，完成自己的业务操作以后，通知长连接接口，用户已经扫描了，可以返回了）。</li></ol><p>这个流程里面有这么几个地方是需要能解决的：</p><ol><li>步骤2里面要求客户端–服务端建立长连接，不会立即返回，客户端一直在等待状态。（Servlet3 的API可以支持，需要把Timeout时间设置长一点，一般是60S够了）</li><li>步骤3中 扫描接口要通知长连接接口，如何做到？  必须存在一个公共的容器，容器里面存着上下文信息，扫描接口把执行完毕的上下文告知长连接接口就可以了。</li></ol><p>所以，实现代码如下：</p><h1 id="配置部分"><a href="#配置部分" class="headerlink" title="配置部分"></a>配置部分</h1><p>web.xml  启用Servlet3 的命名空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">    xmlns:web=&quot;http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">    id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>长连接Servlet要开启异步支持：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(value = &quot;/scan/*&quot;,asyncSupported = true)</span><br></pre></td></tr></table></figure><p>Tomcat server.xml要开启NIO模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="line">     connectionTimeout=&quot;20000&quot; asyncTimeout=&quot;150000&quot;  URIEncoding=&quot;utf-8&quot;  redirectPort=&quot;8443&quot; /&gt;</span><br></pre></td></tr></table></figure><h1 id="长连接Servlet实现"><a href="#长连接Servlet实现" class="headerlink" title="长连接Servlet实现"></a>长连接Servlet实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(value = &quot;/scan/*&quot;,asyncSupported = true)</span><br><span class="line">public class ScanServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">   // private ScanRetain retain;</span><br><span class="line"></span><br><span class="line">    private Logger logger = Logger.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init() throws ServletException &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        ScanRetain.MAP.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        logger.debug(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始访问长连接Servlet.....&quot;);</span><br><span class="line">        String pathInfo = req.getPathInfo();</span><br><span class="line">        String key = null;</span><br><span class="line">        if (pathInfo != null) &#123;</span><br><span class="line">            int i = pathInfo.lastIndexOf(&apos;/&apos;);</span><br><span class="line">            if (i &gt;= 0) &#123;</span><br><span class="line">                key = pathInfo.substring(i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            PrintWriter writer = resp.getWriter();</span><br><span class="line">            writer.write(&quot;error:not found scan key&quot;);</span><br><span class="line">            writer.flush();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        req.startAsync(req, resp);</span><br><span class="line">        if (req.isAsyncStarted()) &#123;</span><br><span class="line">            final AsyncContext asyncContext = req.getAsyncContext();</span><br><span class="line">            final String theKey = key;</span><br><span class="line">            asyncContext.setTimeout(60 * 1000L);</span><br><span class="line"></span><br><span class="line">            asyncContext.addListener(new AsyncListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onComplete(AsyncEvent asyncEvent) throws IOException &#123;</span><br><span class="line">                    ScanRetain.MAP.remove(theKey);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onTimeout(AsyncEvent asyncEvent) throws IOException &#123;</span><br><span class="line">                    ScanRetain.MAP.remove(theKey);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onError(AsyncEvent asyncEvent) throws IOException &#123;</span><br><span class="line">                    ScanRetain.MAP.remove(theKey);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onStartAsync(AsyncEvent asyncEvent) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            logger.debug(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;将长连接上下文对象加入队列等待处理.........&quot;);</span><br><span class="line">            ScanRetain.MAP.put(theKey, asyncContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="公共Context容器存放类以及提供给扫描后对长连接响应处理的逻辑"><a href="#公共Context容器存放类以及提供给扫描后对长连接响应处理的逻辑" class="headerlink" title="公共Context容器存放类以及提供给扫描后对长连接响应处理的逻辑"></a>公共Context容器存放类以及提供给扫描后对长连接响应处理的逻辑</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ScanRetain &#123;</span><br><span class="line"></span><br><span class="line">    // 公共上下文容器</span><br><span class="line">    public static final ConcurrentHashMap&lt;String, AsyncContext&gt; MAP = new ConcurrentHashMap&lt;String, AsyncContext&gt;();</span><br><span class="line"></span><br><span class="line">    private Logger logger = Logger.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    public void doReturn(String key)&#123;</span><br><span class="line">        logger.debug(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;长连接正在响应.....&quot;);</span><br><span class="line">        AsyncContext asyncContext = MAP.get(key);</span><br><span class="line">        if (asyncContext == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        HttpServletResponse res = (HttpServletResponse) asyncContext.getResponse();</span><br><span class="line">        DBObject data = new BasicDBObject(&quot;result&quot;,1)</span><br><span class="line">                .append(&quot;info&quot;,&quot;ok&quot;)</span><br><span class="line">                .append(&quot;now&quot;,System.currentTimeMillis());</span><br><span class="line">        String str = JSON.serialize(data);</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            os = res.getOutputStream();</span><br><span class="line">            os.write(str.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            logger.debug(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;长连接响应完毕.....&quot;);</span><br><span class="line">            os.flush();</span><br><span class="line">            asyncContext.setTimeout(100L);// 一定要加这一句才会及时返回</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扫描事件触发长连接响应的逻辑"><a href="#扫描事件触发长连接响应的逻辑" class="headerlink" title="扫描事件触发长连接响应的逻辑"></a>扫描事件触发长连接响应的逻辑</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Long senceId = 0L;</span><br><span class="line">if (qrSenceId != null) &#123;</span><br><span class="line">    senceId = Long.parseLong(qrSenceId);</span><br><span class="line">&#125;</span><br><span class="line">scanRetain.doReturn(senceId + &quot;&quot;);</span><br></pre></td></tr></table></figure><p>SpringMVC3.2 的实现我也尝试了一下：<br>长连接接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 上下文容器</span><br><span class="line">  public static final ConcurrentHashMap&lt;String, DeferredResult&lt;String&gt;&gt; MAP = new ConcurrentHashMap&lt;String, DeferredResult&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;doScan/&#123;key&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public DeferredResult&lt;String&gt; doScan(@PathVariable(&quot;key&quot;) String key) &#123;</span><br><span class="line">        DeferredResult&lt;String&gt; result = new DeferredResult&lt;String&gt;();</span><br><span class="line">        MAP.put(key, result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通知长连接响应客户端的测试代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value=&quot;/newScan/&#123;key&#125;&quot;,produces = &quot;text/plain;charset=utf-8;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String newScan(@PathVariable(&quot;key&quot;) String key,</span><br><span class="line">            HttpServletRequest req, HttpServletResponse res) &#123;</span><br><span class="line">        DeferredResult&lt;String&gt; data = Scans.MAP.get(key);</span><br><span class="line">        if(data!=null)&#123;</span><br><span class="line">            data.setResult(&quot;this is result:&quot;+System.currentTimeMillis());</span><br><span class="line">            Scans.MAP.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;new scan test finished :&quot;+key+&quot;now is :&quot;+System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Spring的代码实现简单很多，但是也不那么直观，不利于理解。</p><p>同时，它还提供另外两种异步处理的方式，只是不适于这个场景，这里也罗列一下。<br>Callable：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">   @RequestMapping(&quot;call&quot;)</span><br><span class="line">   public Callable&lt;String&gt; call(HttpServletRequest req, HttpServletResponse res) throws Exception &#123;</span><br><span class="line">       return new Callable&lt;String&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public String call() throws Exception &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               return &quot;hello,callable&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>WebAsyncTask:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@ResponseBody</span><br><span class="line">   @RequestMapping(&quot;async&quot;)</span><br><span class="line">   public WebAsyncTask&lt;String&gt; async(HttpServletRequest req, HttpServletResponse res) throws Exception &#123;</span><br><span class="line">       Callable&lt;String&gt; callable = new Callable&lt;String&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public String call() throws Exception &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(5);</span><br><span class="line">               return &quot;hello,WebAsyncTask&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       return new WebAsyncTask&lt;String&gt;(1000*60L,callable);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面两种方式也是用于异步操作的，它们比较适用于一些比较耗时的操作（如大数据计算，文件处理），它们的响应一般不存在其他的触发点，就是取决于Callable内部代码块的执行结束。</p><p>综上，我们大致可以总结出异步处理的两种应用场景：</p><h3 id="1-多点操作，单点的响应往往依赖于其他点的触发，最典型的就是微信扫描登录了。这个基本的编码思路应该是这样的："><a href="#1-多点操作，单点的响应往往依赖于其他点的触发，最典型的就是微信扫描登录了。这个基本的编码思路应该是这样的：" class="headerlink" title="1. 多点操作，单点的响应往往依赖于其他点的触发，最典型的就是微信扫描登录了。这个基本的编码思路应该是这样的："></a>1. 多点操作，单点的响应往往依赖于其他点的触发，最典型的就是微信扫描登录了。这个基本的编码思路应该是这样的：</h3><ul><li><p>定义一个上下文存储容器，容器要支持并发，最好选用Concurrent类型。</p></li><li><p>开发长连接接口，客户端请求连接后，将上下文加入存储容器。</p></li><li><p>开发响应的触发逻辑代码段。</p></li><li><p>触发业务完成以后，调用响应触发逻辑。</p></li></ul><h3 id="2-单点操作，但是操作往往非常耗时，不能及时响应。这种场景一般会把耗时操作全部抽离到Callable代码段，响应的触发点就是Callable代码的结束处。"><a href="#2-单点操作，但是操作往往非常耗时，不能及时响应。这种场景一般会把耗时操作全部抽离到Callable代码段，响应的触发点就是Callable代码的结束处。" class="headerlink" title="2. 单点操作，但是操作往往非常耗时，不能及时响应。这种场景一般会把耗时操作全部抽离到Callable代码段，响应的触发点就是Callable代码的结束处。"></a>2. 单点操作，但是操作往往非常耗时，不能及时响应。这种场景一般会把耗时操作全部抽离到Callable代码段，响应的触发点就是Callable代码的结束处。</h3>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步 </tag>
            
            <tag> Servlet3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql常见调优</title>
      <link href="/2014/02/23/mysql%E5%B8%B8%E8%A7%81%E8%B0%83%E4%BC%98/"/>
      <url>/2014/02/23/mysql%E5%B8%B8%E8%A7%81%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<p><code>MySQL</code>作为最常用的关系型数据库之一，在一些中小型项目中使用的极为普遍。我所在公司对于数据库的选择，在关系型范围内也一直使用它，本文尝试着总结一下在使用过程中积累的一些优化技巧。在我们使用的过程中，我们觉得可以从3个维度探讨一下MySQL可能存在的优化点。</p><ul><li><p>数据结构设计时，数据类型的选择</p></li><li><p>代码开发过程中，索引的维护和SQL语句的编写</p></li><li><p>数据库维护过程中，参数的调整和及时的维护</p></li></ul><ol><li><h1 id="选择正确的数据类型"><a href="#选择正确的数据类型" class="headerlink" title="选择正确的数据类型"></a>选择正确的数据类型</h1></li></ol><p>说到Mysql的数据类型，我们先来整体看看，了解一下各种数据类型的特性，以及它们各自的使用场景。宏观来说，Mysql的数据类型分为几个大类，大类下面又各自分为各种小类，魔鬼就藏在这些小类中，就是小类之间各种细微的差别，能给出完全不同的性能状况。<br>Mysql的数据大类可以分为<code>整形，浮点型，字符串，日期，集合</code>，完全能满足我们存储数据的需要了，下面来逐一看看这些细节。</p><h4 id="1-1-整形"><a href="#1-1-整形" class="headerlink" title="1.1 整形"></a>1.1 整形</h4><p>Mysql中整形有这么几类:</p><ul><li><p>tinyInt<br> 1个字节，范围：（-128-127 | 0-255）</p></li><li><p>smallInt<br> 2 字节，范围：(-32 768，32 767) (0，65 535) </p></li><li><p>mediumInt<br>3 字节 ，范围：(-8 388 608，8 388 607) (0，16 777 215) </p></li><li><p>int<br> 4 字节，范围： (-2 147 483 648，2 147 483 647) (0，4 294 967 295) </p></li></ul><ul><li>bigInt<br>8 字节 ，范围：(-9 233 372 036 854 775 808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) </li></ul><p>对于大部分人来说，设计数据结构的时候，如果选择整形最顺手的就是直接 <code>int</code> 了对不对，其实很大一部分场景是不需要这么浪费的，例如我们常用的字段有<code>类型，状态</code>等，这些字段往往只有几个值，是可遍历的，用<code>tinyInt</code>就可以满足需求，而带来的好处就是更省存储空间，更快的查询性能。</p><h4 id="1-2-浮点型"><a href="#1-2-浮点型" class="headerlink" title="1.2 浮点型"></a>1.2 浮点型</h4><ul><li>FLOAT 4 字节 (-3.402 823 466 E+38，1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度<br>浮点数值</li></ul><ul><li>DOUBLE 8 字节 (1.797 693 134 862 315 7 E+308，2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度<br>浮点数值</li></ul><ul><li>DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 </li></ul><p>对于浮点类型我总是存着一份戒备心理，因为浮点类型的计算往往存在精度丢失的情况，这个问题真的很烦，所以我一般不选择浮点类型作为数据结构类型，即使是有业务需求，我也要用Long类型来替代（通过单位换算）。如果实在要用浮点类型，也优先考虑float.</p><h4 id="1-3-字符串"><a href="#1-3-字符串" class="headerlink" title="1.3 字符串"></a>1.3 字符串</h4><p>MySQL提供了8个基本的字符串类型，可以存储的范围从简单的一个字符到巨大的文本块或二进制字符串数据。</p><ul><li>CHAR 0-255字节 定长字符串</li><li>VARCHAR 0-255字节 变长字符串</li><li>TINYBLOB 0-255字节 不超过 255 个字符的二进制字符串</li><li>TINYTEXT 0-255字节 短文本字符串</li><li>BLOB 0-65 535字节 二进制形式的长文本数据</li><li>TEXT 0-65 535字节 长文本数据</li><li>MEDIUMBLOB 0-16 777 215字节 二进制形式的中等长度文本数据</li><li>MEDIUMTEXT 0-16 777 215字节 中等长度文本数据</li><li>LOGNGBLOB 0-4 294 967 295字节 二进制形式的极大文本数据</li><li>LONGTEXT 0-4 294 967 295字节 极大文本数据 </li></ul><p>这里面真正常用的就是 <code>char 和 varchar</code>了，它们的选择也是很有趣的，一般来说，大家会优先选择 varchar，因为它是可变长度嘛，存储的时候按实际长度存储，省空间。那难道char就没有用武之地了吗，答案当然是否。在一些特定场景下，char反而比varchar更适用。例如我们存储通过MD5加密后的密码，这个数据的长度都是一样的（33位），还有身份证号，手机号等信息，这些数据的共同特点就是长度固定，这个时候用char类型就很适用了。</p><h4 id="1-4-日期类型"><a href="#1-4-日期类型" class="headerlink" title="1.4 日期类型"></a>1.4 日期类型</h4><ul><li><p>DATE 3个字节 1000-01-01/9999-12-31 YYYY-MM-DD 日期值</p></li><li><p>TIME 3个字节  ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间</p></li><li><p>YEAR 1个字节  1901/2155 YYYY 年份值</p></li><li><p>DATETIME 8个字节  8 1000-01-01 00:00:00/9999-12-31 23:59:59 YYYY-MM-DD HH:MM:SS 混合日期和时间值</p></li><li><p>TIMESTAMP 8 个字节 1970-01-01 00:00:00/2037 年某时 YYYYMMDD HHMMSS 混合日期和时间值，时间戳 </p></li></ul><p>日期类型的选择的话还是看具体的业务场景吧，我个人喜欢用TIMESTAMP，因为时间这个字段业务性很强，在统计报表里面对时间维度往往会分得很细，我觉得还是存储全面的信息比较靠谱一些。</p><h4 id="1-5-集合类型"><a href="#1-5-集合类型" class="headerlink" title="1.5  集合类型"></a>1.5  集合类型</h4><ul><li><p>ENUM 类型<br>　　ENUM 类型因为只允许在集合中取得一个值，有点类似于单选项。在处理相互排拆的数据时容易让人理解，比如人类的性别。ENUM 类型字段可以从集合中取得一个值或使用 null值，除此之外的输入将会使 MySQL在这个字段中插入一个空字符串。另外如果插入值的大小写与集合中值的大小写不匹配，MySQL 会自动使用插入值的大小写转换成与集合中大小写一致的值。</p></li><li><p>SET 类型<br>　　SET类型与ENUM类型相似但不相同。SET类型可以从预定义的集合中取得任意数量的值。并且与 ENUM 类型相同的是任何试图在 SET 类型字段中插入非预定义的值都会使 MySQL 插入一个空字符串。如果插入一个即有合法的元素又有非法的元素的记录，MySQL 将会保留合法的元素，除去非法的元素。</p></li></ul><p>这种类型估计大家就用的更少了，我在公司碰到一个牛人用过ENUM，他给的理由和上文提到的tinyInt一致，ENUM类型也适用于<code>状态，类型</code>等可遍历的字段，查询性能会奇高，具体测试我没有做验证，但是这个信息是Mysql官方提供的，所以可以直接用。</p><ol start="2"><li><h1 id="让你的索引用起来，写出真正优雅的SQL"><a href="#让你的索引用起来，写出真正优雅的SQL" class="headerlink" title="让你的索引用起来，写出真正优雅的SQL"></a>让你的索引用起来，写出真正优雅的SQL</h1>索引是查询分析器的指明灯，要想SQL高效，就避不开索引的命中。</li></ol><h4 id="2-1-最左前缀原则"><a href="#2-1-最左前缀原则" class="headerlink" title="2.1 最左前缀原则"></a>2.1 最左前缀原则</h4><p>在实际的开发过程中，索引往往需要作用在多列上（例如根据部门ID+状态来查询员工信息），所以实际情况往往是尽可能对表建立复合索引而非单列索引。因为复合索引的意义相当于符合+单列，例如 索引（a,b,c）就相当建了3个索引：（a),(a,b),(a,b,c). 了解了这一特性，自然而然的就引出了索引的一个最重要的使用原则：<code>最左前缀原则</code>。 只要保证where条件中的查询域是按照索引的最左列开始，就能命中该索引。反之，对于上面提到的索引(a,b,c), （b）, (b,c)是无法命中的。<br>对于<code>最左前缀原则</code>，order操作也同样适用，而且和where部分可以配合使用。例如:<br>select * from table where a = 1 order by b desc, c asc 是可以完全命中索引的。</p><h4 id="2-2-知道哪些情况会无法命中索引"><a href="#2-2-知道哪些情况会无法命中索引" class="headerlink" title="2.2 知道哪些情况会无法命中索引"></a>2.2 知道哪些情况会无法命中索引</h4><ul><li><p>or，union 子句 会导致全表扫描，索引失效</p></li><li><p>!=,&lt;&gt; 操作符会会导致全表扫描，索引失效</p></li><li><p>in, between…and也是应该尽量避免的，同样它们也会造成全表扫描。一般来说，in子句尽量用exists子句代替。</p></li><li><p>索引列中存在null值，也会导致无法命中索引，解决办法是加上 index_col is not null</p></li><li><p>在索引列上使用函数或者运算</p></li><li><p>索引列上存在隐式转换，比如你的SELECT * FROM T WHERE Y = 5 在Y上面有一个索引，但是Y列是VARCHAR的，那么Mysql会将上面的5进行一个隐式的转换，SELECT * FROM T WHERE TO_NUMBER(Y) = 5,这个时候也是有可能用不到索引的。</p></li></ul><h4 id="2-3-其它建议"><a href="#2-3-其它建议" class="headerlink" title="2.3 其它建议"></a>2.3 其它建议</h4><ol><li>表主键尽量采用业务相关的自增长字段，而非业务主键如手机号，身份证号等。</li><li>where子句要主要条件的顺序，尽量将有效过滤条件放在最前面。例如： where sex =’男’ and deptId =’xxxx’ 明显效率不如where deptId =’xxxx’ and  sex =’男’。</li><li>如果碰到非常多表的联合查询，要考虑是不是数据结构设计的问题了。这个时候应该采用中间临时表来实现需求，将需要查询的信息通过后台任务跑到中间表，前端的查询只需要查询临时表就可以了，这样效率会高很多。这种场景常见于订单详情，日志记录等。</li></ol><ol start="3"><li><h1 id="Mysql参数优化"><a href="#Mysql参数优化" class="headerlink" title="Mysql参数优化"></a>Mysql参数优化</h1></li></ol><p>参数优化一般让DBA来干，开发人员基本上不会接触到。我也没有具体实践过，这里有一篇文章，我觉得值得收藏，看看吧。<a href="http://database.51cto.com/art/201103/247839.htm" target="_blank" rel="noopener">链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mongodb索引探索</title>
      <link href="/2014/02/07/mongodb%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2014/02/07/mongodb%E7%B4%A2%E5%BC%95%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>索引是数据库中的一个重要对象，主要用于支持高效查询操作。如果没有索引，数据库就只能进行全表扫描，效率将极为低下。mongodb的索引体系比较庞大，按照索引类型，我准备分这么几个部分来进行阐述：</p><ul><li><p>基本索引</p></li><li><p>Text索引</p></li><li><p>GEO索引</p></li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文将简单介绍常用的基本索引类型，已经索引的相关操作。根据官方的文档，Mongodb有这么几种常见索引：</p><ul><li><p>Default _id 主键索引，默认作用在<code>_id</code>上</p></li><li><p>Single Field 单键索引，针对单个field的索引</p></li><li><p>Compound  复合索引，针对多个field的索引</p></li><li><p>Multikey Index，这个我都不知道怎么翻，多键索引吧，其实就是针对数组子项的索引，因为数组有多个元素，每个元素都可能的key,如果有一个索引A作用在这个key上，这就是所谓的Multikey index  </p></li><li><p>Geospatial Index  针对地理位置信息的索引</p></li><li><p>Text Index  支持全文搜索的索引，2.4才支持</p></li><li><p>Hashed  Index ， To support hash based sharding, MongoDB provides a hashed index (page 22) type, which indexes the hash of the value of a field. </p></li></ul><p>同时，mongodb提供了两个索引的属性： </p><ul><li><p>Unique  唯一性，保证索引作用的field上的value是唯一的。</p></li><li><p>Sparse  稀疏性，如果一个Collection中的某个field A 只存在于某些Document上，而 A 上同时建立了索引，那么用Sparse则会使查询操作直接忽略这些记录。</p></li></ul><p>好了，概念说了很多，来讲一下索引的具体操作吧。创建一个索引很简单，看看下面这些代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 单键索引</span><br><span class="line">db.Student.ensureIndex(&#123;code:1&#125;);</span><br><span class="line"></span><br><span class="line">// 复合索引</span><br><span class="line">db.Student.ensureIndex(&#123;name:1,time:-1&#125;)</span><br><span class="line"></span><br><span class="line">// Multikey Index</span><br><span class="line">db.Student.ensureIndex(&#123;faver.id:1&#125;);</span><br><span class="line"></span><br><span class="line">//  唯一索引</span><br><span class="line">db.Student.ensureIndex(&#123;code:1&#125;,&#123;unique:1&#125;);</span><br><span class="line"></span><br><span class="line">// 唯一索引同时删除重复值</span><br><span class="line">db.Student.ensureIndex(&#123;code:1&#125;,&#123;unique:1,dropDups:1&#125;);</span><br><span class="line"></span><br><span class="line">// 唯一稀疏索引</span><br><span class="line">db.Student.ensureIndex(&#123;code:1&#125;,&#123;unique:1,sparse:1&#125;);</span><br></pre></td></tr></table></figure><p>获取一个Collection上面的集合信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 单个Collection</span><br><span class="line">db.Student.getIndexes();</span><br><span class="line"></span><br><span class="line">// DB中所有的Index</span><br><span class="line">db.system.indexes.find();</span><br></pre></td></tr></table></figure><p>删除索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 删除在某个field上面的索引</span><br><span class="line">db.Student.dropIndex(&#123;name:1&#125;);</span><br><span class="line"></span><br><span class="line">// 根据索引名删除</span><br><span class="line">db.system.indexes.remove(&#123;name:&quot;code_-1&quot;&#125;)</span><br></pre></td></tr></table></figure><p>如何修改索引呢？没有特定修改命令，一般是先删除，然后创建新的索引。</p><p>系统运行一段时间以后，随着数据的累加，业务需求的变化，可能会需要对索引进行重建(rebuild)，则可以做这个操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.reIndex()</span><br></pre></td></tr></table></figure><p>rebuild会先删除集合上的所有索引，包括_id索引，然后重建。这种操作往往和耗时，最好在系统资源充足的时候做。</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><h3 id="1-限制"><a href="#1-限制" class="headerlink" title="1. 限制"></a>1. 限制</h3><p>mongodb对索引的使用和管理也有一些限制</p><ul><li><p>索引key的总容量不能大于1024byte,否则以后的索引将创建不了</p></li><li><p>单个集合不能超过64个索引</p></li><li><p>单个索引的名字长度（包括命名空间）不能超过125 个字符</p></li><li><p>复合索引最多只能作用在31个field上</p></li><li><p>一个查询不能同时使用text and Geospatial 索引</p></li></ul><p>上面列的只是一些大的限制，在具体场景中还有很多索引相互冲突，或者使用不当造成索引无法命中的情况，所以还要看看更细节的一些东西。</p><h3 id="2-使用策略"><a href="#2-使用策略" class="headerlink" title="2. 使用策略"></a>2. 使用策略</h3><h4 id="2-1-id-主键索引"><a href="#2-1-id-主键索引" class="headerlink" title="2.1 _id 主键索引"></a>2.1 _id 主键索引</h4><p>这个是系统自动创建的，不能删除，除非你Drop掉整个Collection。这个效率是非常高的，对于一些数据量很大，但是没有排序需求的集合（如日志表），在分页策略上应该使用_id来进行分页。</p><h4 id="2-2-single-单键索引"><a href="#2-2-single-单键索引" class="headerlink" title="2.2 single  单键索引"></a>2.2 single  单键索引</h4><p>mongodb 不限制你在任何field上面创建单键索引，但是一个查询一次只能使用一个索引（$or子句可以使用多个），所以看看下面的情况会是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//存在两个索引：</span><br><span class="line">&#123;code:1&#125;，</span><br><span class="line">&#123;name:1&#125;</span><br><span class="line"></span><br><span class="line">//这里mongodb只会命中一个索引，具体是哪个由查询分析器决定</span><br><span class="line">db.Student.find(&#123;code:&#123;$lt:10&#125;,name:&#123;$regex:/^a/&#125;&#125;).explain();</span><br><span class="line">&#123;</span><br><span class="line">    &quot;cursor&quot; : &quot;BtreeCursor name_1&quot;,</span><br><span class="line">    &quot;isMultiKey&quot; : false,</span><br><span class="line">    &quot;n&quot; : 1,</span><br><span class="line">    &quot;nscannedObjects&quot; : 1,</span><br><span class="line">    &quot;nscanned&quot; : 1,</span><br><span class="line">    &quot;nscannedObjectsAllPlans&quot; : 4,</span><br><span class="line">    &quot;nscannedAllPlans&quot; : 4,</span><br><span class="line">    &quot;scanAndOrder&quot; : false,</span><br><span class="line">    &quot;indexOnly&quot; : false,</span><br><span class="line">    &quot;nYields&quot; : 0,</span><br><span class="line">    &quot;nChunkSkips&quot; : 0,</span><br><span class="line">    &quot;millis&quot; : 46,</span><br><span class="line">    &quot;indexBounds&quot; : &#123;</span><br><span class="line">        &quot;name&quot; : [</span><br><span class="line">            [</span><br><span class="line">                &quot;a&quot;,</span><br><span class="line">                &quot;b&quot;</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;server&quot; : &quot;pormatoMacBook-Pro.local:27017&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引还存在排序问题，<code>{a:1}升序 / {a:-1}降序</code>，但是对于单键索引，排序的时候升序降序都会命中。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.Student.find().sort(&#123;name:1&#125;);</span><br><span class="line">db.Student.find().sort(&#123;name:-1&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-3-复合索引"><a href="#2-3-复合索引" class="headerlink" title="2.3 复合索引"></a>2.3 复合索引</h4><p>多数情况下，应该考虑复合索引而非单键索引，因为复合索引会包含部分单键索引。例如：<br>对于索引：<br><code>{a:1,b:1,c:1}</code><br>相当于该集合拥有了：<br><code>{a:1}</code>  , <code>{a:1,b:1}</code> , <code>{a:1,b:1,c:1}</code><br>但是：<br><code>{b:1}</code> ,<code>{c:1}</code> , <code>{b:1,c:1}</code> 是无法命中的。</p><p>如果排序也希望命中索引的话，这里分为两种情况:</p><ul><li><p>排序字段以索引开始键开头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 因为查询条件中不存在索引开始键（a:1），要想命中索引，排序必须以索引开始键开头</span><br><span class="line">db.mycoll.find(&#123;b:&#123;$gt:1&#125;&#125;).sort(&#123;a:1,b:1,c:1&#125;);</span><br></pre></td></tr></table></figure></li><li><p>排序字段不以索引开始键开头</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycoll.find(&#123;a:&#123;$gt:1&#125;&#125;).sort(&#123;b:1,c:1&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>当然，排序里面还有更为细致的问题，就是查询条件如果有索引field的精准匹配（equal）,则排序也能更简单:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.mycoll.find(&#123;a:1&#125;).sort(&#123;b:1&#125;);</span><br></pre></td></tr></table></figure><p>同样，复合索引也存在索引反序问题,这里和单键索引一样，只有完全反序才能命中：<br>对于索引<code>{a:1,b:-1}</code>,  <code>{a:-1,b:1}</code> 是可以命中的，反过来也成立。但是：<code>{a:1,b:1}</code>或者<code>{a:-1,b:-1}</code>是无法命中索引的。</p><h3 id="3-MultiKey-Index-多键索引"><a href="#3-MultiKey-Index-多键索引" class="headerlink" title="3 MultiKey Index 多键索引"></a>3 MultiKey Index 多键索引</h3><p>多键索引是作用在 array field上的element中的某个field上的索引。这个没有太多的特别之处，唯一要注意的是，如果一个索引是<code>复合多键索引</code>,那么这个索引的field中只能有一个array类型。例如：<br><code>{a:1,b:[{b1:1,b2:1}]</code> 这个是Ok的， <code>{a:[a1:1,a2:1],b:[{b1:1,b2:1}]</code> 这种索引则是非法的。</p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><p>mongdb中还存在一种Cover Index的说法。它发生在如下的情况中：</p><ul><li><p>all the fields in the query are part of an index, <code>and</code></p></li><li><p>all the fields returned in the results are in the same index.</p></li></ul><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">db.mycoll.find(&#123;a:&#123;$lt:100&#125;&#125;,&#123;a:1,_id:0&#125;&#125;);</span><br></pre></td></tr></table></figure><p>这个时候查询条件的field和 查询域field 完全一样，并且这个field刚好能命中索引的话，这个查询效率将非常的高，因为mongodb不会再去硬盘进行扫描，而是直接将Index信息返回。</p><p>这里需要知道的是如果在下面两种情况下，Cover Index将无法生效</p><ul><li><p>any of the indexed fields in any of the documents in the collection includes an array. If an indexed field is an array, the index becomes a multi-key index , index and cannot support a covered query.<br>数组field将直接会使索引变为多键索引</p></li><li><p>any of the indexed fields are fields in subdocuments. To index fields in subdocuments, use dot notation.<br>查询域总是会返回整个子文档的root节点</p></li></ul><p>基本的索引类型就是这么多了，接下来还有Text , Geo ,hash等较为复杂的索引类型，这个在以后的文章中再来分析。 </p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建自己的轻量级文件服务器</title>
      <link href="/2014/02/06/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2014/02/06/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>现在的WEB应用基本上都离不开文件服务器，各种图片，视频，文档等资源文件的存取一直WEB应用的一部分，对于这种资源的处理一般是通过独立的一个文件服务器来进行处理，文件服务器会提供upload，download等操作分别进行文件的存储和获取，比较完备的还会提供delete操作，但是一般不需要。<br>我希望用Java构建一个轻量级的文件服务器应用，这个应用要能满足这么几个需求：</p><ul><li><p>最少依赖，最好只依赖Web容器（例如Tomcat）环境      </p></li><li><p>对外接口至简       </p></li><li><p>相对成熟，上传操作使用标准表单模式，下载操作支持断点续传   </p></li></ul><p>对于这些需求，我是这么考量的：</p><h3 id="1-依赖性"><a href="#1-依赖性" class="headerlink" title="1. 依赖性"></a>1. 依赖性</h3><p>java处理文件上传往往需要引入一个<code>org.apache.commons.fileupload-1.2.0.jar</code>这个依赖库，就算引入了还是有一堆的API调用要去写，比较繁琐，<code>SpringMVC</code>在它的基础上做了进一步的封装，相对比较好用了。但是引入Spring就重了，这个不予考量。<br>如果不想引入第三方的lib，<code>Servlet3</code>给了非常好的解决方案，只是要求Web容器支持<code>Servlet3（Tomcat7.0++）</code>。这个就确认使用<code>Servlet3</code>了。</p><h3 id="2-简易性"><a href="#2-简易性" class="headerlink" title="2. 简易性"></a>2. 简易性</h3><p>接口的简易性我希望的目标是这么想的，尽量简单，尽量做到不依赖参数信息。</p><h4 id="2-1-对于upload接口"><a href="#2-1-对于upload接口" class="headerlink" title="2.1 对于upload接口"></a>2.1 对于upload接口</h4><ul><li><p>支持多文件批量上传   </p></li><li><p>不依赖文件参数名，客户端上传时可以任意命名文件名参数</p></li></ul><h4 id="2-2-对于download接口"><a href="#2-2-对于download接口" class="headerlink" title="2.2 对于download接口"></a>2.2 对于download接口</h4><ul><li><p>客户获取文件时只需要传入文件名参数即可</p></li><li><p>支持<code>Rest</code>风格。（我发现Servlet的url-pattern不支持正则表达式，无法天然支持这种风格，现在是通过编码解析Url进行实现的）</p></li></ul><h4 id="2-3-成熟性"><a href="#2-3-成熟性" class="headerlink" title="2.3 成熟性"></a>2.3 成熟性</h4><p>对于成熟性的考虑我主要是考虑通用。<code>upload</code>就是使用标准的表单上传处理，这个大家最容易理解，表单是很视觉化的东西嘛，测试也方便。<code>download</code>最基本的就是要支持断点续传，因为有的视频文件可能比较大，下载需要一点时间，如果网络中断了，在下次在线的时候能继续下载而不用重新来过。还有就是现在一些Html5的音频，视频组件对于源的要求也是断点续传的兼容性是最好的，这个在公司的产品中有测试过，简单的Servlet有时候这些HTML5组件识别不了，或者报一些莫名其妙的错误（例如音频不能重复播放，或者压根不能播放）。而支持断点续传的Servlet基本上没有问题。</p><p>好了，做了这么多铺垫，我直接上代码吧。</p><h1 id="Upload"><a href="#Upload" class="headerlink" title="Upload "></a>Upload </h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/upload&quot;)</span><br><span class="line">@MultipartConfig(location = Defs.temp_path, maxRequestSize = 1024L * 10000)</span><br><span class="line">public class UploadServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        resp.reset();</span><br><span class="line">        resp.setContentType(&quot;text/plain; charset=utf-8&quot;);</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        writer.write(&quot;不支持Get操作！&quot;);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        req.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        Collection&lt;Part&gt; parts = null;</span><br><span class="line">        resp.reset();</span><br><span class="line">        resp.setContentType(&quot;text/plain; charset=utf-8&quot;);</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        // 获取上传的文件列表，Part对象就是Servlet3对文件上传支持中对文件数据的抽象结构</span><br><span class="line">        try &#123;</span><br><span class="line">            parts = req.getParts();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;======&gt;get file part error&quot;);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            writer.write(&quot;上传文件出现错误！&quot; + e.getMessage());</span><br><span class="line">            writer.flush();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(parts == null || parts.isEmpty())&#123;</span><br><span class="line">            writer.write(&quot;上传文件为空！&quot;);</span><br><span class="line">            writer.flush();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; fileNameList = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (Part part : parts) &#123;</span><br><span class="line">            if(part == null)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            FileUtil.logPartInfo(part);</span><br><span class="line">            String fileName = FileUtil.getFileName(part);</span><br><span class="line">            String ext = FileUtil.getFileExt(fileName);</span><br><span class="line">            InputStream is = part.getInputStream();</span><br><span class="line">            //创建全局唯一的文件名</span><br><span class="line">            String newName =new ObjectId().toString()+ext;</span><br><span class="line">            String newFileName = Defs.file_path+newName;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 将文件保存指硬盘</span><br><span class="line">                IOUtil.copyInputStreamToFile(is,newFileName);</span><br><span class="line">                fileNameList.add(newName);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String,Object&gt; data = new HashMap&lt;String,Object&gt;();</span><br><span class="line">        data.put(&quot;fileNames&quot;,fileNameList);</span><br><span class="line">        data.put(&quot;result&quot;,1);</span><br><span class="line">        writer.write(data.toString());</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上传的逻辑很简单，基本上没有注释的必要。稍微提一下文件名的产生机制，我这里偷了个懒，直接套用了mongodb的ObjectId来生成。这里在依赖性方面做了妥协，但是我只把ObjectId的源码给拷贝过来，所以还可以接受。为啥要用ObjectId来产生文件名，主要是它很好的做到了分布式环境中同一时间的产生的差异性。一个ObjectId由 时间戳+机器码+进程号+计数器组成，简单而强大，我懒得重复造轮子了，这里直接移过来。</p><h1 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/download/*&quot;)</span><br><span class="line">public class DownloadServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        String fileName=null;</span><br><span class="line">        String requestUri = req.getRequestURI();</span><br><span class="line">        int lastIndex = requestUri.lastIndexOf(&quot;/&quot;);</span><br><span class="line">        if (lastIndex &gt; 0) &#123;</span><br><span class="line">            fileName = requestUri.substring(lastIndex + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (fileName == null || fileName.trim().length() == 0) &#123;</span><br><span class="line">            resp.reset();</span><br><span class="line">            resp.setContentType(&quot;text/plain;charset=utf-8&quot;);</span><br><span class="line">            PrintWriter writer = resp.getWriter();</span><br><span class="line">            writer.write(&quot;error:can&apos;t get the file name! 不能获取文件名&quot;);</span><br><span class="line">            writer.flush();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        fileName = Defs.file_path + fileName;</span><br><span class="line">        File file = new File(fileName);</span><br><span class="line">        if (!file.exists()) &#123;</span><br><span class="line">            resp.reset();</span><br><span class="line">            resp.setContentType(&quot;text/plain;charset=utf-8&quot;);</span><br><span class="line">            PrintWriter writer = resp.getWriter();</span><br><span class="line">            writer.write(&quot;error: file not exist! 文件不存在&quot;);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        long length = file.length();</span><br><span class="line">        long start = 0;</span><br><span class="line">        resp.reset();</span><br><span class="line">        resp.setHeader(&quot;Accept-Ranges&quot;, &quot;byte&quot;);</span><br><span class="line">        //断点续传的信息就存储在这个Header属性里面： range:bytes=3-100;200 （从3开始，读取长度为100，总长度为200）</span><br><span class="line">        String range = req.getHeader(&quot;Range&quot;);</span><br><span class="line">        if (range != null) &#123;</span><br><span class="line">            //SC_PARTIAL_CONTENT 206 表示服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</span><br><span class="line">            resp.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);</span><br><span class="line">            range = range.substring(&quot;bytes=&quot;.length());</span><br><span class="line">            String[] rangeInfo = range.split(&quot;-&quot;);</span><br><span class="line">            start = new Long(rangeInfo[0]);</span><br><span class="line">            if (start &gt; file.length()) &#123;</span><br><span class="line">                resp.sendError(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (rangeInfo.length &gt; 1) &#123;</span><br><span class="line">                length = Long.parseLong(rangeInfo[1]) - start + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                length = length - start;</span><br><span class="line">            &#125;</span><br><span class="line">            if (length + start &gt; file.length()) &#123;</span><br><span class="line">                length = file.length() - start;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resp.setHeader(&quot;Content-Type&quot;, FileUtil.getMime(fileName));</span><br><span class="line">        resp.setHeader(&quot;Content-Length&quot;, new Long(length).toString());</span><br><span class="line">        if (range != null) &#123;</span><br><span class="line">            resp.setHeader(&quot;Content-Range&quot;, &quot;bytes &quot; + new Long(start).toString() + &quot;-&quot; + new Long(start + length - 1).toString() + &quot;/&quot; + new Long(file.length()).toString());</span><br><span class="line">        &#125;</span><br><span class="line">        resp.setContentType(FileUtil.getMime(fileName));</span><br><span class="line">        resp.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + new String(file.getName().getBytes(), &quot;utf-8&quot;));</span><br><span class="line">        long k = 0;</span><br><span class="line">        int ibuffer = 65536;</span><br><span class="line">        byte[] bytes = new byte[ibuffer];</span><br><span class="line">        FileInputStream fileinputstream = new FileInputStream(file);</span><br><span class="line">        try &#123;</span><br><span class="line">            if (start != 0) &#123;</span><br><span class="line">                fileinputstream.skip(start);</span><br><span class="line">            &#125;</span><br><span class="line">            OutputStream os = resp.getOutputStream();</span><br><span class="line">            while (k &lt; length) &#123;</span><br><span class="line">                int j = fileinputstream.read(bytes, 0, (int) (length - k &lt; ibuffer ? length - k : ibuffer));</span><br><span class="line">                if (j &lt; 1) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                os.write(bytes, 0, j);</span><br><span class="line">                k += j;</span><br><span class="line">            &#125;</span><br><span class="line">            os.flush();</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            fileinputstream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下载的逻辑其实也不复杂，只是很繁琐。我也稍微解释一下。<br>把这段代码翻译成汉语是这样的：</p><ol><li>通过解析Url获取文件名</li><li>判断文件是否存在，及时反馈</li><li>如果文件存在，判断请求的<code>Header</code>信息中是否存在<code>Range</code>信息，分断下载的信息就存储在<code>range</code>里面，这里就需要繁琐的解析 range信息，并于相应的文件信息比较判断，最终获取下载文件的分段起止位置进行下载。</li><li>将读取好文件信息通过<code>byte</code>数组返回。</li></ol><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><p>测试代码的提供也很重要，因为对外发布的接口往往需要提供调用范例。因为是Http请求测试，这里我也偷了个懒，基于<code>httpclient4</code>做了下测试，过程通畅，把代码列一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class TestFileServer &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testUpload() throws Exception &#123;</span><br><span class="line">        String url = &quot;http://127.0.0.1:8080/file/upload&quot;;</span><br><span class="line">        File file = new File(&quot;/Users/por/yee/temp/a.jpg&quot;);</span><br><span class="line">        postFile(file, url);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testDownload() throws Exception &#123;</span><br><span class="line">        String url = &quot;http://127.0.0.1:8080/file/download/52f2f9ac036495c277b2e13d.jpg&quot;;</span><br><span class="line">        HttpClient httpclient = new DefaultHttpClient();</span><br><span class="line">        HttpGet httpGet = new HttpGet(url);</span><br><span class="line">        HttpResponse response = httpclient.execute(httpGet);</span><br><span class="line">        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123;</span><br><span class="line">            HttpEntity entity = response.getEntity();</span><br><span class="line">            byte[] datas = EntityUtils.toByteArray(entity);</span><br><span class="line">            System.out.println(&quot;data_length=&quot;+datas.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String postFile(File file, String url) throws ClientProtocolException, IOException &#123;</span><br><span class="line">        HttpClient httpclient = new DefaultHttpClient();</span><br><span class="line"></span><br><span class="line">        HttpPost httppost = new HttpPost(url);</span><br><span class="line">        FileBody fileBody = new FileBody(file);</span><br><span class="line">        MultipartEntity reqEntity = new MultipartEntity();</span><br><span class="line">        reqEntity.addPart(&quot;data&quot;, fileBody);</span><br><span class="line">        httppost.setEntity(reqEntity);</span><br><span class="line">        System.out.println(&quot;执行: &quot; + httppost.getRequestLine());</span><br><span class="line">        HttpResponse response = httpclient.execute(httppost);</span><br><span class="line">        int statusCode = response.getStatusLine().getStatusCode();</span><br><span class="line">        System.out.println(&quot;statusCode is &quot; + statusCode);</span><br><span class="line">        if (statusCode == 200) &#123;</span><br><span class="line">            HttpEntity resEntity = response.getEntity();</span><br><span class="line">            if (resEntity != null) &#123;</span><br><span class="line">                byte[] resData = EntityUtils.toByteArray(resEntity);</span><br><span class="line">                String content = new String(resData, &quot;utf-8&quot;);</span><br><span class="line">                System.out.println(content);</span><br><span class="line">                return content;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件服务器代码量不大，但是确实WEB应用中不可缺少的一个组成部分。同时，相关的逻辑基本上把Servlet，Http等知识都走了一遍，属于麻雀虽小五脏俱全的知识专区，值得好好探索一下。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> http </tag>
            
            <tag> 文件服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb基础操作及进阶理解</title>
      <link href="/2014/01/28/mongodb%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%8F%8A%E8%BF%9B%E9%98%B6%E7%90%86%E8%A7%A3/"/>
      <url>/2014/01/28/mongodb%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%8F%8A%E8%BF%9B%E9%98%B6%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>从2012年初开始，公司的一些核心产品准备开始陆续迁移到MongoDB上，我们尝试着从一个小产品开始使用，陆续将其他产品迁入，到13年年底，公司产品在数据库选择上基本实现了NoSQL化，除了一些事务性要求较高（如支付）的模块继续停留在Mysql上，基本上现在大家都会偏向于使用MongoDB。就我个人而言，我觉得一些小项目（如后台管理），或者需求变化极快的项目（现今的大部分中小移动互联网产品），如果对于并发要求不高，没有特别强的事务性，业务相对简单，基本上就是一到两人完成的小应用，mongodb应该是是这类应用的首选数据库，我自己的体验的理由如下：</p><ul><li><p>相对于MySQL等关系型数据库，mongodb更为轻量，安装，使用，部署都轻便得多。</p></li><li><p>mongodb 的驱动写得极为成熟，天然的Bson数据结构，使得存取数据都以Map结构进行交互，数据接口非常方便，不需要额外进行数据转换，开发效率明显提升。较为明显的对比就是：如果使用MySQL，往往需要使用一个第三方ORM框架进行DB层的操作，以及Bean映射和数据转换，mongodb完全不需要ORM，原生驱动已经做得非常棒了。</p></li><li><p>相对松散的数据库设计模式，使得它能更好的适应快速变化的需求。当然这一点并不是说用mongodb不需要进行严谨的数据库结构设计了，只是说在需求变更涉及到库表修改的时候，不像MySQL那么纠结要先去弄一下表结构，我才敢部署应用。mongodb基本上没有这个痛感。</p></li><li><p>mongodb 现在的最新稳定版是2.4.8，至此，它提供了相对完善的操作API，而且把Aggregation框架加入以后，原来一直头痛的各种统计操作也有了较好的解决方案，现在可以比较放心的说，MySQL能完成的几乎所有事情，mongodb都能完成。</p></li><li><p>mongodb的文档现在真的好的令人发指啊，应该可以算是业界文档的模范了。</p></li></ul><p>这篇文章主要想介绍一下mongodb的一些基本常用的操作，顺便将一些工作中的处理和理解也提出来，希望能称得上是一篇进阶之作。</p><h3 id="1-insert-插入数据"><a href="#1-insert-插入数据" class="headerlink" title="1. insert,插入数据"></a>1. insert,插入数据</h3><p>insert操作比较简单，mongodb提供了insert, save 方法进行数据插入操作。<br>insert就是普通插入，如果待插入的数据中未含有key:’_d’，mongodb则会自动生成一个类型为ObjectId，key为’_id’的数据作为该条记录的主键，如果已经含有，则只校验一下’_id’是否存在于集合中，未存在则会插入成功，否则会返回一个错误。<br>sava 方法会根据待处理的数据中是否含有key:’_id’进行处理，没有包含则插入数据，包含则根据这个_id更新原有数据。<br>另外，insert方法还可以进行批量操作，只要将需要插入的数据按照数组格式组装传入即可。<br>基本语法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">db.collection.insert(&#123;key:value&#125;);</span><br><span class="line">db.collection.insert([&#123;key:value&#125;,&#123;key:value&#125;...]);</span><br><span class="line">db.collection.save(&#123;key:value&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-remove，删除数据"><a href="#2-remove，删除数据" class="headerlink" title="2. remove，删除数据"></a>2. remove，删除数据</h3><p>remove操作也很简单，只需要把删除条件传入即可。<br>基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(&#123;key:value&#125;);</span><br></pre></td></tr></table></figure><p>如果没有传入任何删除条件，则会删除整个集合。</p><h3 id="3-update，更新数据"><a href="#3-update，更新数据" class="headerlink" title="3. update，更新数据"></a>3. update，更新数据</h3><p>update稍微复杂一些，我们在开发中碰到的关于更新的操作大概有以下三种情况：</p><ul><li>普通更新操作(update.$set|$unset)。  </li><li>原子更新操作(update.$inc)。  </li><li>阻塞查询更新操作(findAndModify.$set|$inc)。  </li><li>数组相关更新操作($push|$pull|$addToSet|$pop 等)。  </li></ul><h4 id="3-1-普通更新操作"><a href="#3-1-普通更新操作" class="headerlink" title="3.1 普通更新操作"></a>3.1 普通更新操作</h4><p>首先来说一下update的基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update( &lt;query&gt;, &lt;update&gt;, &lt;upsert&gt;, &lt;multi&gt; )</span><br></pre></td></tr></table></figure><p>query:更新的查询条件.<br>update: 更新的数据.<br>upsert: 当查询条件没有找到数据时是否插入,默认false.<br>multi:是否更新多条，默认false.<br>这里需要强调一下的是对于选项【update】的处理，如果是更新全文档，则无需特别处理；如果只更新文档中的几个字段，则需要加”$set”进行处理，不然会将文档覆盖掉，在写数据处理脚本的时候要特别注意这些地方。这里提供一个对于【普通更新操作】的示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Student.update(</span><br><span class="line">        &#123;_id:ObjectId(&quot;52e8fce17ee72c8860511af6&quot;)&#125;,</span><br><span class="line">        &#123;&quot;$set&quot;:&#123;&quot;name&quot;:&quot;jay&quot;,&quot;status&quot;:1&#125;&#125;,</span><br><span class="line">        false,</span><br><span class="line">        true</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="3-2-原子更新操作"><a href="#3-2-原子更新操作" class="headerlink" title="3.2 原子更新操作"></a>3.2 原子更新操作</h4><p>mongodb对于自增长的处理是通过$inc来实现的，自增长的过程是原子性的。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Student.update(</span><br><span class="line">        &#123;_id:ObjectId(&quot;52e8fce17ee72c8860511af6&quot;)&#125;,</span><br><span class="line">        &#123;&quot;$inc&quot;:&#123;&quot;age&quot;:3&#125;&#125;,</span><br><span class="line">        false,</span><br><span class="line">        true</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>上面这段代码将Student中的一条记录的age字段自增长了3。<br>如果在一个update操作中，我既有更新部分数据的需求，又希望对某个字段进行自增长操作,还希望删除某个字段，这里的处理就很简单了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.Student.update(</span><br><span class="line">        &#123;_id:ObjectId(&quot;52e8fce17ee72c8860511af6&quot;)&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;$set&quot;:&#123;&quot;name&quot;:&quot;jay&quot;,&quot;status&quot;:1&#125;</span><br><span class="line">            ,&quot;$inc&quot;:&#123;&quot;age&quot;:3&#125;,</span><br><span class="line">            ,&quot;$unset&quot;:&#123;&quot;sex&quot;:1&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        false,</span><br><span class="line">        true</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h4 id="3-3-阻塞查询更新操作"><a href="#3-3-阻塞查询更新操作" class="headerlink" title="3.3 阻塞查询更新操作"></a>3.3 阻塞查询更新操作</h4><p>这里需要提一下mongodb的锁机制了。</p><h5 id="3-3-1-MongoDB-使用的锁"><a href="#3-3-1-MongoDB-使用的锁" class="headerlink" title="3.3.1 MongoDB 使用的锁"></a>3.3.1 MongoDB 使用的锁</h5><p>MongoDB 使用的是“readers-writer”锁， 可以支持并发但有很大的局限性，当一个读锁存在,许多读操作可以使用这把锁，然而, 当一个写锁的存在，一个单一的写操作会 exclusively 持有该锁，同时其它读，写操作不能使用共享这个锁；举个例子，假设一个集合里有 10 个文档，多个 update 操作不能并发在这个集合上，即使是更新不同的文档。</p><h5 id="3-3-2锁的粒度"><a href="#3-3-2锁的粒度" class="headerlink" title="3.3.2锁的粒度"></a>3.3.2锁的粒度</h5><p>在2.2版本以前，mongod只有全局锁；在2.2版本开始，大部分读写操作只锁一个库，相对之前版本，这个粒度已经下降，例如如果一个 mongod 实例上有5个库，如果只对一个库中的一个集合执行写操作，那么在写操作过程中，这个库被锁；而其它5个库不影响。相比RDBMS来说，这个粒度已经算很大了！</p><p>可以看出，mongodb这种锁机制设计得不是很合理，数据到了一定数量级比较容易出现性能问题，所以要特别注意【更新】和【查询】操作。</p><p>我现在的需求是，要在mongodb中获取自增长的Integer类型的主键。利用findAndModify以及mongodb的锁机制可以实现这一需求。findAndModify既是read的操作，又是write的操作，在执行findAndModify时，mongodb会对集合进行writer加锁，其他线程不能进行write操作，操作完毕以后，它同时返回操作后的最新结果，保证read的准确性。这样就保证了每一次只能执行write and read in document的事情。<br>我们在实践中的设计是这么做的：</p><ul><li><p>设计一个Collection，集合名为AutoIds.插入一条数据:{_id:1}.   </p></li><li><p>实现生成自增长并返回主键逻辑,这里用的是java驱动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Integer getNextId(String fieldName) &#123;</span><br><span class="line">       DBCollection autoIdsColl = db.getAutoIdsCollection();</span><br><span class="line">       // _id=1, 确定预先插入的唯一一条记录</span><br><span class="line">       DBObject query = new BasicDBObject(&quot;_id&quot;, 1);</span><br><span class="line">       // 过滤一下查询的 field</span><br><span class="line">       DBObject fields =&#123;_id:1, fieldName:1&#125;;</span><br><span class="line">       // 排序</span><br><span class="line">       DBObject sort = new BasicDBObject(&quot;_id&quot;, 1);</span><br><span class="line">       // 定义每次自增长幅度为1</span><br><span class="line">       update = new BasicDBObject(&quot;$inc&quot;, new BasicDBObject(fieldName, 1));</span><br><span class="line">       // 更新并返回</span><br><span class="line">       DBObject obj = autoIdsColl.findAndModify(query, fields, sort, false, update, true, true);</span><br><span class="line">       // 返回此次更新的Id值</span><br><span class="line">       Integer id = (Integer) obj.get(fieldName);</span><br><span class="line">       return id;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>由上一步可知,AutoIds只有一条记录，理论上可以无限横向扩展，为多个表维护ID，只需要传递不同的ID的key作为getNextId的参数即可。</p></li></ul><p>相对于关系型数据库，mongodb需要绕这么一大圈确实有点说不过去，而且由于锁机制的欠缺，性能还差了一大截，不过在实际业务中，mongodb自带的ObjectId作为主键其实能解决大部分问题，所以也还算能接受。</p><h4 id="3-4-数组更新操作"><a href="#3-4-数组更新操作" class="headerlink" title="3.4 数组更新操作"></a>3.4 数组更新操作</h4><p>数组相关的更新操作在大部分情况下和普通更新操作没有啥特别大的区别，无非就是加了几个操作符。但是也有一些棘手的操作，由于不常用，每次弄的时候总是要回过头来翻文档，所以我这里单独提一下。</p><h5 id="3-4-1-添加一个子项到数组中"><a href="#3-4-1-添加一个子项到数组中" class="headerlink" title="3.4.1 添加一个子项到数组中"></a>3.4.1 添加一个子项到数组中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Student.update(</span><br><span class="line">        &#123;_id:ObjectId(&quot;52e8fce17ee72c8860511af6&quot;)&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;$push&quot;:&#123;&quot;courses&quot;:&#123;&quot;name&quot;:&quot;Math&quot;,&quot;code&quot;:&quot;001&quot;&#125;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        false,</span><br><span class="line">        true</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h5 id="3-4-2-添加多个子项到数组中"><a href="#3-4-2-添加多个子项到数组中" class="headerlink" title="3.4.2 添加多个子项到数组中"></a>3.4.2 添加多个子项到数组中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">db.Student.update(</span><br><span class="line">        &#123;_id:ObjectId(&quot;52e8fce17ee72c8860511af6&quot;)&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;$addToSet&quot;:&#123;&quot;courses&quot;:</span><br><span class="line">                           &#123;&quot;$each&quot;:[ &#123;&quot;name&quot;:&quot;Math&quot;,&quot;code&quot;:&quot;001&quot;&#125;</span><br><span class="line">                                      ,&#123;&quot;name&quot;:&quot;English&quot;,&quot;code&quot;:&quot;002&quot;&#125;</span><br><span class="line">                                    ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        false,</span><br><span class="line">        true</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这里的$addToSet会保证带插入的数组中相同子项只会存在一个，重复的子项也只会插入一次。如果业务需求没有这么严谨，也可以用$push代替。</p><h5 id="3-4-2-移除指定子项"><a href="#3-4-2-移除指定子项" class="headerlink" title="3.4.2 移除指定子项"></a>3.4.2 移除指定子项</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.Student.update(</span><br><span class="line">        &#123;_id:ObjectId(&quot;52e8fce17ee72c8860511af6&quot;)&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;$pull&quot;:&#123;&quot;courses&quot;:&#123;&quot;name&quot;:&quot;Math&quot;,&quot;code&quot;:&quot;001&quot;&#125;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        false,</span><br><span class="line">        true</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><h5 id="3-4-2-更新数组子项中的某个field"><a href="#3-4-2-更新数组子项中的某个field" class="headerlink" title="3.4.2 更新数组子项中的某个field"></a>3.4.2 更新数组子项中的某个field</h5><p>这里要借用占位符 $ 来完成。 先看示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.Student.update(</span><br><span class="line">        &#123;</span><br><span class="line">            _id:ObjectId(&quot;52e8fce17ee72c8860511af6&quot;)</span><br><span class="line">            ,&quot;courses.code&quot;:&quot;001&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;$set&quot;:&#123;&quot;courses.$.name&quot;:&quot;MATH&quot;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        false,</span><br><span class="line">        true</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这个语句稍微解释一下：<br>a) 对于更新的查询条件，务必加 【”courses.code”:”001”】这一项，这样才能定位到数组中的具体项。这里我之前有一个疑惑，就是加不加【”courses.code”:”001”】都能查到同一条记录，为啥一定要加呢，主要是为了定位数组中的子项。</p><p>b) 有了 a)的解释，【”$set”:{“courses.$.name”:”MATH”}】中的 “$” 的意思就很好理解了，它就是用来定位数组子项当前项的，这两个写法缺一不可。</p><p>占位符$的使用在涉及到数组子项的查询也需要用到，后面的章节会说。</p><h3 id="4-query-查询"><a href="#4-query-查询" class="headerlink" title="4. query 查询"></a>4. query 查询</h3><p>查询操作其实比较简单了，mongodb提供了大量的操作符来做这个事情。之前我也说了mongodb的文档做得非常好，所以一些普通查询操作，直接翻文档吧，里面有语法，实例，非常棒。 <a href="http://docs.mongodb.org/manual/reference/operator/query/" target="_blank" rel="noopener">链接</a><br>这里我就不准备把文档翻译一遍了，我写一下在使用过程中一些必要但是稍微绕了一下的处理。</p><h4 id="4-1-优雅实现-between…and"><a href="#4-1-优雅实现-between…and" class="headerlink" title="4.1 优雅实现 between…and"></a>4.1 优雅实现 between…and</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.Student.find(&#123;</span><br><span class="line">    &quot;time&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;$gt&quot;:start,</span><br><span class="line">            &quot;$lt&quot;:end</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个结构对我的启发就是：我个人认为 $and 基本上是多余的。<br>之前用$and实现的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Student.find(&#123;</span><br><span class="line">    &quot;$and&quot;:[</span><br><span class="line">        &#123;&quot;time&quot;:&#123;&quot;$gt&quot;:start&#125;&#125;</span><br><span class="line">        ,&#123;&quot;time&quot;:&#123;&quot;$lt&quot;:end&#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样一对比，后者真的笨重而且多余。所以仔细想想，似乎所有的查询条件都不需要通过$and这样通过数组来实现呀，Map结构本来就支持多键存放的嘛。</p><h4 id="4-2-‘like’-的新样子"><a href="#4-2-‘like’-的新样子" class="headerlink" title="4.2  ‘like’ 的新样子"></a>4.2  ‘like’ 的新样子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.Student.find(&#123;</span><br><span class="line">    &quot;name&quot;:</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;$regex&quot;:&quot;/abc[dD]&#123;1&#125;/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正则表达式来实现like的功能，而且更为强大，唯一需要考虑的就是效率问题。这里顺带也把全文搜索也牵出来了，范围太大了，以后单独讲。</p><h3 id="4-3-数组子项的查询，中规中矩的-elemMatch-还是有更方便的写法？"><a href="#4-3-数组子项的查询，中规中矩的-elemMatch-还是有更方便的写法？" class="headerlink" title="4.3 数组子项的查询，中规中矩的$elemMatch,还是有更方便的写法？"></a>4.3 数组子项的查询，中规中矩的$elemMatch,还是有更方便的写法？</h3><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.Student.find(&#123;</span><br><span class="line">      &quot;courses&quot;:&#123;</span><br><span class="line">            &quot;$elemMatch&quot;:&#123;&quot;code&quot;:&quot;001&quot;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>偶然发现还有一个超级简单的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.Student.find(&#123;</span><br><span class="line">      &quot;courses.code&quot;:&quot;001&quot;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这里很容易引起混淆，到底Student的数据结构是怎么样的？【courses】这个字段类型是Map子文档（map）还是数组子文档（List）呢？ 实际上只要它是二者中的任何一种，都可以用上面的写法查询出来。</p><h3 id="4-4-根据数组子项查询，希望只返回查询到的数组子项，应该怎么写？"><a href="#4-4-根据数组子项查询，希望只返回查询到的数组子项，应该怎么写？" class="headerlink" title="4.4 根据数组子项查询，希望只返回查询到的数组子项，应该怎么写？"></a>4.4 根据数组子项查询，希望只返回查询到的数组子项，应该怎么写？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.students.find( </span><br><span class="line">            &#123;_id:ObjectId(&quot;6718703038737487484498&quot;)</span><br><span class="line">              , &quot;courses.code&quot;: &quot;001&quot; </span><br><span class="line">            &#125;,</span><br><span class="line">            &#123; &quot;courses.$&quot;: 1 &#125;)</span><br></pre></td></tr></table></figure><p>这里find方法使用了第二个参数，【courses.$】又看到了熟悉的占位符了，这里的作用还是一样，就是定位到query参数中查询到的子项，并只返回这个子项。</p><p>其实查询操作还有很多地方没有说到，例如基于位置的查询，全文搜索等。但是只要了解了本文所说的篇幅，日常开发中应该大部分也够了。<br>查询操作避不开的话题就是效率问题，我会单独写一篇这方面的文章，从索引，锁机制等探讨一下在mongodb中查询和更新等操作需要注意的问题。</p><p>综上，基本的操作都说了一下，我觉得还是多翻文档，用多了自然就熟了。</p>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和小点哥相处的这三天</title>
      <link href="/2014/01/22/%E5%92%8C%E5%B0%8F%E7%82%B9%E5%93%A5%E7%9B%B8%E5%A4%84%E7%9A%84%E8%BF%99%E4%B8%89%E5%A4%A9/"/>
      <url>/2014/01/22/%E5%92%8C%E5%B0%8F%E7%82%B9%E5%93%A5%E7%9B%B8%E5%A4%84%E7%9A%84%E8%BF%99%E4%B8%89%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<p>在小点哥出生之前，他外婆就一直在这边照顾我们了，小点哥出生后，虽然事情多些，但生活品质也真够得上饭来张口的奢华度。现在年底了，外婆家里也有些事情得回去，而他奶奶还要几天才能过得来，不管愿意不愿意，小点哥得和我混几天了。</p><p>我实在是咬牙硬着头皮上的，穿衣服，换尿片，喂饭，哄睡觉我一个都不会。我是这么想的，再麻烦也只有3天，应该没有问题的。就当给自己放个小长假，感受下婴孩的时光该怎么度过。</p><h3 id="1-第一天，生涩"><a href="#1-第一天，生涩" class="headerlink" title="1. 第一天，生涩"></a>1. 第一天，生涩</h3><p>老婆怕我搞不定，就请来了另外一朋友帮忙。早上7点多，老婆就要出门上班了，而这个时候小点哥也基本上会醒来，朋友还在隔壁睡大觉没起来呢，没有依靠了，只能硬着头皮给小点哥穿衣服了。因为是冬天，要穿的衣服特别多，一层套着一层，幸好现在的衣服设计的还蛮合理，基本上轻轻松松就能套进去，点点现在会表达了，只要不舒服，就会嚷嚷“哎哟，哎哟”，穿衣服的过程还蛮顺利，没有啥大障碍。比较头疼的是穿尿不湿，如果已经穿好了衣服来换的话，需要伸手到衣服里面去取尿不湿的粘扣，这个时候小点哥肯定反抗，我第一次弄的时候简直急的不行，点点在唧唧哼哼的叫着，我以为是弄痛他了，后面叫了朋友弄才弄好的。</p><p>因为有朋友在这边，我们计划吃了早餐就去梅溪湖玩一个上午，然后下午我自己带点点。因为是周一，梅溪湖基本上没啥人，阳光又很好，如果不是带着点点的话，那让我晒一天太阳我都答应。点点在梅溪湖还玩得很开心的，一路都是要自己走，回来的时候估计累了，歪着脖子趴在车子上就睡着了，对这个我又没有经验，生怕弄醒了他，都不敢动他，路上有个阿姨说他这样睡会落枕的，要扶正一下，我只要硬着把他轻轻往后扶了下，他居然没有醒来，刚到楼下的时候，老婆打电话来，她说怕我不会哄他睡觉，从上班的地方赶回来哄他。</p><p>中午的时候小点哥最容易睡着，我也实在累了，就也准备午睡一下。老婆哄他入睡的时候自己也睡着了，多睡了一个小时，她和我说了一句就匆匆去公司了，我反正没啥事情，就继续睡觉，但是这是感觉心里没底气了，生怕点点突然醒来，我一点招也没有。但是今天他居然睡到了4点多，下午都快过完了，我们就起来出去转下晒下太阳，就等他妈妈下班了。第一天就这么过了，不知道是快还是慢。</p><h3 id="2-第二天，旅行"><a href="#2-第二天，旅行" class="headerlink" title="2.  第二天，旅行"></a>2.  第二天，旅行</h3><p>昨天来的朋友很贴心，她走的时候说：如果你搞不定，明天带来我们家吧。哈哈，就这么定了，明天去他们家呆一下，不就又是一天嘛。</p><p>一大早点点就醒来了，所有的事情和昨天一样，穿衣服，换尿片，然后就是陪他玩一下，给他讲下故事，差不多八点半的时候，我准备喂他吃的了，这小破孩有一坏习惯，在家基本上吃不下东西，必须在我们家楼下一边玩一边吃，没办法了，我把他抱下去，陪他一边捉迷藏，一边趁他高兴的时候把饭给喂了。</p><p>吃完饭以后就给他收拾好准备坐车去朋友家了。坐公交车又是一头疼的事情，点点在车上从来不安分，拉着周围的人念叨那都不叫事，他基本上要把没看到过的东西全摸一边。因为经过老婆的公司，所以我们中间停留了一下，老婆抽空溜了出来，点点这个时候粘人的意识还不是特别强，只要有人陪他玩，他不会太在意身边的人突然消失或是出现。所以他妈妈出现的时候他也没太大反应，我们呆了一会儿后就又坐车去朋友家了，在车上碰到一老爷爷，小点哥非要拉着老人玩，这样也好，我基本上不用这么费力了。</p><p>在朋友家吃饭以后，她的小孩早就迫不及待要睡觉了，小点哥一点睡意也没有，自己一个人在地上玩积木，没办法了，我只能看着他。朋友说附近的学校里面有个天鹅池，里面有蛮多天鹅，我们可以去看看。等她小孩醒来以后，我们就出发了，点点最喜欢出门了，一看到开门就迫不及待要我抱着出去。外面的太阳真好，这个冬天真的过得很舒服，别说雪，连雨都少见，太阳暖洋洋的打在我们身上，小点哥还没走两步就睡着了，真的太神奇了，我就找了一个地方坐着，让小点哥好好睡一觉。他大概睡了1个小时吧，就醒来了，看到天鹅的时候好激动的，不停的在喊“鹅，鹅，鹅”。</p><p>快到5点的时候，我就想先去他妈妈公司下面，然后一起回家。我们上车以后，小点哥这次居然非常安静，就那么老老实实的坐着，不知道的还以为他很文静呢。到了老婆公司楼下后不久，老婆出来了，我今天算是又混过去了。</p><h3 id="3-第三天，结束"><a href="#3-第三天，结束" class="headerlink" title="3. 第三天，结束"></a>3. 第三天，结束</h3><p>今天他爷爷奶奶要过来，应该中午的时候能到这边，我觉得那就等下吧，不出去玩了。</p><p>早上起来以后事情差不多，我基本上都比较熟了，但是今天尿片得我自己换了，这个我仔细琢磨了下，确认了几个要领，觉得应该也不难，后面实践的时候确实也还好，今天总共换了4个尿片吧，没啥问题，基本上一下子就搞定了。</p><p>中午去接爷爷奶奶的时候去早了，小点哥在车站里面看到来来往往的人群，有点不敢说话，或者有时候悄悄叫一句“哥哥”，我也实在抱不动，就在附近找了个银行的营业厅休息了一下。</p><p>接到爷爷奶奶的时候，点点一点都不认生，和他们玩的很开心。吃了午饭，我看他在揉眼睛，但是在家里怎么样都不肯睡觉，我就带他去楼下转悠，他一下子就睡着了，然后我就抱他回家睡了，我生怕把他一放到床上就醒来了，所以陪他睡了好一会儿。今天居然就这样也睡了2个小时，到此，应该所有的事情我都做了一遍吧，穿衣服，换尿片，喂饭，哄睡觉，还算是比较完整吧。</p><pre><code>这三天算是体验了一下带小孩的不容易，事情都很简单，但是真的都需要耐心。也需要一点点智慧，了解小孩所想的。婴孩的生活真的很简单满足啊，一个捉迷藏游戏（躲在窗帘后面然后给个笑脸）能乐此不疲持续玩上10分钟，还有拔萝卜的小人书每天至少可以读6遍...... 不管怎样，这三天过得还不错，算是一个充实假期。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程中的生产者消费者场景</title>
      <link href="/2014/01/15/thread-producter-and-consumer/"/>
      <url>/2014/01/15/thread-producter-and-consumer/</url>
      
        <content type="html"><![CDATA[<p>生产者-消费者问题可以说是线程中最基础，最经典的场景了。它把并发编程中涉及到的一些常见概念都披露了出来，可以说是线程入门绕不开的场景。什么是’生产者-消费者问题’呢，通俗的定义就是：<br><strong>在指定容量的容器中，同时存在两种对象对容器进行生产或者消费的动作，由于容器的容量有限，使得”生产”不能太多（太多没有意义，容器装不下），“消费”不能无限（容器中不一定含有那么多消费量）。</strong>具体详情可以参见<a href="http://zh.wikipedia.org/zh-cn/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" title="生产者消费者问题" target="_blank" rel="noopener">生产者消费者问题</a>。</p><p>在Java的线程模型中，我总结了对于这一问题的3种处理模式，可以分别比较一下。</p><h3 id="1-普通模式-synchronized-notify-await"><a href="#1-普通模式-synchronized-notify-await" class="headerlink" title="1.  普通模式 synchronized+notify+await"></a>1.  普通模式 synchronized+notify+await</h3><p>这种模式应该最为普遍，不需要了解JDK1.5以后的相关线程类工具，直接使用内置关键字synchronized保证线程访问的同步性，同时使用继承至Object对象的wait，notify方法可以根据业务需求控制线程的实际访问权限。详情如下，这里业务场景是：一个盘子一次只能装一个鸡蛋，分别有放鸡蛋的线程和取鸡蛋的线程对盘子进行存取操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Egg&gt; eggs = <span class="keyword">new</span> ArrayList&lt;Egg&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取鸡蛋的业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getEgg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (eggs.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Egg e = eggs.get(<span class="number">0</span>);</span><br><span class="line">        eggs.clear();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;get egg:"</span> + e.getName());</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放鸡蛋的业务逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putEgg</span><span class="params">(Egg egg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (eggs.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        eggs.add(egg);</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;put egg:"</span> + egg.getName());</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产者线程</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PutThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span>  Plate plate;</span><br><span class="line"></span><br><span class="line">       PutThread(Plate plate) &#123;</span><br><span class="line">           <span class="keyword">this</span>.plate = plate;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           plate.putEgg(<span class="keyword">new</span> Egg(<span class="string">"egg["</span> + RandomUtils.nextInt(<span class="number">10</span>) + <span class="string">"]"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者线程</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span>  Plate plate;</span><br><span class="line"></span><br><span class="line">        GetThread(Plate plate) &#123;</span><br><span class="line">            <span class="keyword">this</span>.plate = plate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               plate.getEgg();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Egg(String name) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        Plate p = <span class="keyword">new</span> Plate();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)  &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> PutThread(p)).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> GetThread(p)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-巧妙模式-Semaphore"><a href="#2-巧妙模式-Semaphore" class="headerlink" title="2. 巧妙模式 Semaphore"></a>2. 巧妙模式 Semaphore</h3><p>Semaphore 是JDK5推出线程工具类之一，JDK5推出的一系列线程工具类大大简化了并发编程，覆盖了一些常见的业务场景，后面我会有篇文章单独讲讲这些工具类。<br>下面看看如何用Semaphore 进行生产者消费者问题的解决思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewPlate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Semaphore fullSema = <span class="keyword">new</span> Semaphore(<span class="number">10</span>); <span class="comment">// 定义容器的最大容量条件</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore emptySema = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);<span class="comment">// 定义容器的最小容量条件</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);<span class="comment">// 这个非常重要，用来控制 消费/生产逻辑一次只有一个线程来访问，说白了就是模拟Synchronized的语义。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 先判断是否满了,语义就是wait()</span></span><br><span class="line">            fullSema.acquire();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保证一次只有一个线程访问，语义就是synchronized</span></span><br><span class="line">            mutex.acquire();</span><br><span class="line">            System.out.printf(<span class="string">"=====before set , current size:%d\n"</span>, list.size());</span><br><span class="line">            list.add(data);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.printf(<span class="string">"=====after set , current size:%d\n"</span>, list.size());</span><br><span class="line">            mutex.release();</span><br><span class="line">            <span class="comment">// 为空条件释放一个，语义就是notify()</span></span><br><span class="line">            emptySema.release();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object ret = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            emptySema.acquire();</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            System.out.printf(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;before get , current size:%d\n"</span>, list.size());</span><br><span class="line">            ret = list.remove(<span class="number">0</span>);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">            System.out.printf(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;after get, current size:%d\n"</span>, list.size());</span><br><span class="line">            mutex.release();</span><br><span class="line">            fullSema.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> NewPlate newPlate = <span class="keyword">new</span> NewPlate();</span><br><span class="line">        Thread setThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    newPlate.set(<span class="keyword">new</span> Object());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread getThead = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    newPlate.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setThread.start();</span><br><span class="line">        getThead.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-高阶模式-Lock-Condition"><a href="#3-高阶模式-Lock-Condition" class="headerlink" title="3. 高阶模式 Lock + Condition"></a>3. 高阶模式 Lock + Condition</h3><p>Lock 提供了与synchronized相似的语义，但是功能更为强大，我个人认为这种模式从语义上更好理解，更类似人类的语言逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">// 容器的容量</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Object&gt; buffer;  <span class="comment">// 容器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock;<span class="comment">// 锁，用来加锁 生产/消费逻辑，保证一次只有一个线程访问</span></span><br><span class="line">    <span class="keyword">private</span> Condition notFull;<span class="comment">//  非满条件，在容量已满的情况下，控制生产者继续生产</span></span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty;<span class="comment">// 非空条件，在容量是空的情况下，控制消费线程继续消费</span></span><br><span class="line"></span><br><span class="line">    BoundedBuffer() &#123;</span><br><span class="line">        maxSize = <span class="number">5</span>;</span><br><span class="line">        buffer = <span class="keyword">new</span> LinkedList&lt;Object&gt;();</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        notFull = lock.newCondition();</span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容量已满，则生产者等待</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.size() == maxSize) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.offer(data);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            System.out.printf(<span class="string">"set %s, size:%d\n"</span>, Thread.currentThread().getName(), buffer.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生产完毕，提醒所有消费者可以消费了</span></span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        Object ret = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 容量为空，则消费者等待</span></span><br><span class="line">            <span class="keyword">while</span> (buffer.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            ret = buffer.poll();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            System.out.printf(<span class="string">"get %s,get one, current size:%d\n"</span>, Thread.currentThread().getName(), buffer.size());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 消费完毕，提醒所有生产者者可以继续生产</span></span><br><span class="line">            notFull.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Setter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> BoundedBuffer boundedBuffer;</span><br><span class="line"></span><br><span class="line">        Setter(BoundedBuffer boundedBuffer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.boundedBuffer = boundedBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            boundedBuffer.set(<span class="keyword">new</span> Object());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Getter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> BoundedBuffer boundedBuffer;</span><br><span class="line"></span><br><span class="line">        Getter(BoundedBuffer boundedBuffer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.boundedBuffer = boundedBuffer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            boundedBuffer.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        BoundedBuffer boundedBuffer = <span class="keyword">new</span> BoundedBuffer();</span><br><span class="line">        Setter setter = <span class="keyword">new</span> Setter(boundedBuffer);</span><br><span class="line">        Getter getter = <span class="keyword">new</span> Getter(boundedBuffer);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Thread setThread = <span class="keyword">new</span> Thread(setter);</span><br><span class="line">            Thread getThread = <span class="keyword">new</span> Thread(getter);</span><br><span class="line">            setThread.start();</span><br><span class="line">            getThread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近一年读过的一些书</title>
      <link href="/2014/01/04/book-list/"/>
      <url>/2014/01/04/book-list/</url>
      
        <content type="html"><![CDATA[<p>今天整理了一下过去一年读过的书，发现还读了不少好书，在这里总结一下，看看能不能找出时间来重读并把相应的读书笔记给补上来。</p><h3 id="1-爱的五种语言"><a href="#1-爱的五种语言" class="headerlink" title="1. 爱的五种语言"></a>1. 爱的五种语言</h3><ul><li>完成度： 100%</li><li>评分：10分</li><li>个人评语：关于情感表达，此书做出了非常深刻的洞悉，书中提到的五种表达爱的方式，本人特别认可。作者对生活的观察之细致，思考之深刻，令人叹服。虽然作者有着基督徒的宗教背景，书中内容也引用的圣经也很多，但一点也不妨碍本书成为普通人可读的好书。PS，我也是基督徒，我的看法是，正是因为作者对圣经的熟悉，从中提炼出了对于婚姻部分的得着，书中的智慧才显得如此璀璨。</li></ul><h3 id="2-1984"><a href="#2-1984" class="headerlink" title="2. 1984"></a>2. 1984</h3><ul><li>完成度： 100%</li><li>评分： 10分</li><li>个人评语： 这本书我一口气，花了一天看完的。想想书中的描绘的世界存在过，并且还存在着，内心不难过是假的。</li></ul><h3 id="3-不抱怨的世界"><a href="#3-不抱怨的世界" class="headerlink" title="3. 不抱怨的世界"></a>3. 不抱怨的世界</h3><ul><li>完成度： 60%</li><li>评分： 5分</li><li>个人评语： 不接地气的书真的让我看着看着就睡着了。</li></ul><h3 id="4-战胜拖拉"><a href="#4-战胜拖拉" class="headerlink" title="4. 战胜拖拉"></a>4. 战胜拖拉</h3><ul><li>完成度： 20%</li><li>评分： 5分</li><li>个人评语：  那些激情满满的标题会误导你，以后永远不要相信拖拉是战胜得了的。</li></ul><h3 id="5-拖拉一点也无妨"><a href="#5-拖拉一点也无妨" class="headerlink" title="5. 拖拉一点也无妨"></a>5. 拖拉一点也无妨</h3><ul><li>完成度： 100%</li><li>评分： 9分</li><li>个人评语： 小书，一天应该就能翻完，但是绝对比给了你一大堆关于对付拖拉的解决方案的书要强。此书赢在接地气，告诉我拖拉应该去接受它，但是也应该有智慧来管理它，书中提出的结构化拖延真的是良药啊，同时告诉了我另一个道理，任何反人性的自制都长久不了，顺应人性的引导才有真正的果效。</li></ul><h3 id="6-把你的英语用起来"><a href="#6-把你的英语用起来" class="headerlink" title="6. 把你的英语用起来"></a>6. 把你的英语用起来</h3><ul><li>完成度： 40%</li><li>评分： 9分</li><li>个人评语： 谁说没读完就不能评分了，此书甚好，以至于我不敢一口气读完，我在哪个阶段我就读相应阶段的方案怎么了。</li></ul><h3 id="7-我们最幸福"><a href="#7-我们最幸福" class="headerlink" title="7. 我们最幸福"></a>7. 我们最幸福</h3><ul><li>完成度： 100%</li><li>评分： 9分</li><li>个人评语： 隔壁家正在发生的事情，《1984》的现实版。回头想想自己生活的国家，真的是运气太好了。有时候我真的在问上帝，为什么你允许这么邪恶的国家存在，那么多无助的人们在过着炼狱一般的生活，这样的日子何时才是尽头？</li></ul><h3 id="8-把时间当朋友"><a href="#8-把时间当朋友" class="headerlink" title="8. 把时间当朋友"></a>8. 把时间当朋友</h3><ul><li>完成度： 100%</li><li>评分： 8.5分</li><li>个人评语： 别被标题给吓跑了，真的算好书一本。 作者可以算得上真正在体验生活，思考生活的人，我对自己的期望就是能做到这样的状态就好。在生活中活出一些想法，真正的接地气。</li></ul><h3 id="9-怪诞行为学"><a href="#9-怪诞行为学" class="headerlink" title="9. 怪诞行为学"></a>9. 怪诞行为学</h3><ul><li>完成度： 100%</li><li>评分： 8分</li><li>个人评语： 在上班的路上看完的，书中的很多观点和实验让人大吃一惊，唯一的遗憾就是没有系统的组织起来。</li></ul><h3 id="10-浪潮之巅"><a href="#10-浪潮之巅" class="headerlink" title="10. 浪潮之巅"></a>10. 浪潮之巅</h3><ul><li>完成度： 30%</li><li>评分： 10分</li><li>个人评语： 想知道最近几十年发生了哪些惊心动魄的事情吗？来读一下这本书吧。</li></ul><h3 id="11-暗时间"><a href="#11-暗时间" class="headerlink" title="11. 暗时间"></a>11. 暗时间</h3><ul><li>完成度： 30%</li><li>评分: 8.5分</li><li>个人评语：  好书，感觉还有很多东西消化不了，暂时放放。</li></ul><p>书是读了不少，吸收的却不多呀，挺对不起这些优质而昂贵的书籍。去年Kindle Paper White 刚出来的时候，把持不住入手了。纯粹用来看书，算是小奢侈了吧。现在看来，挺值的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见，以及你好！</title>
      <link href="/2013/12/31/hello-and-bye/"/>
      <url>/2013/12/31/hello-and-bye/</url>
      
        <content type="html"><![CDATA[<pre><code>这段时间一直在折腾如何搭建一个个人技术博客，前前后后花了很多时间，因为太多的东西需要去选择，太多的东西需要去学习。偶然发现公司里面的一个小伙伴的博客非常棒，心里特别羡慕，和他交流了一下，他建议选择GitHub平台，里面有很多不错的优质博客组件，其中Hexo最为简单好用，我体验了一下Hexo，真的挺适合的，于是决定，嗯，就是它了。说巧不巧，从开始折腾到今天的第一篇博客，刚好花了1周左右，而今天是13年的最后一天，很有意思的时间点，希望自己以后能坚持写一写自己的想法和思考，算是一个新的开始吧，一种新的习惯吧。</code></pre><h2 id="折腾博客的过程"><a href="#折腾博客的过程" class="headerlink" title="折腾博客的过程"></a>折腾博客的过程</h2><p>这里主要想记录一下这个折腾的过程中所接触到的东西，算是梳理总结一下吧。</p><h3 id="1-Github"><a href="#1-Github" class="headerlink" title="1. Github"></a>1. Github</h3><pre><code>你得有一个 GitHub 账号，熟悉一下GitHub的使用方式及常用命令。</code></pre><h3 id="2-Hexo"><a href="#2-Hexo" class="headerlink" title="2. Hexo"></a>2. Hexo</h3><pre><code>这个是最核心的啦，把Hexo安装好，跟着它的文档，只用几个命令，就能轻松的搭建一个博客了。入门虽然容易，定制却是要花些时间的。</code></pre><h3 id="3-Markdown"><a href="#3-Markdown" class="headerlink" title="3. Markdown"></a>3. Markdown</h3><pre><code>哈哈，Hexo内置Markdown模板，这个当然得学了，Markdown简单易学，上手很快，用了就离不开。</code></pre><h3 id="4-Sublime"><a href="#4-Sublime" class="headerlink" title="4. Sublime"></a>4. Sublime</h3><pre><code>写博客当然要一个好的编辑器对不对，首推Sublime这个神器了，不过这个这个工具稍微有一些学习曲线，在Sublime上面折腾的事情主要有：*  第一件事就是把字体设大（默认的太小了）*  各种常用快捷键*  安装包管理插件*  安装Markdown插件*  建立自己的workspace</code></pre><h3 id="5-图片服务器"><a href="#5-图片服务器" class="headerlink" title="5. 图片服务器"></a>5. 图片服务器</h3><pre><code>准备一个资源服务器，七牛真的很不错。</code></pre><h3 id="6-评论系统"><a href="#6-评论系统" class="headerlink" title="6. 评论系统"></a>6. 评论系统</h3><pre><code>国内的话首推多说，配置起来还是花了不少时间，但是过程并不复杂</code></pre><h3 id="7-统计"><a href="#7-统计" class="headerlink" title="7. 统计"></a>7. 统计</h3><pre><code>我选了百度统计，这个都差不太多吧，随便选一个就好。</code></pre><h3 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h3><pre><code>还有个事情得提一下，首先得给机器装一个node环境，之前在Windows上面折腾了好久，各种繁琐，换了Mac，顺畅多了。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
